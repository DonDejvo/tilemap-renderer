<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tilemap Player Example</title>
    <style>
        body {
            margin: 0;
        }

        canvas {
            position: absolute;
            left: 0;
            top: 0;
            display: block;
        }

        #fps {
            position: fixed;
            left: 10px;
            top: 10px;
            color: white;
            font: 14px monospace;
            z-index: 9999;
            background: rgba(0, 0, 0, 0.3);
            padding: 2px 6px;
            border-radius: 4px;
        }

        .controls {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 160px;
            height: 160px;
            display: grid;
            grid-template-columns: 50px 50px 50px;
            grid-template-rows: 50px 50px 50px;
            gap: 5px;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            z-index: 9999;
        }

        .btn {
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            backdrop-filter: blur(4px);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 18px;
            font-weight: bold;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }

        .btn:active {
            background: rgba(255, 255, 255, 0.3);
        }

        .up {
            grid-column: 2;
            grid-row: 1;
        }

        .left {
            grid-column: 1;
            grid-row: 2;
        }

        .down {
            grid-column: 2;
            grid-row: 3;
        }

        .right {
            grid-column: 3;
            grid-row: 2;
        }
    </style>
</head>

<body>
    <div id="fps">FPS: 0</div>

    <div class="controls" id="controls">
        <div class="btn up" data-key="w">▲</div>
        <div class="btn left" data-key="a">◀</div>
        <div class="btn down" data-key="s">▼</div>
        <div class="btn right" data-key="d">▶</div>
    </div>

    <script type="module">
        import * as TilemapRenderer from "../src/TilemapRenderer.ts";

        const rendererContext = "webgpu";

        class KeyboardInput {
            constructor() {
                this.up = false;
                this.down = false;
                this.left = false;
                this.right = false;

                const setKey = (key, isDown) => {
                    switch (key.toLowerCase()) {
                        case "w": this.up = isDown; break;
                        case "s": this.down = isDown; break;
                        case "a": this.left = isDown; break;
                        case "d": this.right = isDown; break;
                    }
                };

                addEventListener("keydown", (e) => setKey(e.key, true));
                addEventListener("keyup", (e) => setKey(e.key, false));

                document.addEventListener("touchstart", (e) => e.preventDefault(), { passive: false });
                document.addEventListener("touchmove", (e) => e.preventDefault(), { passive: false });
                document.addEventListener("contextmenu", (e) => e.preventDefault());

                const controls = document.getElementById("controls");
                for (const btn of controls.querySelectorAll(".btn")) {
                    const key = btn.dataset.key;
                    const start = () => setKey(key, true);
                    const end = () => setKey(key, false);

                    btn.addEventListener("touchstart", start);
                    btn.addEventListener("mousedown", start);
                    btn.addEventListener("touchend", end);
                    btn.addEventListener("mouseup", end);
                    btn.addEventListener("mouseleave", end);
                }
            }
        }

        class Player {
            constructor(x, y) {
                this.sprite = new TilemapRenderer.Sprite({
                    tileset: TilemapRenderer.Tileset.getByName("MyTileset"),
                    tilesetRegion: { x: 0, y: 0 },
                    isStatic: false,
                    origin: "bottom"
                });

                this.position = new TilemapRenderer.Vector(x, y);
                this.velocity = new TilemapRenderer.Vector();
                this.speed = 100;

                this.sprite.position.copy(this.position);
                this.sprite.scale.set(32, 32);
            }

            update(dt, input) {
                this.velocity.set(0, 0);
                if (input.up) this.velocity.y += 1;
                if (input.down) this.velocity.y -= 1;
                if (input.left) this.velocity.x -= 1;
                if (input.right) this.velocity.x += 1;

                if (this.velocity.lenSq() > 0) {
                    this.velocity.unit().scale(this.speed * dt);
                    this.position.add(this.velocity);
                    this.sprite.position.copy(this.position);
                }
            }
        }

        const main = async () => {
            const fpsElem = document.getElementById("fps");
            let lastTime = 0;
            let frameCount = 0;
            let fps = 0;

            const camera = new TilemapRenderer.Camera(300, 150);
            const cameraLerpSpeed = 5;
            const input = new KeyboardInput();

            const zoomSpline = new TilemapRenderer.LinearSpline([1, 1.5, 1.2, 2, 1.8, 1]);
            const zoomDuration = 5;
            let zoomTime = 0;

            const myTilesetImage = await TilemapRenderer.assets.loadImage("/textures/tileset.png");
            const snowyLandsImage = await TilemapRenderer.assets.loadImage("/textures/RPGW_SnowyLands_v2.0/MainLev2.0_extruded.png");
            const snowyLandsDecorativeImage = await TilemapRenderer.assets.loadImage("/textures/RPGW_SnowyLands_v2.0/decorative.png");

            const exampleMap = await TilemapRenderer.Tilemap.load("/tilemaps/Example30x20.tmj", {
                ["SnowyLands"]: "/tilesets/SnowyLands.tsj",
                ["MyTileset"]: "/tilesets/MyTileset.tsj",
                ["SnowyLands_Decorative"]: "/tilesets/SnowyLands_Decorative.tsj"
            });

            const scene = new TilemapRenderer.Scene();
            let player = null;

            scene.addTilemap(exampleMap, {
                layers: [
                    { name: "Decorative", zIndex: 1 },
                    { name: "Entities", zIndex: 1 },
                ],
                onObject: (scene, obj, layer, zIndex) => {
                    switch (obj.name) {
                        case "tree_lg":
                            const tree = new TilemapRenderer.Sprite({
                                tileset: TilemapRenderer.Tileset.getByName("SnowyLands_Decorative"),
                                tilesetRegion: { x: 3, y: 20, width: 3, height: 4 },
                                zIndex,
                                isStatic: false,
                                origin: "bottom"
                            });
                            tree.scale.set(3 * layer.tilemap.tileWidth, 4 * layer.tilemap.tileHeight);
                            tree.position.set(obj.x, -obj.y);
                            scene.addSprite(tree);
                            break;

                        case "player":
                            player = new Player(obj.x, -obj.y);
                            player.sprite.zIndex = zIndex;
                            scene.addSprite(player.sprite);
                            break;
                    }
                }
            });

            const renderer = TilemapRenderer.createRenderer(rendererContext);
            document.body.appendChild(renderer.getCanvas());

            const resize = () => {
                const w = innerWidth, h = innerHeight;
                renderer.setSize(w, h);
                camera.updateProjection(w, h);
            };
            addEventListener("resize", resize);
            resize();

            renderer.addTextures(exampleMap.getTilesets(), {
                ["SnowyLands"]: snowyLandsImage,
                ["MyTileset"]: myTilesetImage,
                ["SnowyLands_Decorative"]: snowyLandsDecorativeImage
            });

            await renderer.init();
            renderer.setClearColor(new TilemapRenderer.Color(0.5, 0.5, 0.5));

            let lastRAF = 0;

            const draw = (t) => {
                requestAnimationFrame(draw);
                t *= 0.001;
                const dt = t - lastRAF;
                lastRAF = t;

                frameCount++;
                if (t - lastTime >= 1) {
                    fps = frameCount;
                    frameCount = 0;
                    lastTime = t;
                    fpsElem.textContent = `${rendererContext.toUpperCase()} - FPS: ${fps}`;
                }

                if (player) {
                    player.update(dt, input);

                    camera.position.lerp(player.position, 1 - Math.exp(-cameraLerpSpeed * dt));
                }

                zoomTime += dt;
                const zoomT = (zoomTime % zoomDuration) / zoomDuration * (zoomSpline.points.length - 1);
                camera.zoom = zoomSpline.getValue(zoomT);

                camera.update();

                renderer.render(scene, camera);
            };

            requestAnimationFrame(draw);
        };

        main();
    </script>
</body>

</html>