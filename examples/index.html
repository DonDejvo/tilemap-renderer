<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tilemap Player Example</title>
    <style>
        body {
            margin: 0;
            background-color: #000;
            overflow: hidden;
        }

        canvas {
            position: absolute;
            left: 0;
            top: 0;
            display: block;
        }

        #fps {
            position: fixed;
            left: 10px;
            top: 10px;
            color: white;
            font: 14px monospace;
            z-index: 9999;
            background: rgba(0, 0, 0, 0.3);
            padding: 2px 6px;
            border-radius: 4px;
        }

        .controls {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 160px;
            height: 160px;
            display: grid;
            grid-template-columns: 50px 50px 50px;
            grid-template-rows: 50px 50px 50px;
            gap: 5px;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            z-index: 9999;
        }

        .btn {
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            backdrop-filter: blur(4px);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 18px;
            font-weight: bold;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }

        .btn:active {
            background: rgba(255, 255, 255, 0.3);
        }

        .up {
            grid-column: 2;
            grid-row: 1;
        }

        .left {
            grid-column: 1;
            grid-row: 2;
        }

        .down {
            grid-column: 2;
            grid-row: 3;
        }

        .right {
            grid-column: 3;
            grid-row: 2;
        }
    </style>
</head>

<body>
    <div id="fps">FPS: 0</div>

    <div class="controls" id="controls">
        <div class="btn up" data-key="w">▲</div>
        <div class="btn left" data-key="a">◀</div>
        <div class="btn down" data-key="s">▼</div>
        <div class="btn right" data-key="d">▶</div>
    </div>

    <script type="module">
        import * as TilemapRenderer from "../src/TilemapRenderer.ts";

        const assetsUrl = "";
        const rendererContext = "webgpu";

        class KeyboardInput {
            constructor() {
                this.up = false;
                this.down = false;
                this.left = false;
                this.right = false;

                const setKey = (key, isDown) => {
                    switch (key.toLowerCase()) {
                        case "w": this.up = isDown; break;
                        case "s": this.down = isDown; break;
                        case "a": this.left = isDown; break;
                        case "d": this.right = isDown; break;
                    }
                };

                addEventListener("keydown", (e) => setKey(e.key, true));
                addEventListener("keyup", (e) => setKey(e.key, false));

                document.addEventListener("touchstart", (e) => e.preventDefault(), { passive: false });
                document.addEventListener("touchmove", (e) => e.preventDefault(), { passive: false });
                document.addEventListener("contextmenu", (e) => e.preventDefault());

                const controls = document.getElementById("controls");
                for (const btn of controls.querySelectorAll(".btn")) {
                    const key = btn.dataset.key;
                    const start = () => setKey(key, true);
                    const end = () => setKey(key, false);

                    btn.addEventListener("touchstart", start);
                    btn.addEventListener("mousedown", start);
                    btn.addEventListener("touchend", end);
                    btn.addEventListener("mouseup", end);
                    btn.addEventListener("mouseleave", end);
                }
            }
        }

        class Player {
            constructor(x, y) {
                this.sprite = new TilemapRenderer.Sprite({
                    tileset: TilemapRenderer.Tileset.getByName("BODY_skeleton"),
                    tilesetRegion: { x: 0, y: 0 },
                    isStatic: false
                });

                this.animator = new TilemapRenderer.Animator(this.sprite);

                this.position = new TilemapRenderer.Vector(x, y);
                this.velocity = new TilemapRenderer.Vector();

                this.speed = 80;

                this.sprite.position.copy(this.position);
                this.sprite.scale.set(64, 64);
                this.sprite.offset.set(-32, -64);

                this.direction = 2; // start as facing down
            }

            update(input, dt) {
                this.velocity.set(0, 0);

                if (input.up) { this.velocity.y -= 1; this.direction = 0; }
                if (input.down) { this.velocity.y += 1; this.direction = 2; }
                if (input.left) { this.velocity.x -= 1; this.direction = 1; }
                if (input.right) { this.velocity.x += 1; this.direction = 3; }

                const moving = this.velocity.lenSq() > 0;

                if (moving) {
                    this.velocity.unit().scale(this.speed);
                    this.position.add(this.velocity.clone().scale(dt));
                    this.sprite.position.copy(this.position);

                    this.animator.play({ x: 1, y: this.direction }, { repeat: true, restart: false }); // walking
                } else {
                    this.animator.play({ x: 0, y: this.direction }, { repeat: true, restart: false }); // idle
                }

                this.animator.update(dt);
            }

            getLookVector() {
                switch (this.direction) {
                    case 0: return new TilemapRenderer.Vector(0, -1);
                    case 1: return new TilemapRenderer.Vector(-1, 0);
                    case 2: return new TilemapRenderer.Vector(0, 1);
                    case 3: return new TilemapRenderer.Vector(1, 0);
                }
                return new TilemapRenderer.Vector(0, 0);
            }
        }


        const main = async () => {
            let w = 360, h = 480;
            const fpsElem = document.getElementById("fps");
            let frameCount = 0;
            let fps = 0;
            let dt = 0;
            let lastRAF = 0;
            let lastFPSUpdate = 0;

            const camera = new TilemapRenderer.Camera(w, h);
            const input = new KeyboardInput();

            const myTilesetImage = await TilemapRenderer.assets.loadImage(assetsUrl + "/textures/tileset.png");
            const snowyLandsImage = await TilemapRenderer.assets.loadImage(assetsUrl + "/textures/RPGW_SnowyLands_v2.0/MainLev2.0_extruded.png");
            const snowyLandsDecorativeImage = await TilemapRenderer.assets.loadImage(assetsUrl + "/textures/RPGW_SnowyLands_v2.0/decorative.png");
            const skeletonBodyImage = await TilemapRenderer.assets.loadImage(assetsUrl + "/textures/lpc_entry/png/walkcycle/BODY_skeleton.png");

            const skeletonBodyTileset = await TilemapRenderer.Tileset.load(assetsUrl + "/tilesets/BODY_skeleton.tsj");

            const exampleMap = await TilemapRenderer.Tilemap.load(assetsUrl + "/tilemaps/Example30x20.tmj", {
                ["SnowyLands"]: assetsUrl + "/tilesets/SnowyLands.tsj",
                ["MyTileset"]: assetsUrl + "/tilesets/MyTileset.tsj",
                ["SnowyLands_Decorative"]: assetsUrl + "/tilesets/SnowyLands_Decorative.tsj"
            });

            const scene = new TilemapRenderer.Scene();
            let player = null;

            scene.addTilemap(exampleMap, {
                layers: [
                    { name: "Decorative", zIndex: 1 },
                    { name: "Entities", zIndex: 1 },
                ],
                onObject: (scene, obj, layer, zIndex) => {
                    switch (obj.name) {
                        case "tree_lg":
                            const tree = new TilemapRenderer.Sprite({
                                tileset: TilemapRenderer.Tileset.getByName("SnowyLands_Decorative"),
                                tilesetRegion: { x: 3, y: 20, width: 3, height: 4 },
                                zIndex,
                                isStatic: false
                            });
                            tree.offset.set(-1.5 * layer.tilemap.tileWidth, -4 * layer.tilemap.tileHeight + 4);
                            tree.scale.set(3 * layer.tilemap.tileWidth, 4 * layer.tilemap.tileHeight);
                            tree.position.set(obj.x, obj.y);
                            scene.addSprite(tree);
                            break;

                        case "player":
                            player = new Player(obj.x, obj.y);
                            player.sprite.zIndex = zIndex;
                            scene.addSprite(player.sprite);
                            break;
                    }
                }
            });

            const renderer = TilemapRenderer.createRenderer(rendererContext);
            document.body.appendChild(renderer.getCanvas());

            camera.updateProjection(w, h);
            renderer.setSize(w, h);

            renderer.addTextures(exampleMap.getTilesets(), {
                ["SnowyLands"]: snowyLandsImage,
                ["MyTileset"]: myTilesetImage,
                ["SnowyLands_Decorative"]: snowyLandsDecorativeImage
            });

            renderer.addTextures([skeletonBodyTileset], { ["BODY_skeleton"]: skeletonBodyImage });

            const builder = new TilemapRenderer.ShaderBuilder();

            builder
                .declare("center", "vec2")
                .declare("dist", "float")
                .declare("pulse", "float")
                .declare("inverted", "vec3")
                .declare("modifiedColor", "vec3")
                .set("center", "0.5 * $resolution.xy")
                .set("dist", "2.0 * length($fragCoord - center) / min($resolution.x, $resolution.y)")
                .set("pulse", "0.25 + 0.75 * sin($time * 0.5)")
                .set("inverted", "vec3(1.0) - fragColor.rgb")
                .set("modifiedColor", "mix(inverted, vec3(0.0), dist * pulse)")
                .set("fragColor", "vec4(modifiedColor, fragColor.a)");

            renderer.addShader("myShader", builder);

            await renderer.init();
            renderer.setClearColor(new TilemapRenderer.Color(0.5, 0.5, 0.5));
            renderer.setShader("myShader");

            const draw = () => {
                requestAnimationFrame(now => {
                    draw();

                    now *= 0.001;

                    dt = now - (lastRAF || now);
                    lastRAF = now;

                    // Update FPS
                    frameCount++;
                    if (now - lastFPSUpdate >= 1) {
                        fps = frameCount;
                        frameCount = 0;
                        lastFPSUpdate = now;
                        fpsElem.textContent = `${rendererContext.toUpperCase()} - FPS: ${fps}`;
                    }

                    // Update game logic
                    if (player) {
                        player.update(input, dt);

                        const targetCameraPos = player.position.clone()
                            .sub(new TilemapRenderer.Vector(w * 0.5, h * 0.5));

                        targetCameraPos.set(Math.round(targetCameraPos.x), Math.round(targetCameraPos.y));

                        // smooth movement
                        const lerpDistance = TilemapRenderer.Vector.distance(targetCameraPos, camera.position);
                        if (lerpDistance > 5) {
                            camera.position.lerp(targetCameraPos, Math.min(1, 5 * dt));
                        }

                        camera.update();
                    }

                    camera.update();
                    renderer.render(scene, camera);
                });
            }

            draw();
        };

        main();
    </script>
</body>

</html>