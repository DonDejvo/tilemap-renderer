<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tilemap Player Example</title>
    <style>
        body {
            margin: 0;
            background-color: #000;
            overflow: hidden;
        }

        canvas {
            position: absolute;
            left: 0;
            top: 0;
            display: block;
        }

        #fps {
            position: fixed;
            left: 10px;
            top: 10px;
            color: white;
            font: 14px monospace;
            z-index: 9999;
            background: rgba(0, 0, 0, 0.3);
            padding: 2px 6px;
            border-radius: 4px;
        }

        .controls {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 160px;
            height: 160px;
            display: grid;
            grid-template-columns: 50px 50px 50px;
            grid-template-rows: 50px 50px 50px;
            gap: 5px;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            z-index: 9999;
        }

        .btn {
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            backdrop-filter: blur(4px);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 18px;
            font-weight: bold;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }

        .btn:active {
            background: rgba(255, 255, 255, 0.3);
        }

        .up {
            grid-column: 2;
            grid-row: 1;
        }

        .left {
            grid-column: 1;
            grid-row: 2;
        }

        .down {
            grid-column: 2;
            grid-row: 3;
        }

        .right {
            grid-column: 3;
            grid-row: 2;
        }

        .action {
            position: fixed;
            bottom: 40px;
            right: 40px;
            width: 70px;
            height: 70px;
            background: rgba(255, 80, 80, 0.4);
            border-radius: 50%;
            border: 3px solid rgba(255, 120, 120, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 22px;
            z-index: 9999;
        }

        .action:active {
            background: rgba(255, 100, 100, 0.7);
        }
    </style>
</head>

<body>
    <div id="fps">FPS: 0</div>

    <div class="controls" id="controls">
        <div class="btn up" data-key="w">▲</div>
        <div class="btn left" data-key="a">◀</div>
        <div class="btn down" data-key="s">▼</div>
        <div class="btn right" data-key="d">▶</div>
        <div class="btn action" data-key="e">●</div>
    </div>

    <script type="module">
        import * as TilemapRenderer from "../src/TilemapRenderer.ts";

        const assetsUrl = "";
        const rendererContext = "webgpu";
        let k = 8;

        class KeyboardInput {
            constructor() {
                this.up = false;
                this.down = false;
                this.left = false;
                this.right = false;
                this.action = false;

                // NEW: edge detection flags
                this._prevAction = false;
                this.actionPressed = false;

                const setKey = (key, isDown) => {
                    switch (key.toLowerCase()) {
                        case "w": this.up = isDown; break;
                        case "s": this.down = isDown; break;
                        case "a": this.left = isDown; break;
                        case "d": this.right = isDown; break;
                        case "e": this.action = isDown; break;
                    }
                };

                addEventListener("keydown", e => setKey(e.key, true));
                addEventListener("keyup", e => setKey(e.key, false));

                document.addEventListener("touchstart", e => e.preventDefault(), { passive: false });
                document.addEventListener("touchmove", e => e.preventDefault(), { passive: false });
                document.addEventListener("contextmenu", e => e.preventDefault());

                const controls = document.getElementById("controls");
                for (const btn of controls.querySelectorAll(".btn")) {
                    const key = btn.dataset.key;
                    const start = () => setKey(key, true);
                    const end = () => setKey(key, false);

                    btn.addEventListener("touchstart", start);
                    btn.addEventListener("mousedown", start);
                    btn.addEventListener("touchend", end);
                    btn.addEventListener("mouseup", end);
                    btn.addEventListener("mouseleave", end);
                }
            }

            // call this ONCE per frame at beginning of update loop
            update() {
                this.actionPressed = this.action && !this._prevAction;
                this._prevAction = this.action;
            }
        }


        class Player {
            constructor(x, y, emitter) {
                this.sprite = new TilemapRenderer.Sprite({
                    tileset: TilemapRenderer.Tileset.getByName("BODY_skeleton"),
                    tilesetRegion: { x: 0, y: 0 },
                    isStatic: false
                });

                this.animator = new TilemapRenderer.Animator(this.sprite);

                this.position = new TilemapRenderer.Vector(x, y);
                this.velocity = new TilemapRenderer.Vector();

                this.speed = 80;

                this.sprite.position.copy(this.position);
                this.sprite.scale.set(64, 64);
                this.sprite.offset.set(-32, -64);

                this.direction = 2; // start as facing down
                this.isCasting = false;
                this.emitter = emitter;
            }

            update(input, dt) {
                this.velocity.set(0, 0);

                if (!this.isCasting && input.actionPressed) {
                    this.isCasting = true;
                    this.animator.play({ x: 0, y: 4 + this.direction }, { repeat: false, restart: true });
                    this.animator.onEnded = () => {
                        const look = this.getLookVector();
                        const px = this.position.x + look.x * 80;
                        const py = this.position.y + look.y * 80;
                        this.emitter.emit(px, py, this.sprite.zIndex);
                        this.isCasting = false;
                        this.animator.onEnded = null;
                    };
                }

                if (!this.isCasting) {
                    if (input.up) { this.velocity.y -= 1; this.direction = 0; }
                    if (input.down) { this.velocity.y += 1; this.direction = 2; }
                    if (input.left) { this.velocity.x -= 1; this.direction = 1; }
                    if (input.right) { this.velocity.x += 1; this.direction = 3; }

                    const moving = this.velocity.lenSq() > 0;

                    if (moving) {
                        this.velocity.unit().scale(this.speed);
                        this.position.add(this.velocity.clone().scale(dt));
                        this.sprite.position.copy(this.position);

                        this.animator.play({ x: 1, y: this.direction }, { repeat: true, restart: false }); // walking
                    } else {
                        this.animator.play({ x: 0, y: this.direction }, { repeat: true, restart: false }); // idle
                    }
                }

                this.animator.update(dt);
            }

            getLookVector() {
                switch (this.direction) {
                    case 0: return new TilemapRenderer.Vector(0, -1);
                    case 1: return new TilemapRenderer.Vector(-1, 0);
                    case 2: return new TilemapRenderer.Vector(0, 1);
                    case 3: return new TilemapRenderer.Vector(1, 0);
                }
                return new TilemapRenderer.Vector(0, 0);
            }
        }

        class Particle {
            constructor(x, y, zIndex, tileset) {
                this.sprite = new TilemapRenderer.Sprite({
                    tileset: tileset,
                    tilesetRegion: { x: 0, y: 0 }, // animated region
                    isStatic: false,
                    zIndex
                });
                this.sprite.maskColor.set(1, 1, 1, 1);

                this.sprite.position.set(x, y);
                this.sprite.scale.set(32, 32);
                this.sprite.offset.set(-16, -48);

                this.animator = new TilemapRenderer.Animator(this.sprite);
                this.animator.play({ x: 0, y: 0 }, { repeat: false });

                this.onDead = null;

                this.animator.onEnded = () => {
                    if (this.onDead) this.onDead();
                };
            }

            update(dt) {
                this.animator.update(dt);
            }
        }

        class ParticleEmitter {
            constructor(scene, tileset) {
                this.scene = scene;
                this.tileset = tileset;
                this.particles = [];
            }

            emit(x, y, zIndex) {
                const p = new Particle(x, y, zIndex, this.tileset);

                // auto-remove after animation ends
                p.onDead = () => {
                    this.scene.removeSprite(p.sprite);
                    this.particles = this.particles.filter(pp => pp !== p);
                };

                this.particles.push(p);
                this.scene.addSprite(p.sprite);
            }

            update(dt) {
                for (const p of this.particles) {
                    p.update(dt);
                }
            }
        }


        const main = async () => {
            let w = 360, h = 480;
            const fpsElem = document.getElementById("fps");
            let frameCount = 0;
            let fps = 0;
            let dt = 0;
            let lastRAF = 0;
            let lastFPSUpdate = 0;

            const camera = new TilemapRenderer.Camera(w, h);
            const input = new KeyboardInput();

            const myTilesetImage = await TilemapRenderer.assets.loadImage(assetsUrl + "/textures/tileset.png");
            const snowyLandsImage = await TilemapRenderer.assets.loadImage(assetsUrl + "/textures/RPGW_SnowyLands_v2.0/MainLev2.0_extruded.png");
            const snowyLandsDecorativeImage = await TilemapRenderer.assets.loadImage(assetsUrl + "/textures/RPGW_SnowyLands_v2.0/decorative.png");
            const skeletonBodyImage = await TilemapRenderer.assets.loadImage(assetsUrl + "/textures/lpc_entry/png/BODY_skeleton.png");
            const FX16Image = await TilemapRenderer.assets.loadImage(assetsUrl + "/textures/FX/16.png");

            const skeletonBodyTileset = await TilemapRenderer.Tileset.load(assetsUrl + "/tilesets/BODY_skeleton.tsj");
            const FX16Tileset = await TilemapRenderer.Tileset.load(assetsUrl + "/tilesets/FX_16.tsj");

            const exampleMap = await TilemapRenderer.Tilemap.load(assetsUrl + "/tilemaps/Example30x20.tmj", {
                ["SnowyLands"]: assetsUrl + "/tilesets/SnowyLands.tsj",
                ["MyTileset"]: assetsUrl + "/tilesets/MyTileset.tsj",
                ["SnowyLands_Decorative"]: assetsUrl + "/tilesets/SnowyLands_Decorative.tsj"
            });

            const scene = new TilemapRenderer.Scene();
            let player = null;

            const emitter = new ParticleEmitter(scene, FX16Tileset);

            scene.addTilemap(exampleMap, {
                layers: [
                    { name: "Decorative", zIndex: 1 },
                    { name: "Entities", zIndex: 1 },
                ],
                onObject: (scene, obj, layer, zIndex) => {
                    switch (obj.name) {
                        case "tree_lg":
                            const tree = new TilemapRenderer.Sprite({
                                tileset: TilemapRenderer.Tileset.getByName("SnowyLands_Decorative"),
                                tilesetRegion: { x: 3, y: 20, width: 3, height: 4 },
                                zIndex,
                                isStatic: false
                            });
                            tree.offset.set(-1.5 * layer.tilemap.tileWidth, -4 * layer.tilemap.tileHeight + 4);
                            tree.scale.set(3 * layer.tilemap.tileWidth, 4 * layer.tilemap.tileHeight);
                            tree.position.set(obj.x, obj.y);
                            tree.tintColor.r = 0;
                            scene.addSprite(tree);
                            break;

                        case "player":
                            player = new Player(obj.x, obj.y, emitter);
                            player.sprite.zIndex = zIndex;
                            scene.addSprite(player.sprite);
                            break;
                    }
                }
            });

            const renderer = TilemapRenderer.createRenderer(rendererContext);
            document.body.appendChild(renderer.getCanvas());

            camera.updateProjection(w, h);
            renderer.setSize(w, h);

            renderer.addTextures(exampleMap.getTilesets(), {
                ["SnowyLands"]: snowyLandsImage,
                ["MyTileset"]: myTilesetImage,
                ["SnowyLands_Decorative"]: snowyLandsDecorativeImage
            });

            renderer.addTextures([skeletonBodyTileset, FX16Tileset], { ["BODY_skeleton"]: skeletonBodyImage, ["FX_16"]: FX16Image });

            const neonExtract = new TilemapRenderer.ShaderBuilder();

            neonExtract
                .uniform("threshold", "float")
                .declare("uv", "vec2")
                .declare("color", "vec4")
                .declare("b", "vec3")
                .set("uv", "fragCoord / uniforms.resolution")
                .set("color", "texture(0, uv)")
                .set("b", "max(color.rgb - vec3(uniforms.threshold), vec3(0.0))")
                // .set("fragColor", "vec4(b,1.0)");
                .if("b.r > 0.0")
                .set("fragColor", "vec4(color.rgb, 1.0)")
                .else()
                .set("fragColor", "vec4(vec3(0.0), 1.0)")
                .endif();

            const neonBlurH = new TilemapRenderer.ShaderBuilder();

            neonBlurH
                .declare("uv", "vec2")
                .declare("w", "float")
                .declare("sum", "vec4")
                .set("uv", "fragCoord / uniforms.resolution")
                .set("w", "1.0 / uniforms.resolution.x")
                .set("sum",
                    `(
                    texture(0, uv + vec2(-3.0 * w, 0.0)) * 0.05 +
                    texture(0, uv + vec2(-2.0 * w, 0.0)) * 0.1 +
                    texture(0, uv + vec2(-1.0 * w, 0.0)) * 0.2 +
                    texture(0, uv) * 0.3 +
                    texture(0, uv + vec2(1.0 * w, 0.0)) * 0.2 +
                    texture(0, uv + vec2(2.0 * w, 0.0)) * 0.1 +
                    texture(0, uv + vec2(3.0 * w, 0.0)) * 0.05
                )`
                )
                .set("fragColor", "sum");

            const neonBlurV = new TilemapRenderer.ShaderBuilder();

            neonBlurV
                .declare("uv", "vec2")
                .declare("h", "float")
                .declare("sum", "vec4")
                .set("uv", "fragCoord / uniforms.resolution")
                .set("h", "1.0 / uniforms.resolution.y")
                .set("sum",
                    `(
            texture(0, uv + vec2(0.0, -3.0 * h)) * 0.05 +
                    texture(0, uv + vec2(0.0, -2.0 * h)) * 0.1 +
                    texture(0, uv + vec2(0.0, -1.0 * h)) * 0.2 +
                    texture(0, uv) * 0.3 +
                    texture(0, uv + vec2(0.0, 1.0 * h)) * 0.2 +
                    texture(0, uv + vec2(0.0, 2.0 * h)) * 0.1 +
                    texture(0, uv + vec2(0.0, 3.0 * h)) * 0.05
                )`
                )
                .set("fragColor", "sum");

            const neonComposite = new TilemapRenderer.ShaderBuilder();

            neonComposite
                .declare("uv", "vec2")
                .declare("base", "vec4")
                .declare("glow", "vec4")
                .set("uv", "fragCoord / uniforms.resolution")
                .set("base", "texture(0, uv)")
                .set("glow", "texture(1, uv)")
                .set("fragColor", "vec4(base.rgb - glow.rgb, 1.0)");

            renderer.registerShader("blurX", neonBlurH);
            renderer.registerShader("blurY", neonBlurV);
            renderer.registerShader("neonExtract", neonExtract);
            renderer.registerShader("neonComposite", neonComposite);

            await renderer.init();
            renderer.setClearColor(new TilemapRenderer.Color(0.5, 0.5, 0.5));

            renderer.pass = [
                // downscale to quarter
                { shader: "default", inputs: [1], output: k },

                // neon glow extraction
                { shader: "neonExtract", inputs: [k], output: k + 1, uniforms: [{ name: "threshold", value: 0.5 }] },

                // blur
                { shader: "blurX", inputs: [k + 1], output: k },
                { shader: "blurY", inputs: [k], output: k + 1 },

                // composite with original full scene
                { shader: "neonComposite", inputs: [0, k + 1], output: -1 }
            ];

            const draw = () => {
                requestAnimationFrame(now => {
                    draw();

                    now *= 0.001;

                    dt = now - (lastRAF || now);
                    lastRAF = now;

                    // Update FPS
                    frameCount++;
                    if (now - lastFPSUpdate >= 1) {
                        fps = frameCount;
                        frameCount = 0;
                        lastFPSUpdate = now;
                        fpsElem.textContent = `${rendererContext.toUpperCase()} - FPS: ${fps}`;
                    }

                    input.update();

                    // Update game logic
                    if (player) {
                        player.update(input, dt);

                        const targetCameraPos = player.position.clone()
                            .sub(new TilemapRenderer.Vector(w * 0.5, h * 0.5));

                        targetCameraPos.set(Math.round(targetCameraPos.x), Math.round(targetCameraPos.y));

                        // smooth movement
                        const lerpDistance = TilemapRenderer.Vector.distance(targetCameraPos, camera.position);
                        if (lerpDistance > 5) {
                            camera.position.lerp(targetCameraPos, Math.min(1, 5 * dt));
                        }

                        camera.update();
                    }

                    camera.update();
                    emitter.update(dt);

                    renderer.render(scene, camera);
                });
            }

            draw();
        };

        main();
    </script>
</body>

</html>