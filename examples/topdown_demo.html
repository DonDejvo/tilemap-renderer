<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Topdown Demo</title>
    <style>
        html,
        body {
            margin: 0;
            height: 100%;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #fps {
            position: fixed;
            left: 10px;
            top: 10px;
            color: white;
            font: 14px monospace;
            z-index: 9999;
            background: rgba(0, 0, 0, 0.3);
            padding: 2px 6px;
            border-radius: 4px;
        }

        .controls {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 160px;
            height: 160px;
            display: grid;
            grid-template-columns: 50px 50px 50px;
            grid-template-rows: 50px 50px 50px;
            gap: 5px;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            z-index: 9999;
        }

        .btn {
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            backdrop-filter: blur(4px);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 18px;
            font-weight: bold;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }

        .btn:active {
            background: rgba(255, 255, 255, 0.3);
        }

        .up {
            grid-column: 2;
            grid-row: 1;
        }

        .left {
            grid-column: 1;
            grid-row: 2;
        }

        .down {
            grid-column: 2;
            grid-row: 3;
        }

        .right {
            grid-column: 3;
            grid-row: 2;
        }

        .action {
            position: fixed;
            bottom: 40px;
            right: 40px;
            width: 70px;
            height: 70px;
            background: rgba(255, 80, 80, 0.4);
            border-radius: 50%;
            border: 3px solid rgba(255, 120, 120, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 22px;
            z-index: 9999;
        }

        .action:active {
            background: rgba(255, 100, 100, 0.7);
        }
    </style>
</head>

<body>
    <div id="fps">FPS: 0</div>

    <div class="controls" id="controls">
        <div class="btn up" data-key="w">▲</div>
        <div class="btn left" data-key="a">◀</div>
        <div class="btn down" data-key="s">▼</div>
        <div class="btn right" data-key="d">▶</div>
        <div class="btn action" data-key="e">●</div>
    </div>

    <script type="module">
        import * as TilemapRenderer from "../src/TilemapRenderer.ts";

        const assetsUrl = "";
        const rendererContext = "webgpu";
        let k = 6;

        class KeyboardInput {
            constructor() {
                this.up = false;
                this.down = false;
                this.left = false;
                this.right = false;
                this.action = false;

                this._prevAction = false;
                this.actionPressed = false;

                const setKey = (key, isDown) => {
                    switch (key.toLowerCase()) {
                        case "w": this.up = isDown; break;
                        case "s": this.down = isDown; break;
                        case "a": this.left = isDown; break;
                        case "d": this.right = isDown; break;
                        case "e": this.action = isDown; break;
                    }
                };

                addEventListener("keydown", e => setKey(e.key, true));
                addEventListener("keyup", e => setKey(e.key, false));

                document.addEventListener("touchstart", e => e.preventDefault(), { passive: false });
                document.addEventListener("touchmove", e => e.preventDefault(), { passive: false });
                document.addEventListener("contextmenu", e => e.preventDefault());

                const controls = document.getElementById("controls");
                for (const btn of controls.querySelectorAll(".btn")) {
                    const key = btn.dataset.key;
                    const start = () => setKey(key, true);
                    const end = () => setKey(key, false);

                    btn.addEventListener("touchstart", start);
                    btn.addEventListener("mousedown", start);
                    btn.addEventListener("touchend", end);
                    btn.addEventListener("mouseup", end);
                    btn.addEventListener("mouseleave", end);
                }
            }

            update() {
                this.actionPressed = this.action && !this._prevAction;
                this._prevAction = this.action;
            }
        }


        class Player {
            constructor(scene, x, y, zIndex, emitter, tileset) {
                this.sprite = new TilemapRenderer.Sprite({
                    tileset,
                    tilesetRegion: { x: 0, y: 0 },
                    isStatic: false,
                    zIndex
                });
                this.sprite.maskColor.set(1, 1, 1, 1);
                scene.addSprite(this.sprite);

                this.animator = new TilemapRenderer.Animator(this.sprite);

                this.position = new TilemapRenderer.Vector(x, y);
                this.velocity = new TilemapRenderer.Vector();

                this.speed = 80;

                this.sprite.position.copy(this.position);
                // this.sprite.scale.set(64, 64);
                this.sprite.offset.set(-32, -64);

                this.direction = 2;
                this.isCasting = false;
                this.emitter = emitter;

                this.collider = new TilemapRenderer.colliders.BoxCollider(24, 12);
                scene.addCollider(this.collider);
            }

            update(input, dt) {
                this.velocity.set(0, 0);

                if (!this.isCasting && input.actionPressed) {
                    this.isCasting = true;
                    this.animator.play({ x: 0, y: 4 + this.direction }, { repeat: false, restart: true });
                    this.animator.onEnded = () => {
                        const look = this.getLookVector();
                        const px = this.position.x + look.x * 16;
                        const py = this.position.y - 16 + look.y * 16;
                        this.emitter.emit(px, py, look, this.sprite.zIndex);
                        this.isCasting = false;
                        this.animator.onEnded = null;
                    };
                }

                if (!this.isCasting) {
                    if (input.up) { this.velocity.y -= 1; this.direction = 0; }
                    if (input.down) { this.velocity.y += 1; this.direction = 2; }
                    if (input.left) { this.velocity.x -= 1; this.direction = 1; }
                    if (input.right) { this.velocity.x += 1; this.direction = 3; }

                    const moving = this.velocity.lenSq() > 0;

                    if (moving) {
                        this.velocity.normalize().scale(this.speed);
                        this.position.add(this.velocity.clone().scale(dt));

                        this.animator.play({ x: 1, y: this.direction }, { repeat: true, restart: false }); // walking
                    } else {
                        this.animator.play({ x: 0, y: this.direction }, { repeat: true, restart: false }); // idle
                    }

                    this.sprite.position.copy(this.position);
                    this.collider.position.copy(this.position);
                }

                this.animator.update(dt);
            }

            getLookVector() {
                switch (this.direction) {
                    case 0: return new TilemapRenderer.Vector(0, -1);
                    case 1: return new TilemapRenderer.Vector(-1, 0);
                    case 2: return new TilemapRenderer.Vector(0, 1);
                    case 3: return new TilemapRenderer.Vector(1, 0);
                }
                return new TilemapRenderer.Vector(0, 0);
            }
        }

        class Particle {
            constructor(x, y, direction, zIndex, tileset, light) {
                this.sprite = new TilemapRenderer.Sprite({
                    tileset: tileset,
                    tilesetRegion: { x: 0, y: 0 },
                    isStatic: false,
                    zIndex
                });
                this.light = light;

                this.sprite.position.set(x, y);
                this.sprite.angle = direction.angle();
                // this.sprite.scale.set(64, 64);
                this.sprite.offset.set(-32, -32);

                this.direction = direction;

                this.animator = new TilemapRenderer.Animator(this.sprite);
                this.animator.play({ x: 0, y: 0 }, { repeat: false });

                this.onDead = null;
                this.startLifetime = 1.0;
                this.lifetime = this.startLifetime;
            }

            update(dt) {
                this.sprite.position.add(this.direction.clone().scale(160 * dt));
                this.animator.update(dt);
                this.light.position.copy(this.sprite.position.clone().add(this.direction.clone().scale(24)));
                this.lifetime -= dt;
                if (this.onDead && this.lifetime <= 0) {
                    this.onDead();
                }
            }
        }

        class ParticleEmitter {
            constructor(scene, tileset) {
                this.scene = scene;
                this.tileset = tileset;
                this.particles = [];
            }

            emit(x, y, direction, zIndex) {
                const light = new TilemapRenderer.Light({ radius: 16, color: new TilemapRenderer.Color(1, 0.7, 0.2) })
                const p = new Particle(x, y, direction, zIndex, this.tileset, light);

                this.particles.push(p);
                this.scene.addSprite(p.sprite);
                this.scene.addLight(light);

                p.onDead = () => {
                    this.scene.removeSprite(p.sprite);
                    this.scene.removeLight(light);
                    this.particles = this.particles.filter(pp => pp !== p);
                };
            }

            update(dt) {
                for (const p of this.particles) {
                    p.update(dt);
                }
            }
        }


        const main = async () => {
            let w = 1920, h = 1080;
            const fpsElem = document.getElementById("fps");
            let frameCount = 0;
            let fps = 0;
            let dt = 0;
            let lastRAF = 0;
            let lastFPSUpdate = 0;

            const camera = new TilemapRenderer.Camera(w, h);
            const input = new KeyboardInput();

            const myTilesetImage = await TilemapRenderer.assets.loadImage(assetsUrl + "/textures/tileset.png");
            const snowyLandsImage = await TilemapRenderer.assets.loadImage(assetsUrl + "/textures/RPGW_SnowyLands_v2.0/MainLev2.0_extruded.png");
            const snowyLandsDecorativeImage = await TilemapRenderer.assets.loadImage(assetsUrl + "/textures/RPGW_SnowyLands_v2.0/decorative.png");
            const skeletonBodyImage = await TilemapRenderer.assets.loadImage(assetsUrl + "/textures/lpc_entry/png/BODY_skeleton.png");
            const FX16Image = await TilemapRenderer.assets.loadImage(assetsUrl + "/textures/FX/579.png");

            const skeletonBodyTileset = await TilemapRenderer.Tileset.load(assetsUrl + "/tilesets/BODY_skeleton.tsj");
            const FX16Tileset = await TilemapRenderer.Tileset.load(assetsUrl + "/tilesets/FX_16.tsj");

            const exampleMap = await TilemapRenderer.Tilemap.load(assetsUrl + "/tilemaps/Example30x20.tmj", {
                ["SnowyLands"]: assetsUrl + "/tilesets/SnowyLands.tsj",
                ["MyTileset"]: assetsUrl + "/tilesets/MyTileset.tsj",
                ["SnowyLands_Decorative"]: assetsUrl + "/tilesets/SnowyLands_Decorative.tsj"
            });

            const scene = new TilemapRenderer.Scene({
                bounds: [new TilemapRenderer.Vector(0, 0), new TilemapRenderer.Vector(1000, 1000)]
            });
            scene.ambientIntensity = 0.1;
            scene.shadowsZIndex = 2;

            let player = null;

            const emitter = new ParticleEmitter(scene, FX16Tileset);

            scene.addTilemap(exampleMap, {
                layers: [
                    { name: "Decorative", zIndex: 1 },
                    { name: "Entities", zIndex: 1 },
                ],
                onObject: (scene, obj, layer, zIndex) => {
                    switch (obj.name) {
                        case "tree_lg":
                            for (let i = 0; i < 1; ++i) {
                                const tree = new TilemapRenderer.Sprite({
                                    tileset: exampleMap.getTilesetByName("SnowyLands_Decorative"),
                                    tilesetRegion: { x: 3, y: 20, width: 3, height: 4 },
                                    zIndex,
                                    isStatic: false
                                });
                                tree.offset.set(-1.5 * layer.tilemap.tileWidth, -4 * layer.tilemap.tileHeight + 4);
                                // tree.scale.set(3 * layer.tilemap.tileWidth, 4 * layer.tilemap.tileHeight);
                                tree.position.set(obj.x, obj.y);
                                scene.addSprite(tree);
                                const treeCollider = new TilemapRenderer.colliders.BoxCollider(2 * layer.tilemap.tileWidth - 12, 0.5 * layer.tilemap.tileWidth);
                                treeCollider.position.copy(tree.position);
                                scene.addCollider(treeCollider);
                            }
                            break;

                        case "player":
                            player = new Player(scene, obj.x, obj.y, zIndex, emitter, skeletonBodyTileset);
                            break;

                        case "light":
                            for (let i = 0; i < 1; ++i) {
                                const light = new TilemapRenderer.Light({
                                    radius: 240,
                                    cutoff: 0.7,
                                    direction: TilemapRenderer.Vector.fromAngle(TilemapRenderer.math.degToRad(obj.getProperty("angle") || 0))
                                });

                                light.position.set(obj.x, obj.y);
                                scene.addLight(light);
                            }
                            break;
                    }
                }
            });

            const light = new TilemapRenderer.Light({
                radius: 240
            });
            scene.addLight(light);

            console.log(scene.getInfo());

            const renderer = TilemapRenderer.createRenderer(rendererContext);
            document.body.appendChild(renderer.getCanvas());

            camera.updateProjection(w, h);
            renderer.setSize(w, h);

            renderer.addTextures(exampleMap.getTilesets(), {
                ["SnowyLands"]: snowyLandsImage,
                ["MyTileset"]: myTilesetImage,
                ["SnowyLands_Decorative"]: snowyLandsDecorativeImage
            });

            renderer.addTextures([skeletonBodyTileset, FX16Tileset], { ["BODY_skeleton"]: skeletonBodyImage, ["FX_16"]: FX16Image });

            const neonExtract = new TilemapRenderer.ShaderBuilder();

            neonExtract
                .uniform("threshold", "float")
                .declare("uv", "vec2")
                .declare("color", "vec4")
                .declare("b", "vec3")
                .set("uv", "fragCoord / uniforms.resolution")
                .set("color", "texture(0, uv)")
                .set("b", "max(color.rgb - vec3(uniforms.threshold), vec3(0.0))")
                .set("fragColor", "vec4(b,1.0)");

            const neonComposite = new TilemapRenderer.ShaderBuilder();

            neonComposite
                .declare("uv", "vec2")
                .declare("base", "vec4")
                .declare("glow", "vec4")
                .set("uv", "fragCoord / uniforms.resolution")
                .set("base", "texture(0, uv)")
                .set("glow", "texture(1, uv)")
                .set("fragColor", "vec4(base.rgb + glow.rgb, 1.0)");

            renderer.registerShader("neonExtract", neonExtract);
            renderer.registerShader("neonComposite", neonComposite);

            await renderer.init();
            renderer.setClearColor(new TilemapRenderer.Color(0.5, 0.5, 0.5));

            const observer = new ResizeObserver(entries => {
                for (const entry of entries) {
                    const width = w = entry.contentBoxSize[0].inlineSize;
                    const height = h = entry.contentBoxSize[0].blockSize;

                    renderer.setSize(width, height);
                    camera.vw = width;
                    camera.vh = height;
                }
            });

            observer.observe(renderer.getCanvas());

            renderer.pass = [
                // downscale to quarter
                { shader: "default", inputs: [1], output: k },

                // neon glow extraction
                { shader: "neonExtract", inputs: [k], output: k + 1, uniforms: [{ name: "threshold", value: 0.5 }] },

                // blur
                { shader: "blurHorizontal", inputs: [k + 1], output: k },
                { shader: "blurVertical", inputs: [k], output: k + 1 },

                // composite with original full scene
                { shader: "neonComposite", inputs: [0, k + 1], output: -1 }
            ];

            const draw = () => {
                requestAnimationFrame(now => {
                    draw();

                    now *= 0.001;

                    dt = now - (lastRAF || now);
                    lastRAF = now;

                    frameCount++;
                    if (now - lastFPSUpdate >= 1) {
                        fps = frameCount;
                        frameCount = 0;
                        lastFPSUpdate = now;
                        fpsElem.textContent = `${rendererContext.toUpperCase()} - FPS: ${fps}`;
                    }

                    input.update();

                    if (player) {
                        player.update(input, dt);

                        const targetCameraPos = player.position.clone()
                            .sub(new TilemapRenderer.Vector(w * 0.5, h * 0.5));

                        targetCameraPos.set(Math.round(targetCameraPos.x), Math.round(targetCameraPos.y));

                        const lerpDistance = TilemapRenderer.Vector.distance(targetCameraPos, camera.position);
                        if (lerpDistance > 5) {
                            camera.position.lerp(targetCameraPos, Math.min(1, 5 * dt));
                        }
                    }

                    emitter.update(dt);

                    scene.update();

                    renderer.render(scene, camera);
                });
            }

            draw();
        };

        main();
    </script>
</body>

</html>