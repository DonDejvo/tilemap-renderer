const S = {
  loadImage: (t) => new Promise((i, r) => {
    const s = new Image();
    s.crossOrigin = "anonymous", s.src = t, s.onload = () => {
      i(s);
    }, s.onerror = () => {
      r();
    };
  }),
  loadJson: async (t) => {
    const i = await fetch(t);
    if (!i.ok) throw new Error(`Failed to load: ${t}`);
    return await i.json();
  }
}, A = {
  identity: () => new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
  createOrtho: (t, i, r, s, a) => (t[0] = 2 / (r - i), t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 2 / (a - s), t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = -(r + i) / (r - i), t[13] = -(a + s) / (a - s), t[14] = 0, t[15] = 1, t)
};
class x {
  x;
  y;
  constructor(e = 0, t = 0) {
    this.x = e, this.y = t;
  }
  set(e, t) {
    return this.x = e, this.y = t, this;
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this;
  }
  clone() {
    return new x(this.x, this.y);
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this;
  }
  divideScalar(e) {
    return e !== 0 ? (this.x /= e, this.y /= e) : (this.x = 0, this.y = 0), this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  normalize() {
    const e = this.length();
    return e > 0 && this.divideScalar(e), this;
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSq(e));
  }
  distanceToSq(e) {
    const t = this.x - e.x, i = this.y - e.y;
    return t * t + i * i;
  }
  angle() {
    return Math.atan2(this.y, this.x);
  }
  rotate(e) {
    const t = Math.cos(e), i = Math.sin(e), r = this.x * t - this.y * i, s = this.x * i + this.y * t;
    return this.x = r, this.y = s, this;
  }
  setFromAngle(e, t = 1) {
    return this.x = Math.cos(e) * t, this.y = Math.sin(e) * t, this;
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this;
  }
  toString() {
    return `Vector(${this.x}, ${this.y})`;
  }
}
class N {
  vw;
  vh;
  projectionMatrix;
  position;
  constructor(e, t) {
    this.projectionMatrix = A.identity(), this.position = new x(), this.vw = 0, this.vh = 0, this.updateProjection(e, t);
  }
  updateProjection(e, t) {
    this.vw = e, this.vh = t, A.createOrtho(this.projectionMatrix, 0, e, 0, t);
  }
}
class p {
  r;
  g;
  b;
  a;
  constructor(e, t, i, r = 1) {
    this.r = e, this.g = t, this.b = i, this.a = r;
  }
  copy(e) {
    this.r = e.r, this.g = e.g, this.b = e.b, this.a = e.a;
  }
}
const f = {
  quad: new Float32Array([
    -0.5,
    0.5,
    0,
    0,
    -0.5,
    -0.5,
    0,
    1,
    0.5,
    0.5,
    1,
    0,
    0.5,
    -0.5,
    1,
    1
  ]),
  createSpritesData: (t) => {
    const i = [];
    for (const r of t)
      i.push(r.position.x, r.position.y, r.scale.x, r.scale.y, r.tilesetIdx);
    return new Float32Array(i);
  }
}, d = {
  getImageData: (t) => {
    if (t instanceof Uint8Array)
      return t;
    let i, r, s;
    t instanceof HTMLCanvasElement || t instanceof OffscreenCanvas ? (s = t, i = s.width, r = s.height) : (i = t.width, r = t.height, s = document.createElement("canvas"), s.width = i, s.height = r);
    const a = s.getContext("2d");
    if (!a) throw new Error("Could not get 2D context");
    return t instanceof HTMLCanvasElement || t instanceof OffscreenCanvas || a.drawImage(t, 0, 0), new Uint8Array(a.getImageData(0, 0, i, r).data);
  },
  isPowerOf2: (t) => t > 0 && (t & t - 1) === 0
};
class y {
  gl;
  program;
  uniforms;
  constructor(e, t, i) {
    this.gl = e, this.uniforms = /* @__PURE__ */ new Map();
    const r = this.compileShader(e.VERTEX_SHADER, t), s = this.compileShader(e.FRAGMENT_SHADER, i);
    if (this.program = e.createProgram(), e.attachShader(this.program, r), e.attachShader(this.program, s), e.linkProgram(this.program), !e.getProgramParameter(this.program, e.LINK_STATUS))
      throw new Error(e.getProgramInfoLog(this.program) ?? "Could not link program");
    e.deleteShader(r), e.deleteShader(s);
  }
  compileShader(e, t) {
    const i = this.gl.createShader(e);
    if (!i) throw new Error("Could not create shader");
    if (this.gl.shaderSource(i, t), this.gl.compileShader(i), !this.gl.getShaderParameter(i, this.gl.COMPILE_STATUS))
      throw new Error(this.gl.getShaderInfoLog(i) ?? "Could not compile shader");
    return i;
  }
  use() {
    this.gl.useProgram(this.program);
  }
  getUniform(e) {
    if (!this.uniforms.has(e)) {
      const t = this.gl.getUniformLocation(this.program, e);
      t || console.log("Could not get uniform location:", e), this.uniforms.set(e, t);
    }
    return this.uniforms.get(e);
  }
  getAttrib(e) {
    return this.gl.getAttribLocation(this.program, e);
  }
}
const P = `

attribute vec2 aVertexPos;
attribute vec2 aTexCoord;
attribute vec2 aTilePos;
attribute vec2 aTileScale;
attribute float aDepth;

uniform mat4 uProjectionMatrix;
uniform vec2 uCameraPos;
uniform vec2 uTilesetDimensions;

varying vec2 vTexCoord;

void main() {
    float col = mod(aDepth, uTilesetDimensions.x);
    float row = floor(aDepth / uTilesetDimensions.x);
    vTexCoord = vec2(aTexCoord.x + col, aTexCoord.y + row) / uTilesetDimensions;

    vec2 worldPos = aVertexPos * aTileScale + aTilePos;
    gl_Position = uProjectionMatrix * vec4(worldPos - uCameraPos, 0.0, 1.0);
}
`, b = `

precision mediump float;

varying vec2 vTexCoord;

uniform sampler2D uSampler;  

void main() {
    gl_FragColor = texture2D(uSampler, vTexCoord);
}
`;
class w {
  canvas;
  gl;
  shaderProgram;
  vbo;
  ebo;
  layersMap;
  texturesMap;
  attribLocations;
  clearColor;
  constructor(e) {
    this.canvas = e, this.layersMap = /* @__PURE__ */ new Map(), this.texturesMap = /* @__PURE__ */ new Map(), this.clearColor = new p(0, 0, 0, 0);
  }
  setClearColor(e) {
    this.clearColor.copy(e);
  }
  setSize(e, t) {
    this.canvas.width = e, this.canvas.height = t;
  }
  getCanvas() {
    return this.canvas;
  }
  async init(e) {
    const t = this.canvas.getContext("webgl");
    if (!t) throw new Error("WebGL not supported");
    this.gl = t;
    for (const a of e)
      a.tileset && this.createTexture(a.tileset, a.tileset.name, d.getImageData(a.image));
    this.shaderProgram = new y(t, P, b), this.attribLocations = {
      vertexPos: this.shaderProgram.getAttrib("aVertexPos"),
      texCoord: this.shaderProgram.getAttrib("aTexCoord"),
      tilePos: this.shaderProgram.getAttrib("aTilePos"),
      tileScale: this.shaderProgram.getAttrib("aTileScale"),
      depth: this.shaderProgram.getAttrib("aDepth")
    }, this.vbo = t.createBuffer(), t.bindBuffer(t.ARRAY_BUFFER, this.vbo);
    const i = new Float32Array(l * 4 * 4);
    for (let a = 0; a < l; ++a)
      i.set(f.quad, a * 4 * 4);
    t.bufferData(t.ARRAY_BUFFER, i, t.STATIC_DRAW);
    const r = [0, 1, 2, 1, 2, 3];
    this.ebo = t.createBuffer(), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.ebo);
    const s = new Uint16Array(l * 6);
    for (let a = 0; a < l; ++a)
      for (let o = 0; o < 6; ++o)
        s[a * 6 + o] = r[o] + 4 * a;
    t.bufferData(t.ELEMENT_ARRAY_BUFFER, s, t.STATIC_DRAW);
  }
  render(e, t) {
    const i = [];
    for (const r of e.layers.toSorted((s, a) => s.zIndex - a.zIndex)) {
      const s = r.getKey();
      if (!this.layersMap.has(s)) {
        const o = new E(this.gl, this, r.isStatic, r.atlasName);
        this.layersMap.set(s, o);
      }
      const a = this.layersMap.get(s);
      a.needsUpdate && a.upload(r.sprites), i.push(a);
    }
    this.gl.viewport(0, 0, t.vw, t.vh), this.gl.clearColor(this.clearColor.r, this.clearColor.g, this.clearColor.b, this.clearColor.a), this.gl.clear(this.gl.COLOR_BUFFER_BIT), this.shaderProgram.use(), this.gl.uniformMatrix4fv(this.shaderProgram.getUniform("uProjectionMatrix"), !1, t.projectionMatrix), this.gl.uniform2f(this.shaderProgram.getUniform("uCameraPos"), t.position.x, t.position.y);
    for (let r of i) {
      const s = this.getTextureInfo(r.texName), a = s.tileset.tilesPerRow, o = Math.floor(s.tileset.totalTiles / s.tileset.tilesPerRow);
      this.gl.uniform2f(this.shaderProgram.getUniform("uTilesetDimensions"), a, o), r.render();
    }
  }
  getTextureInfo(e) {
    const t = this.texturesMap.get(e);
    if (!t) throw new Error("Texture not found: " + e);
    return t;
  }
  getVBO() {
    return this.vbo;
  }
  getEBO() {
    return this.ebo;
  }
  getAttribLocations() {
    return this.attribLocations;
  }
  createTexture(e, t, i) {
    const r = this.gl, s = r.createTexture();
    r.bindTexture(r.TEXTURE_2D, s), r.texImage2D(r.TEXTURE_2D, 0, r.RGBA, e.imageWidth, e.imageHeight, 0, r.RGBA, r.UNSIGNED_BYTE, i), d.isPowerOf2(e.imageWidth) && d.isPowerOf2(e.imageHeight) && r.generateMipmap(r.TEXTURE_2D), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MAG_FILTER, r.NEAREST), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MIN_FILTER, r.NEAREST), this.texturesMap.set(t, { texture: s, tileset: e });
  }
}
let E = class {
  gl;
  renderer;
  spriteBuffer;
  isStatic;
  texName;
  needsUpdate;
  spriteCount;
  constructor(e, t, i, r) {
    this.gl = e, this.renderer = t, this.isStatic = i, this.texName = r, this.needsUpdate = !0, this.spriteCount = 0, this.spriteBuffer = e.createBuffer(), e.bindBuffer(e.ARRAY_BUFFER, this.spriteBuffer), e.bufferData(e.ARRAY_BUFFER, (this.isStatic ? l : g) * 5 * 4 * 4, this.isStatic ? e.STATIC_DRAW : e.DYNAMIC_DRAW);
  }
  upload(e) {
    const t = this.gl;
    t.bindBuffer(t.ARRAY_BUFFER, this.spriteBuffer);
    const i = [];
    for (let r of e)
      for (let s = 0; s < 4; ++s)
        i.push(r.position.x, r.position.y, r.scale.x, r.scale.y, r.tilesetIdx);
    t.bufferSubData(t.ARRAY_BUFFER, 0, new Float32Array(i)), this.isStatic && (this.needsUpdate = !1), this.spriteCount = e.length;
  }
  render() {
    const e = this.gl;
    e.bindTexture(e.TEXTURE_2D, this.renderer.getTextureInfo(this.texName).texture), e.bindBuffer(e.ARRAY_BUFFER, this.renderer.getVBO());
    const t = this.renderer.getAttribLocations();
    e.enableVertexAttribArray(t.vertexPos), e.vertexAttribPointer(t.vertexPos, 2, e.FLOAT, !1, 16, 0), e.enableVertexAttribArray(t.texCoord), e.vertexAttribPointer(t.texCoord, 2, e.FLOAT, !1, 16, 8), e.bindBuffer(e.ARRAY_BUFFER, this.spriteBuffer), e.enableVertexAttribArray(t.tilePos), e.vertexAttribPointer(t.tilePos, 2, e.FLOAT, !1, 20, 0), e.enableVertexAttribArray(t.tileScale), e.vertexAttribPointer(t.tileScale, 2, e.FLOAT, !1, 20, 8), e.enableVertexAttribArray(t.depth), e.vertexAttribPointer(t.depth, 1, e.FLOAT, !1, 20, 16), e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this.renderer.getEBO()), e.drawElements(e.TRIANGLES, 6 * this.spriteCount, e.UNSIGNED_SHORT, 0);
  }
};
const C = `#version 300 es

layout(location = 0) in vec2 aVertexPos;
layout(location = 1) in vec2 aTexCoord;
layout(location = 2) in vec2 aTilePos;
layout(location = 3) in vec2 aTileScale;
layout(location = 4) in float aDepth;

uniform mat4 uProjectionMatrix;
uniform vec2 uCameraPos;

out vec2 vTexCoord;
out float vDepth;

void main() {
    vTexCoord = aTexCoord;
    vDepth = aDepth;

    vec2 worldPos = aVertexPos * aTileScale + aTilePos;
    gl_Position = uProjectionMatrix * vec4(worldPos - uCameraPos, 0.0, 1.0);
}
`, B = `#version 300 es

precision mediump float;

in vec2 vTexCoord;
in float vDepth;

uniform mediump sampler2DArray uSampler;  

out vec4 fragColor;

void main() {
    fragColor = texture(uSampler, vec3(vTexCoord, vDepth));
}
`;
class _ {
  canvas;
  gl;
  shaderProgram;
  vbo;
  layersMap;
  texturesMap;
  clearColor;
  constructor(e) {
    this.canvas = e, this.layersMap = /* @__PURE__ */ new Map(), this.texturesMap = /* @__PURE__ */ new Map(), this.clearColor = new p(0, 0, 0, 0);
  }
  setClearColor(e) {
    this.clearColor.copy(e);
  }
  setSize(e, t) {
    this.canvas.width = e, this.canvas.height = t;
  }
  getCanvas() {
    return this.canvas;
  }
  async init(e) {
    const t = this.canvas.getContext("webgl2");
    if (!t) throw new Error("WebGL2 not supported");
    this.gl = t;
    for (const i of e)
      i.tileset && this.createTexture(i.tileset, i.tileset.name, d.getImageData(i.image));
    this.shaderProgram = new y(t, C, B), this.vbo = t.createBuffer(), t.bindBuffer(t.ARRAY_BUFFER, this.vbo), t.bufferData(t.ARRAY_BUFFER, f.quad, t.STATIC_DRAW);
  }
  render(e, t) {
    const i = [];
    for (const r of e.layers.toSorted((s, a) => s.zIndex - a.zIndex)) {
      const s = r.getKey();
      if (!this.layersMap.has(s)) {
        const o = new U(this.gl, this, r.isStatic, r.atlasName);
        this.layersMap.set(s, o);
      }
      const a = this.layersMap.get(s);
      a.needsUpdate && a.upload(r.sprites), i.push(a);
    }
    this.gl.viewport(0, 0, this.canvas.width, this.canvas.height), this.gl.clearColor(this.clearColor.r, this.clearColor.g, this.clearColor.b, this.clearColor.a), this.gl.clear(this.gl.COLOR_BUFFER_BIT), this.shaderProgram.use(), this.gl.uniformMatrix4fv(this.shaderProgram.getUniform("uProjectionMatrix"), !1, t.projectionMatrix), this.gl.uniform2f(this.shaderProgram.getUniform("uCameraPos"), t.position.x, t.position.y);
    for (let r of i)
      r.render();
  }
  getTextureInfo(e) {
    const t = this.texturesMap.get(e);
    if (!t) throw new Error("Texture not found: " + e);
    return t;
  }
  getVBO() {
    return this.vbo;
  }
  createTexture(e, t, i) {
    const r = this.gl, s = r.createBuffer();
    r.bindBuffer(r.PIXEL_UNPACK_BUFFER, s), r.bufferData(r.PIXEL_UNPACK_BUFFER, i, r.STATIC_DRAW), r.pixelStorei(r.UNPACK_ROW_LENGTH, e.imageWidth), r.pixelStorei(r.UNPACK_IMAGE_HEIGHT, e.imageHeight);
    const a = r.createTexture();
    r.bindTexture(r.TEXTURE_2D_ARRAY, a), r.texStorage3D(r.TEXTURE_2D_ARRAY, 4, r.RGBA8, e.tileSize, e.tileSize, e.totalTiles);
    for (let o = 0; o < e.totalTiles; ++o) {
      const c = o % e.tilesPerRow, h = Math.floor(o / e.tilesPerRow);
      r.pixelStorei(r.UNPACK_SKIP_PIXELS, c * e.tileSize), r.pixelStorei(r.UNPACK_SKIP_ROWS, h * e.tileSize), r.texSubImage3D(r.TEXTURE_2D_ARRAY, 0, 0, 0, o, e.tileSize, e.tileSize, 1, r.RGBA, r.UNSIGNED_BYTE, 0);
    }
    r.deleteBuffer(s), r.generateMipmap(r.TEXTURE_2D_ARRAY), r.texParameteri(r.TEXTURE_2D_ARRAY, r.TEXTURE_MAG_FILTER, r.NEAREST), r.texParameteri(r.TEXTURE_2D_ARRAY, r.TEXTURE_MIN_FILTER, r.NEAREST), this.texturesMap.set(t, { texture: a, tileset: e });
  }
}
class U {
  gl;
  renderer;
  instanceBuffer;
  vao;
  isStatic;
  texName;
  needsUpdate;
  instanceCount;
  constructor(e, t, i, r) {
    this.gl = e, this.renderer = t, this.isStatic = i, this.texName = r, this.needsUpdate = !0, this.instanceCount = 0, this.vao = e.createVertexArray(), e.bindVertexArray(this.vao), e.bindBuffer(e.ARRAY_BUFFER, t.getVBO()), e.enableVertexAttribArray(0), e.vertexAttribPointer(0, 2, e.FLOAT, !1, 16, 0), e.enableVertexAttribArray(1), e.vertexAttribPointer(1, 2, e.FLOAT, !1, 16, 8), this.instanceBuffer = e.createBuffer(), e.bindBuffer(e.ARRAY_BUFFER, this.instanceBuffer), e.bufferData(e.ARRAY_BUFFER, (this.isStatic ? l : g) * 5 * 4, this.isStatic ? e.STATIC_DRAW : e.DYNAMIC_DRAW), e.enableVertexAttribArray(2), e.vertexAttribPointer(2, 2, e.FLOAT, !1, 20, 0), e.vertexAttribDivisor(2, 1), e.enableVertexAttribArray(3), e.vertexAttribPointer(3, 2, e.FLOAT, !1, 20, 8), e.vertexAttribDivisor(3, 1), e.enableVertexAttribArray(4), e.vertexAttribPointer(4, 1, e.FLOAT, !1, 20, 16), e.vertexAttribDivisor(4, 1), e.bindVertexArray(null);
  }
  upload(e) {
    const t = this.gl;
    t.bindBuffer(t.ARRAY_BUFFER, this.instanceBuffer), t.bufferSubData(t.ARRAY_BUFFER, 0, f.createSpritesData(e)), this.isStatic && (this.needsUpdate = !1), this.instanceCount = e.length;
  }
  render() {
    const e = this.gl;
    e.bindTexture(e.TEXTURE_2D_ARRAY, this.renderer.getTextureInfo(this.texName).texture), e.bindVertexArray(this.vao), e.drawArraysInstanced(e.TRIANGLE_STRIP, 0, 4, this.instanceCount), e.bindVertexArray(null);
  }
}
const I = async () => {
  const e = await (await navigator.gpu?.requestAdapter())?.requestDevice();
  if (!e) return null;
  const t = navigator.gpu.getPreferredCanvasFormat();
  return {
    device: e,
    format: t
  };
}, M = `
struct VSInput {
    @location(0) vertexPos: vec2f,
    @location(1) texCoord: vec2f,
    
    @location(2) tilePos: vec2f,
    @location(3) tileScale: vec2f,
    @location(4) depth: f32
}

struct Camera {
    projectionMatrix: mat4x4f,
    pos: vec2f
}

@group(0) @binding(0)
var<uniform> camera: Camera;

struct VSOutput {
    @builtin(position) pos: vec4f,
    @location(0) texCoord: vec2f,
    @location(1) depth: f32
}

@vertex
fn vs_main(input: VSInput) -> VSOutput {
    var out: VSOutput;

    out.texCoord = input.texCoord;
    out.depth = input.depth;

    let worldPos = input.vertexPos * input.tileScale + input.tilePos;
    out.pos = camera.projectionMatrix * vec4f(worldPos - camera.pos, 0.0, 1.0);

    return out;
}

@group(1) @binding(0)
var spriteSampler: sampler;

@group(1) @binding(1)
var spriteTexture: texture_2d_array<f32>;

@fragment
fn fs_main(input: VSOutput) -> @location(0) vec4f {
    let idx: u32 = u32(input.depth);
    return textureSample(spriteTexture, spriteSampler, input.texCoord, idx);
}
`;
class D {
  canvas;
  ctx;
  cfg;
  pipeline;
  vbo;
  layersMap;
  texturesMap;
  cameraBuffer;
  cameraBindGroup;
  sampler;
  clearColor;
  constructor(e) {
    this.layersMap = /* @__PURE__ */ new Map(), this.texturesMap = /* @__PURE__ */ new Map(), this.canvas = e, this.clearColor = new p(0, 0, 0, 0);
  }
  setClearColor(e) {
    this.clearColor.copy(e);
  }
  setSize(e, t) {
    this.canvas.width = e, this.canvas.height = t;
  }
  getCanvas() {
    return this.canvas;
  }
  async init(e) {
    const t = await I();
    if (!t) throw new Error("WebGPU not supported");
    this.cfg = t;
    const i = this.cfg.device, r = this.canvas.getContext("webgpu");
    this.ctx = r, this.ctx.configure(this.cfg);
    for (const a of e)
      a.tileset && this.createTexture(a.tileset, a.tileset.name, d.getImageData(a.image));
    const s = i.createShaderModule({
      code: M
    });
    this.pipeline = i.createRenderPipeline({
      layout: "auto",
      vertex: {
        module: s,
        entryPoint: "vs_main",
        buffers: [
          {
            arrayStride: 16,
            stepMode: "vertex",
            attributes: [
              { shaderLocation: 0, offset: 0, format: "float32x2" },
              { shaderLocation: 1, offset: 8, format: "float32x2" }
            ]
          },
          {
            arrayStride: 20,
            stepMode: "instance",
            attributes: [
              { shaderLocation: 2, offset: 0, format: "float32x2" },
              { shaderLocation: 3, offset: 8, format: "float32x2" },
              { shaderLocation: 4, offset: 16, format: "float32" }
            ]
          }
        ]
      },
      fragment: {
        module: s,
        entryPoint: "fs_main",
        targets: [{ format: this.cfg.format }]
      },
      primitive: { topology: "triangle-strip" }
    }), this.cameraBuffer = i.createBuffer({
      size: 80,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    }), this.cameraBindGroup = i.createBindGroup({
      layout: this.pipeline.getBindGroupLayout(0),
      entries: [{
        binding: 0,
        resource: { buffer: this.cameraBuffer }
      }]
    }), this.sampler = i.createSampler({
      magFilter: "nearest",
      minFilter: "nearest"
    }), this.vbo = i.createBuffer({
      size: f.quad.byteLength,
      usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
    }), i.queue.writeBuffer(this.vbo, 0, f.quad);
  }
  render(e, t) {
    const i = [];
    for (const o of e.layers.toSorted((c, h) => c.zIndex - h.zIndex)) {
      const c = o.getKey();
      if (!this.layersMap.has(c)) {
        const u = new F(this, o.isStatic, o.atlasName);
        this.layersMap.set(c, u);
      }
      const h = this.layersMap.get(c);
      h.needsUpdate && h.upload(o.sprites), i.push(h);
    }
    this.cfg.device.queue.writeBuffer(
      this.cameraBuffer,
      0,
      t.projectionMatrix
    ), this.cfg.device.queue.writeBuffer(
      this.cameraBuffer,
      64,
      new Float32Array([t.position.x, t.position.y])
    );
    const r = this.cfg.device.createCommandEncoder(), s = r.beginRenderPass({
      colorAttachments: [{
        clearValue: this.clearColor,
        view: this.ctx.getCurrentTexture().createView(),
        loadOp: "clear",
        storeOp: "store"
      }]
    });
    s.setPipeline(this.pipeline), s.setBindGroup(0, this.cameraBindGroup), s.setVertexBuffer(0, this.vbo);
    for (const o of i)
      o.render(s);
    s.end();
    const a = r.finish();
    this.cfg.device.queue.submit([a]);
  }
  createTexture(e, t, i) {
    const r = e.tileSize, s = this.cfg.device.createTexture({
      size: {
        width: r,
        height: r,
        depthOrArrayLayers: e.totalTiles
      },
      format: "rgba8unorm",
      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT
    });
    for (let a = 0; a < e.totalTiles; ++a) {
      const o = Math.floor(a / e.tilesPerRow), c = a % e.tilesPerRow, h = new Uint8Array(r * r * 4);
      for (let u = 0; u < r; ++u) {
        const m = ((o * r + u) * e.tilesPerRow + c) * r * 4, v = m + r * 4;
        h.set(i.slice(m, v), u * r * 4);
      }
      this.cfg.device.queue.writeTexture(
        {
          texture: s,
          origin: { x: 0, y: 0, z: a }
        },
        h,
        {
          bytesPerRow: r * 4,
          rowsPerImage: r
        },
        {
          width: r,
          height: r,
          depthOrArrayLayers: 1
        }
      );
    }
    this.texturesMap.set(t, { texture: s, tileset: e });
  }
  getConfig() {
    return this.cfg;
  }
  getTextureInfo(e) {
    const t = this.texturesMap.get(e);
    if (!t) throw new Error("Texture not found: " + e);
    return t;
  }
  getPipeline() {
    return this.pipeline;
  }
  getSampler() {
    return this.sampler;
  }
}
class F {
  isStatic;
  texName;
  needsUpdate;
  instanceCount;
  renderer;
  instanceBuffer;
  textureBindGroup;
  constructor(e, t, i) {
    this.renderer = e, this.isStatic = t, this.texName = i, this.needsUpdate = !0, this.instanceCount = 0, this.instanceBuffer = e.getConfig().device.createBuffer({
      size: 20 * (t ? l : g),
      usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
    }), this.textureBindGroup = e.getConfig().device.createBindGroup({
      layout: e.getPipeline().getBindGroupLayout(1),
      entries: [
        { binding: 0, resource: e.getSampler() },
        {
          binding: 1,
          resource: e.getTextureInfo(i).texture.createView({
            dimension: "2d-array"
          })
        }
      ]
    });
  }
  upload(e) {
    this.renderer.getConfig().device.queue.writeBuffer(this.instanceBuffer, 0, f.createSpritesData(e)), this.isStatic && (this.needsUpdate = !1), this.instanceCount = e.length;
  }
  render(e) {
    e.setVertexBuffer(1, this.instanceBuffer), e.setBindGroup(1, this.textureBindGroup), e.draw(4, this.instanceCount);
  }
}
const l = 1e4, g = 1e4, G = (n) => {
  const e = document.createElement("canvas");
  switch (n) {
    case "webgl":
      return new w(e);
    case "webgl2":
      return new _(e);
    case "webgpu":
      return new D(e);
  }
};
class V {
  layers;
  constructor() {
    this.layers = [];
  }
  addSprite(e) {
    let t = this.layers.find((i) => i.isLocked === !1 && i.isStatic === e.isStatic && i.zIndex === e.zIndex && i.atlasName === e.tilesetName);
    t || (t = new L(e.zIndex, e.isStatic, e.tilesetName, !1), this.layers.push(t)), t.add(e);
  }
  addLayer(e) {
    this.layers.push(e);
  }
}
class L {
  zIndex;
  isStatic;
  atlasName;
  isLocked;
  sprites;
  constructor(e, t, i, r) {
    this.zIndex = e, this.isStatic = t, this.atlasName = i, this.isLocked = r, this.sprites = [];
  }
  add(e) {
    this.sprites.push(e);
  }
  getKey() {
    return `${this.zIndex};${this.isStatic ? "static" : "dynamic"};${this.atlasName}`;
  }
}
class Y {
  zIndex;
  tilesetName;
  tilesetIdx;
  isStatic;
  position;
  scale;
  constructor(e) {
    this.zIndex = e.zIndex || 0, this.tilesetName = e.tilesetName, this.tilesetIdx = e.tilesetIdx, this.isStatic = e.isStatic || !1, this.position = new x(), this.scale = new x(1, 1);
  }
}
class T {
  x;
  y;
  properties;
  animation;
  constructor(e, t, i) {
    this.x = e, this.y = t, this.properties = i?.properties, this.animation = i?.animation;
  }
  getProperty(e) {
    return this.properties?.find((t) => t.name === e) ?? null;
  }
}
class R {
  name;
  imageWidth;
  imageHeight;
  tileSize;
  tilesPerRow;
  totalTiles;
  data;
  constructor(e) {
    if (this.name = e.name, this.imageWidth = e.imageWidth, this.imageHeight = e.imageHeight, this.tileSize = e.tileSize, this.tilesPerRow = e.tilesPerRow, this.totalTiles = e.totalTiles, this.data = /* @__PURE__ */ new Map(), e.data)
      for (const t of e.data)
        this.data.set(t.id, t);
  }
  static async load(e) {
    const t = await S.loadJson(e);
    return new R(t);
  }
  getTile(e, t) {
    const i = this.data.get(t * this.tilesPerRow + e);
    return new T(e, t, i);
  }
  getTileById(e) {
    const t = this.data.get(e), i = e % this.tilesPerRow, r = Math.floor(e / this.tilesPerRow);
    return new T(i, r, t);
  }
}
export {
  N as Camera,
  p as Color,
  V as Scene,
  Y as Sprite,
  R as Tileset,
  x as Vector,
  S as assets,
  G as createRenderer,
  A as matrix
};
