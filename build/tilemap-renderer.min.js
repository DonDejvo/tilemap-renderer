var TilemapRenderer=(function(c){"use strict";const R={loadImage:t=>new Promise((s,r)=>{const i=new Image;i.crossOrigin="anonymous",i.src=t,i.onload=()=>{s(i)},i.onerror=()=>{r()}}),loadJson:async t=>{try{return await(await fetch(t)).json()}catch{throw new Error(`Failed to load: ${t}`)}}},E={identity:()=>new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]),createOrtho:(t,s,r,i,o)=>(t[0]=2/(r-s),t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=2/(o-i),t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=-(r+s)/(r-s),t[13]=-(o+i)/(o-i),t[14]=0,t[15]=1,t)};class d{constructor(e=0,t=0){this.x=e,this.y=t}set(e,t){return this.x=e,this.y=t,this}copy(e){return this.x=e.x,this.y=e.y,this}clone(){return new d(this.x,this.y)}add(e){return this.x+=e.x,this.y+=e.y,this}sub(e){return this.x-=e.x,this.y-=e.y,this}scale(e){return this.x*=e,this.y*=e,this}mul(e){return this.x*=e.x,this.y*=e.y,this}div(e){return e!==0?(this.x/=e,this.y/=e):(this.x=0,this.y=0),this}static dot(e,t){return e.x*t.x+e.y*t.y}static cross(e,t){return e.x*t.y-e.y*t.x}len(){return Math.sqrt(this.x*this.x+this.y*this.y)}lenSq(){return this.x*this.x+this.y*this.y}unit(){const e=this.len();return e>0&&this.div(e),this}project(e){const t=e.lenSq();if(t>0)return this.scale(0);const s=d.dot(this,e);return this.copy(e).scale(s/t)}static distance(e,t){const s=e.x-t.x,r=e.y-t.y;return Math.sqrt(s*s+r*r)}angle(){return Math.atan2(this.y,this.x)}rot(e){const t=Math.cos(e),s=Math.sin(e),r=this.x*t-this.y*s,i=this.x*s+this.y*t;return this.x=r,this.y=i,this}fromAngle(e,t=1){return this.x=Math.cos(e)*t,this.y=Math.sin(e)*t,this}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this}toString(){return`Vector(${this.x}, ${this.y})`}}class C{constructor(e,t){this.projectionMatrix=E.identity(),this.position=new d,this.vw=0,this.vh=0,this.updateProjection(e,t)}updateProjection(e,t){this.vw=e,this.vh=t,E.createOrtho(this.projectionMatrix,-e*.5,e*.5,-t*.5,t*.5)}}class p{constructor(e,t,s,r=1){this.r=e,this.g=t,this.b=s,this.a=r}copy(e){this.r=e.r,this.g=e.g,this.b=e.b,this.a=e.a}}const g={quad:new Float32Array([-.5,.5,0,0,-.5,-.5,0,1,.5,.5,1,0,.5,-.5,1,1]),createSpritesData:(t,s=!1)=>{const r=s?1:4,i=24,o=new ArrayBuffer(t.length*r*i),a=new DataView(o);let n=0;for(const l of t)for(let f=0;f<r;++f)a.setFloat32(n,l.position.x+l.offset.x*l.scale.x,!0),a.setFloat32(n+4,l.position.y+l.offset.y*l.scale.y,!0),a.setFloat32(n+8,l.scale.x,!0),a.setFloat32(n+12,l.scale.y,!0),a.setUint16(n+16,l.tilesetRegion.x,!0),a.setUint16(n+18,l.tilesetRegion.y,!0),a.setUint16(n+20,l.tilesetRegion.width||1,!0),a.setUint16(n+22,l.tilesetRegion.height||1,!0),n+=i;return o}};class S{constructor(e,t,s){this.gl=e,this.uniforms=new Map;const r=this.compileShader(e.VERTEX_SHADER,t),i=this.compileShader(e.FRAGMENT_SHADER,s);if(this.program=e.createProgram(),e.attachShader(this.program,r),e.attachShader(this.program,i),e.linkProgram(this.program),!e.getProgramParameter(this.program,e.LINK_STATUS))throw new Error(e.getProgramInfoLog(this.program)??"Could not link program");e.deleteShader(r),e.deleteShader(i)}compileShader(e,t){const s=this.gl.createShader(e);if(!s)throw new Error("Could not create shader");if(this.gl.shaderSource(s,t),this.gl.compileShader(s),!this.gl.getShaderParameter(s,this.gl.COMPILE_STATUS))throw new Error(this.gl.getShaderInfoLog(s)??"Could not compile shader");return s}use(){this.gl.useProgram(this.program)}getUniform(e){if(!this.uniforms.has(e)){const t=this.gl.getUniformLocation(this.program,e);t||console.log("Could not get uniform location:",e),this.uniforms.set(e,t)}return this.uniforms.get(e)}getAttrib(e){return this.gl.getAttribLocation(this.program,e)}}const U=`

attribute vec2 aVertexPos;
attribute vec2 aTexCoord;
attribute vec2 aTilePos;
attribute vec2 aTileScale;
attribute vec4 aTileRegion;

uniform mat4 uProjectionMatrix;
uniform vec2 uCameraPos;

uniform vec2 uTilesetDimensions;

varying vec2 uv;

void main() {
    uv = (vec2(aTileRegion.xy) + aTexCoord * vec2(aTileRegion.zw)) / uTilesetDimensions;

    vec2 worldPos = aVertexPos * aTileScale + aTilePos;
    gl_Position = uProjectionMatrix * vec4(worldPos - uCameraPos, 0.0, 1.0);
}
`,B=`

precision mediump float;

varying vec2 uv;

uniform sampler2D uSampler;  

void main() {
    gl_FragColor = texture2D(uSampler, uv);
}
`;class I{constructor(e){this.canvas=e,this.layersMap=new Map,this.texturesMap=new Map,this.clearColor=new p(0,0,0,0),this.texturesInfo=[]}addTextures(e,t){for(const s of e)t[s.name]&&this.texturesInfo.push({tileset:s,image:t[s.name]})}setClearColor(e){this.clearColor.copy(e)}setSize(e,t){this.canvas.width=e,this.canvas.height=t}getCanvas(){return this.canvas}async init(){const e=this.canvas.getContext("webgl");if(!e)throw new Error("WebGL not supported");this.gl=e;for(const i of this.texturesInfo)i.tileset&&this.createTexture(i.tileset,i.tileset.name,i.image);this.shaderProgram=new S(e,U,B),this.attribLocations={vertexPos:this.shaderProgram.getAttrib("aVertexPos"),texCoord:this.shaderProgram.getAttrib("aTexCoord"),tilePos:this.shaderProgram.getAttrib("aTilePos"),tileScale:this.shaderProgram.getAttrib("aTileScale"),tileRegion:this.shaderProgram.getAttrib("aTileRegion")},this.vbo=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.vbo);const t=new Float32Array(u*4*4);for(let i=0;i<u;++i)t.set(g.quad,i*4*4);e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW);const s=[0,1,2,1,2,3];this.ebo=e.createBuffer(),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,this.ebo);const r=new Uint16Array(u*6);for(let i=0;i<u;++i)for(let o=0;o<6;++o)r[i*6+o]=s[o]+4*i;e.bufferData(e.ELEMENT_ARRAY_BUFFER,r,e.STATIC_DRAW),e.enable(e.BLEND),e.blendFunc(e.SRC_ALPHA,e.ONE_MINUS_SRC_ALPHA)}render(e,t){const s=[];for(const r of e.getLayersOrdered()){if(!this.layersMap.has(r)){const o=new M(this.gl,this,r.isStatic);this.layersMap.set(r,o)}const i=this.layersMap.get(r);i.needsUpdate&&i.upload(r.getSpritesOrdered()),s.push(i)}this.gl.viewport(0,0,t.vw,t.vh),this.gl.clearColor(this.clearColor.r,this.clearColor.g,this.clearColor.b,this.clearColor.a),this.gl.clear(this.gl.COLOR_BUFFER_BIT),this.shaderProgram.use(),this.gl.uniformMatrix4fv(this.shaderProgram.getUniform("uProjectionMatrix"),!1,t.projectionMatrix),this.gl.uniform2f(this.shaderProgram.getUniform("uCameraPos"),t.position.x,t.position.y);for(let r of s)r.render();for(const[r,i]of this.layersMap)i.lifetime<=0&&(this.layersMap.delete(r),i.destroy())}getTextureInfo(e){const t=this.texturesMap.get(e);if(!t)throw new Error("Texture not found: "+e);return t}getVBO(){return this.vbo}getEBO(){return this.ebo}getShaderProgram(){return this.shaderProgram}getAttribLocations(){return this.attribLocations}createTexture(e,t,s){const r=this.gl,i=r.createTexture();r.bindTexture(r.TEXTURE_2D,i),r.texImage2D(r.TEXTURE_2D,0,r.RGBA,r.RGBA,r.UNSIGNED_BYTE,s),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_WRAP_S,r.CLAMP_TO_EDGE),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_WRAP_T,r.CLAMP_TO_EDGE),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_MIN_FILTER,r.NEAREST),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_MAG_FILTER,r.NEAREST),this.texturesMap.set(t,{texture:i,tileset:e})}}let M=class{constructor(e,t,s){this.gl=e,this.renderer=t,this.isStatic=s,this.needsUpdate=!0,this.drawCalls=[],this.lifetime=x,this.spriteBuffer=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.spriteBuffer),e.bufferData(e.ARRAY_BUFFER,(this.isStatic?u:A)*5*4*4,this.isStatic?e.STATIC_DRAW:e.DYNAMIC_DRAW)}upload(e){const t=this.gl;t.bindBuffer(t.ARRAY_BUFFER,this.spriteBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,g.createSpritesData(e)),this.isStatic&&(this.needsUpdate=!1),this.drawCalls.length=0;let s=null;for(let r=0;r<e.length;++r){const i=e[r].tilesetName;!s||i!==s.texName?(s={texName:i,spriteOffset:r,spriteCount:1},this.drawCalls.push(s)):s.spriteCount++}}render(){const e=this.gl,t=this.renderer.getAttribLocations();e.bindBuffer(e.ARRAY_BUFFER,this.renderer.getVBO()),e.enableVertexAttribArray(t.vertexPos),e.vertexAttribPointer(t.vertexPos,2,e.FLOAT,!1,16,0),e.enableVertexAttribArray(t.texCoord),e.vertexAttribPointer(t.texCoord,2,e.FLOAT,!1,16,8),e.bindBuffer(e.ARRAY_BUFFER,this.spriteBuffer),e.enableVertexAttribArray(t.tilePos),e.vertexAttribPointer(t.tilePos,2,e.FLOAT,!1,24,0),e.enableVertexAttribArray(t.tileScale),e.vertexAttribPointer(t.tileScale,2,e.FLOAT,!1,24,8),e.enableVertexAttribArray(t.tileRegion),e.vertexAttribPointer(t.tileRegion,4,e.UNSIGNED_SHORT,!1,24,16),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,this.renderer.getEBO());for(const s of this.drawCalls){const r=this.renderer.getTextureInfo(s.texName);e.bindTexture(e.TEXTURE_2D,r.texture);const i=r.tileset.columns,o=Math.floor(r.tileset.tileCount/r.tileset.columns);this.gl.uniform2f(this.renderer.getShaderProgram().getUniform("uTilesetDimensions"),i,o),e.drawElements(e.TRIANGLES,6*s.spriteCount,e.UNSIGNED_SHORT,s.spriteOffset*6*2)}this.lifetime=x}destroy(){this.gl.deleteBuffer(this.spriteBuffer)}};const F=`#version 300 es

layout(location = 0) in vec2 aVertexPos;
layout(location = 1) in vec2 aTexCoord;

layout(location = 2) in vec2 aTilePos;
layout(location = 3) in vec2 aTileScale;
layout(location = 4) in uvec4 aTileRegion;

uniform mat4 uProjectionMatrix;
uniform vec2 uCameraPos;

uniform vec2 uTilesetDimensions;

out vec2 uv;

void main() {
    uv = (vec2(aTileRegion.xy) + aTexCoord * vec2(aTileRegion.zw)) / uTilesetDimensions;

    vec2 worldPos = aVertexPos * aTileScale + aTilePos;
    gl_Position = uProjectionMatrix * vec4(worldPos - uCameraPos, 0.0, 1.0);
}
`,L=`#version 300 es

precision mediump float;

in vec2 uv;

uniform mediump sampler2D uSampler;  

out vec4 fragColor;

void main() {
    fragColor = texture(uSampler, uv);
}
`;class D{constructor(e){this.canvas=e,this.layersMap=new Map,this.texturesMap=new Map,this.clearColor=new p(0,0,0,0),this.texturesInfo=[]}addTextures(e,t){for(const s of e)t[s.name]&&this.texturesInfo.push({tileset:s,image:t[s.name]})}setClearColor(e){this.clearColor.copy(e)}setSize(e,t){this.canvas.width=e,this.canvas.height=t}getCanvas(){return this.canvas}async init(){const e=this.canvas.getContext("webgl2");if(!e)throw new Error("WebGL2 not supported");this.gl=e;for(const i of this.texturesInfo)i.tileset&&this.createTexture(i.tileset,i.tileset.name,i.image);this.shaderProgram=new S(e,F,L),this.vbo=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.vbo);const t=new Float32Array(u*4*4);for(let i=0;i<u;++i)t.set(g.quad,i*4*4);e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW);const s=[0,1,2,1,2,3];this.ebo=e.createBuffer(),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,this.ebo);const r=new Uint32Array(u*6);for(let i=0;i<u;++i)for(let o=0;o<6;++o)r[i*6+o]=s[o]+4*i;e.bufferData(e.ELEMENT_ARRAY_BUFFER,r,e.STATIC_DRAW),e.enable(e.BLEND),e.blendFunc(e.SRC_ALPHA,e.ONE_MINUS_SRC_ALPHA)}render(e,t){const s=[];for(const r of e.getLayersOrdered()){if(!this.layersMap.has(r)){const o=new O(this.gl,this,r.isStatic);this.layersMap.set(r,o)}const i=this.layersMap.get(r);i.needsUpdate&&i.upload(r.getSpritesOrdered()),s.push(i)}this.gl.viewport(0,0,this.canvas.width,this.canvas.height),this.gl.clearColor(this.clearColor.r,this.clearColor.g,this.clearColor.b,this.clearColor.a),this.gl.clear(this.gl.COLOR_BUFFER_BIT),this.shaderProgram.use(),this.gl.uniformMatrix4fv(this.shaderProgram.getUniform("uProjectionMatrix"),!1,t.projectionMatrix),this.gl.uniform2f(this.shaderProgram.getUniform("uCameraPos"),t.position.x,t.position.y);for(let r of s)r.render();for(const[r,i]of this.layersMap)i.lifetime<=0&&(this.layersMap.delete(r),i.destroy())}getTextureInfo(e){const t=this.texturesMap.get(e);if(!t)throw new Error("Texture not found: "+e);return t}getVBO(){return this.vbo}getEBO(){return this.ebo}getShaderProgram(){return this.shaderProgram}createTexture(e,t,s){const r=this.gl,i=r.createTexture();r.bindTexture(r.TEXTURE_2D,i),r.texImage2D(r.TEXTURE_2D,0,r.RGBA8,r.RGBA,r.UNSIGNED_BYTE,s),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_WRAP_S,r.CLAMP_TO_EDGE),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_WRAP_T,r.CLAMP_TO_EDGE),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_MIN_FILTER,r.NEAREST),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_MAG_FILTER,r.NEAREST),this.texturesMap.set(t,{texture:i,tileset:e})}createTextureArray(e,t,s){const r=this.gl,i=r.createBuffer();r.bindBuffer(r.PIXEL_UNPACK_BUFFER,i),r.bufferData(r.PIXEL_UNPACK_BUFFER,s,r.STATIC_DRAW),r.pixelStorei(r.UNPACK_ROW_LENGTH,e.imageWidth),r.pixelStorei(r.UNPACK_IMAGE_HEIGHT,e.imageHeight);const o=r.createTexture();r.bindTexture(r.TEXTURE_2D_ARRAY,o),r.texStorage3D(r.TEXTURE_2D_ARRAY,4,r.RGBA8,e.tileWidth,e.tileHeight,e.tileCount);for(let a=0;a<e.tileCount;++a){const n=a%e.columns,l=Math.floor(a/e.columns);r.pixelStorei(r.UNPACK_SKIP_PIXELS,n*e.tileWidth),r.pixelStorei(r.UNPACK_SKIP_ROWS,l*e.tileHeight),r.texSubImage3D(r.TEXTURE_2D_ARRAY,0,0,0,a,e.tileWidth,e.tileHeight,1,r.RGBA,r.UNSIGNED_BYTE,0)}r.deleteBuffer(i),r.generateMipmap(r.TEXTURE_2D_ARRAY),r.texParameteri(r.TEXTURE_2D_ARRAY,r.TEXTURE_MAG_FILTER,r.NEAREST),r.texParameteri(r.TEXTURE_2D_ARRAY,r.TEXTURE_MIN_FILTER,r.NEAREST),this.texturesMap.set(t,{texture:o,tileset:e})}}class O{constructor(e,t,s){this.gl=e,this.renderer=t,this.isStatic=s,this.needsUpdate=!0,this.drawCalls=[],this.lifetime=x,this.vao=e.createVertexArray(),e.bindVertexArray(this.vao),e.bindBuffer(e.ARRAY_BUFFER,t.getVBO()),e.enableVertexAttribArray(0),e.vertexAttribPointer(0,2,e.FLOAT,!1,16,0),e.enableVertexAttribArray(1),e.vertexAttribPointer(1,2,e.FLOAT,!1,16,8);const r=24;this.spriteBuffer=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.spriteBuffer),e.bufferData(e.ARRAY_BUFFER,(this.isStatic?u:A)*4*r,this.isStatic?e.STATIC_DRAW:e.DYNAMIC_DRAW),e.enableVertexAttribArray(2),e.vertexAttribPointer(2,2,e.FLOAT,!1,r,0),e.enableVertexAttribArray(3),e.vertexAttribPointer(3,2,e.FLOAT,!1,r,8),e.enableVertexAttribArray(4),e.vertexAttribIPointer(4,4,e.UNSIGNED_SHORT,r,16),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,t.getEBO()),e.bindVertexArray(null)}upload(e){const t=this.gl;t.bindBuffer(t.ARRAY_BUFFER,this.spriteBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,g.createSpritesData(e)),this.isStatic&&(this.needsUpdate=!1),this.drawCalls.length=0;let s=null;for(let r=0;r<e.length;++r){const i=e[r].tilesetName;!s||i!==s.texName?(s={texName:i,spriteOffset:r,spriteCount:1},this.drawCalls.push(s)):s.spriteCount++}}render(){const e=this.gl;e.bindVertexArray(this.vao);for(const t of this.drawCalls){const s=this.renderer.getTextureInfo(t.texName);e.bindTexture(e.TEXTURE_2D,s.texture);const r=s.tileset.columns,i=Math.floor(s.tileset.tileCount/s.tileset.columns);this.gl.uniform2f(this.renderer.getShaderProgram().getUniform("uTilesetDimensions"),r,i),e.drawElements(e.TRIANGLES,6*t.spriteCount,e.UNSIGNED_INT,t.spriteOffset*6*4)}e.bindVertexArray(null),this.lifetime=x}destroy(){this.gl.deleteBuffer(this.spriteBuffer),this.gl.deleteVertexArray(this.vao)}}const N=async()=>{const e=await(await navigator.gpu?.requestAdapter())?.requestDevice();if(!e)return null;const t=navigator.gpu.getPreferredCanvasFormat();return{device:e,format:t}},G=`
struct VSInput {
    @location(0) vertexPos: vec2f,
    @location(1) texCoord: vec2f,
    
    @location(2) tilePos: vec2f,
    @location(3) tileScale: vec2f,
    @location(4) tileRegion: vec2u
}

struct Camera {
    projectionMatrix: mat4x4f,
    pos: vec2f
}

@group(0) @binding(0)
var<uniform> camera: Camera;

@group(1) @binding(2)
var<uniform> tilesetDimensions: vec2f;

struct VSOutput {
    @builtin(position) pos: vec4f,
    @location(0) uv: vec2f,
}

@vertex
fn vs_main(input: VSInput) -> VSOutput {
    var out: VSOutput;

    let x = f32(input.tileRegion.x & 0xFFFFu);
    let y = f32(input.tileRegion.x >> 16);
    let w = f32(input.tileRegion.y & 0xFFFFu);
    let h = f32(input.tileRegion.y >> 16);

    let tileRegion = vec4f(x, y, w, h);

    out.uv = (tileRegion.xy + input.texCoord * tileRegion.zw) / tilesetDimensions;

    let worldPos = input.vertexPos * input.tileScale + input.tilePos;
    out.pos = camera.projectionMatrix * vec4f(worldPos - camera.pos, 0.0, 1.0);

    return out;
}

@group(1) @binding(0)
var spriteSampler: sampler;

@group(1) @binding(1)
var spriteTexture: texture_2d<f32>;

@fragment
fn fs_main(input: VSOutput) -> @location(0) vec4f {
    return textureSample(spriteTexture, spriteSampler, input.uv);
}
`;class Y{constructor(e){this.layersMap=new Map,this.texturesMap=new Map,this.canvas=e,this.clearColor=new p(0,0,0,0),this.texturesInfo=[]}addTextures(e,t){for(const s of e)t[s.name]&&this.texturesInfo.push({tileset:s,image:t[s.name]})}setClearColor(e){this.clearColor.copy(e)}setSize(e,t){this.canvas.width=e,this.canvas.height=t}getCanvas(){return this.canvas}async init(){const e=await N();if(!e)throw new Error("WebGPU not supported");this.cfg=e;const t=this.cfg.device,s=this.canvas.getContext("webgpu");this.ctx=s,this.ctx.configure(this.cfg);for(const i of this.texturesInfo)i.tileset&&this.createTexture(i.tileset,i.tileset.name,i.image);const r=t.createShaderModule({code:G});this.pipeline=t.createRenderPipeline({layout:"auto",vertex:{module:r,entryPoint:"vs_main",buffers:[{arrayStride:16,stepMode:"vertex",attributes:[{shaderLocation:0,offset:0,format:"float32x2"},{shaderLocation:1,offset:8,format:"float32x2"}]},{arrayStride:24,stepMode:"instance",attributes:[{shaderLocation:2,offset:0,format:"float32x2"},{shaderLocation:3,offset:8,format:"float32x2"},{shaderLocation:4,offset:16,format:"uint32x2"}]}]},fragment:{module:r,entryPoint:"fs_main",targets:[{format:this.cfg.format,blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha",operation:"add"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"}}}]},primitive:{topology:"triangle-strip"}}),this.cameraBuffer=t.createBuffer({size:80,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),this.cameraBindGroup=t.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:this.cameraBuffer}}]}),this.sampler=t.createSampler({magFilter:"nearest",minFilter:"nearest",addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge"}),this.vbo=t.createBuffer({size:g.quad.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST}),t.queue.writeBuffer(this.vbo,0,g.quad)}render(e,t){const s=[];for(const a of e.getLayersOrdered()){if(!this.layersMap.has(a)){const l=new V(this,a.isStatic);this.layersMap.set(a,l)}const n=this.layersMap.get(a);n.needsUpdate&&n.upload(a.getSpritesOrdered()),s.push(n)}this.cfg.device.queue.writeBuffer(this.cameraBuffer,0,t.projectionMatrix),this.cfg.device.queue.writeBuffer(this.cameraBuffer,64,new Float32Array([t.position.x,t.position.y]));const r=this.cfg.device.createCommandEncoder(),i=r.beginRenderPass({colorAttachments:[{clearValue:this.clearColor,view:this.ctx.getCurrentTexture().createView(),loadOp:"clear",storeOp:"store"}]});i.setPipeline(this.pipeline),i.setBindGroup(0,this.cameraBindGroup),i.setVertexBuffer(0,this.vbo);for(const a of s)a.render(i);i.end();const o=r.finish();this.cfg.device.queue.submit([o]);for(const[a,n]of this.layersMap)n.lifetime<=0&&(n.destroy(),this.layersMap.delete(a))}createTexture(e,t,s){const r=this.cfg.device.createTexture({size:{width:e.imageWidth,height:e.imageHeight,depthOrArrayLayers:1},format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT});this.cfg.device.queue.copyExternalImageToTexture,this.cfg.device.queue.copyExternalImageToTexture({source:s},{texture:r},[e.imageWidth,e.imageHeight,1]),this.texturesMap.set(t,{texture:r,tileset:e})}createTextureArray(e,t,s){const r=e.tileWidth,i=e.tileHeight,o=this.cfg.device.createTexture({size:{width:r,height:i,depthOrArrayLayers:e.tileCount},format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT});for(let a=0;a<e.tileCount;++a){const n=Math.floor(a/e.columns),l=a%e.columns,f=new Uint8Array(r*i*4);for(let y=0;y<i;++y){const v=((n*i+y)*e.columns+l)*r*4,k=v+r*4;f.set(s.slice(v,k),y*r*4)}this.cfg.device.queue.writeTexture({texture:o,origin:{x:0,y:0,z:a}},f,{bytesPerRow:r*4,rowsPerImage:i},{width:r,height:i,depthOrArrayLayers:1})}this.texturesMap.set(t,{texture:o,tileset:e})}getConfig(){return this.cfg}getTextureInfo(e){const t=this.texturesMap.get(e);if(!t)throw new Error("Texture not found: "+e);return t}getPipeline(){return this.pipeline}getSampler(){return this.sampler}}class V{constructor(e,t){this.renderer=e,this.isStatic=t,this.needsUpdate=!0,this.drawCalls=[],this.bindGroups=new Map,this.lifetime=x,this.lastTexIdx=0,this.instanceBuffer=e.getConfig().device.createBuffer({label:"Instance Buffer",size:24*(t?u:A),usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST}),this.tilesetDimBuffer=e.getConfig().device.createBuffer({label:"Tileset Dimensions Buffer",size:X*256,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST})}upload(e){const t=this.renderer.getConfig().device,s=this.renderer.getPipeline(),r=this.renderer.getSampler();t.queue.writeBuffer(this.instanceBuffer,0,g.createSpritesData(e,!0)),this.isStatic&&(this.needsUpdate=!1),this.drawCalls.length=0;let i=null;for(let o=0;o<e.length;++o){const a=e[o].tilesetName;if(!i||a!==i.texName){const n=this.renderer.getTextureInfo(a),l=new Float32Array([n.tileset.columns,Math.floor(n.tileset.tileCount/n.tileset.columns)]);t.queue.writeBuffer(this.tilesetDimBuffer,this.lastTexIdx*256,l);const f=t.createBindGroup({layout:s.getBindGroupLayout(1),entries:[{binding:0,resource:r},{binding:1,resource:n.texture.createView()},{binding:2,resource:{buffer:this.tilesetDimBuffer,offset:this.lastTexIdx*256,size:8}}]});i={texName:a,instanceOffset:o,instanceCount:1},this.bindGroups.has(i.texName)||(this.bindGroups.set(i.texName,f),++this.lastTexIdx),this.drawCalls.push(i)}else i.instanceCount++}}render(e){e.setVertexBuffer(1,this.instanceBuffer);for(const t of this.drawCalls)e.setBindGroup(1,this.bindGroups.get(t.texName)),e.draw(4,t.instanceCount,0,t.instanceOffset);this.lifetime=x}destroy(){this.instanceBuffer.destroy(),this.tilesetDimBuffer.destroy()}}const u=1e5,A=1e5,x=30,X=16,W=h=>{const e=document.createElement("canvas");switch(h){case"webgl":return new I(e);case"webgl2":return new D(e);case"webgpu":return new Y(e);default:throw new Error("Unknwn renderer type")}};class w{constructor(e){this.zIndex=e.zIndex||0,this.tilesetName=e.tilesetName,this.tilesetRegion=e.tilesetRegion,this.isStatic=e.isStatic||!1,this.position=new d,this.offset=this.getOffsetFromOrigin(e.origin),this.scale=new d(1,1)}getOffsetFromOrigin(e){switch(e){case"bottom":return new d(0,.5);case"top":return new d(0,-.5);default:return new d}}}class z{constructor(){this.layers=[]}addSprite(e){let t=this.layers.find(s=>s.isStatic===e.isStatic&&s.zIndex===e.zIndex);t||(t=new P({zIndex:e.zIndex,isStatic:e.isStatic}),this.layers.push(t)),t.add(e)}addTilemap(e,t={}){const s=e.getLayers();let r=0;for(const i of s){const o=t.layers?.find(a=>a.name===i.name);switch(o?.zIndex&&(r=o.zIndex),i.renderOrder!=="manual"&&this.createLayer({zIndex:r,renderOrder:i.renderOrder,isStatic:!1}),i.type){case"tilelayer":{for(let a=0;a<i.height;++a)for(let n=0;n<i.width;++n){const l=i.getTile(n,a);if(!l)continue;const f=new w({isStatic:l.animation===void 0,zIndex:r,tilesetName:l.tileset.name,tilesetRegion:{x:l.x,y:l.y}});f.position.set((n+i.x+.5)*e.tileWidth,-(a+i.y+.5)*e.tileHeight),f.scale.set(e.tileWidth,e.tileHeight),this.addSprite(f)}break}case"objectgroup":{if(t.onObject){const a=i.getObjects();for(const n of a)t.onObject(this,n,i,r)}break}}++r}}createLayer(e){const t=new P(e);return this.layers.push(t),t}getLayersOrdered(){return this.layers.sort((e,t)=>e.zIndex-t.zIndex)}}class P{constructor(e){this.zIndex=e.zIndex,this.isStatic=e.isStatic,this.renderOrder=e.renderOrder||"manual",this.sprites=[]}add(e){if(this.renderOrder==="manual"){let t=-1;for(let s=this.sprites.length-1;s>=0;--s)if(this.sprites[s].tilesetName<=e.tilesetName){t=s;break}t===-1?this.sprites.unshift(e):this.sprites.splice(t+1,0,e)}else this.sprites.push(e)}getSpritesOrdered(){switch(this.renderOrder){case"topdown":return this.sprites.sort((e,t)=>t.position.y-e.position.y);default:return this.sprites}}}class H{constructor(e,t,s,r){this.tileset=e,this.x=t,this.y=s,this.properties=r?.properties,this.animation=r?.animation}getProperty(e){return this.properties?.find(t=>t.name===e)??null}}const T=class T{constructor(e){if(this.name=e.name,this.imageWidth=e.imagewidth,this.imageHeight=e.imageheight,this.tileWidth=e.tilewidth,this.tileHeight=e.tileheight,this.columns=e.columns,this.tileCount=e.tilecount,this.tiledata=new Map,e.tiles)for(let t of e.tiles)this.tiledata.set(t.id,t)}static async load(e){if(!this.cache.has(e)){const t=await R.loadJson(e);this.cache.set(e,new T(t))}return this.cache.get(e)}getTile(e,t){const s=this.tiledata.get(t*this.columns+e);return new H(this,e,t,s)}getTileById(e){if(e>=this.tileCount||e<0)return null;const t=e%this.columns,s=Math.floor(e/this.columns);return this.getTile(t,s)}};T.cache=new Map;let m=T;class _{constructor(e){this.name=e.name,this.x=e.x,this.y=e.y,this.width=e.width,this.height=e.height,this.type=e.type,this.renderOrder=e.draworder||"manual"}}class q extends _{constructor(e){super(e),this.data=e.data}getTile(e,t){const s=this.data[t*this.width+e];return s-1==-1?null:this.tilemap.getTileById(s)}}class j extends _{constructor(e){super(e),this.objects=e.objects}getObjects(){return this.objects}}class b{constructor(e,t,s,r){this.width=e,this.height=t,this.tileWidth=s,this.tileHeight=r,this.tilesets=[],this.layers=[]}static async load(e,t){const s=await R.loadJson(e),r=new b(s.width,s.height,s.tilewidth,s.tileheight);for(const i of s.layers)switch(i.type){case"tilelayer":r.addLayer(new q(i));break;case"objectgroup":r.addLayer(new j(i));break}for(let i of s.tilesets){let o;if(i.source){const a=i.source.split(/(\/|\\\/)/),n=a[a.length-1].split(".tsj")[0];if(!t[n])throw new Error("Source is missing for tileset: "+n);o=await m.load(t[n])}else o=new m(i);r.tilesets.push({tileset:o,firstGlobalId:i.firstgid})}return r}addLayer(e){e.tilemap=this,this.layers.push(e)}getTilesets(){return this.tilesets.map(e=>e.tileset)}getLayers(){return this.layers}getLayerByName(e){return this.layers.find(t=>t.name===e)||null}getTileById(e){const t=this.tilesets;for(let s of t){let r=s.tileset.getTileById(e-s.firstGlobalId);if(r)return r}return null}}return c.Camera=C,c.Color=p,c.Scene=z,c.Sprite=w,c.Tilemap=b,c.Tileset=m,c.Vector=d,c.assets=R,c.createRenderer=W,c.matrix=E,Object.defineProperty(c,Symbol.toStringTag,{value:"Module"}),c})({});
