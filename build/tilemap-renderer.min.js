(function(v,S){typeof exports=="object"&&typeof module<"u"?S(exports):typeof define=="function"&&define.amd?define(["exports"],S):(v=typeof globalThis<"u"?globalThis:v||self,S(v.TilemapRenderer={}))})(this,(function(v){"use strict";class S{constructor(e){this.repeat=!0,this.currentFrameIndex=0,this.frameTimer=0,this.sprite=e,this.animation=null}play(e,t={}){const i=this.sprite.tileset.getTile(e.x,e.y);if(!i)return;const s=i.animation||[{tileid:i.id,duration:100}];if(!t.restart&&this.animation===s)return;this.animation=s,this.repeat=t.repeat??!0,this.currentFrameIndex=0,this.frameTimer=0;const r=this.animation[0],o=this.sprite.tileset.getTileXY(r.tileid);this.sprite.setTilesetRegion(o.x,o.y)}update(e){if(!this.animation)return;const t=this.animation[this.currentFrameIndex];if(this.frameTimer+=e*1e3,this.frameTimer<t.duration)return;if(this.frameTimer-=t.duration,this.currentFrameIndex++,this.currentFrameIndex>=this.animation.length)if(this.repeat)this.currentFrameIndex=0;else{this.currentFrameIndex=this.animation.length-1,this.onEnded?.(this.animation),this.animation=null;return}const i=this.animation[this.currentFrameIndex],s=this.sprite.tileset.getTileXY(i.tileid);this.sprite.setTilesetRegion(s.x,s.y)}}const $={loadImage:t=>new Promise((i,s)=>{const r=new Image;r.crossOrigin="anonymous",r.src=t,r.onload=()=>{i(r)},r.onerror=()=>{s("Failed to load image: "+t)}}),loadJson:async t=>{try{return await(await fetch(t)).json()}catch{throw new Error(`Failed to load json: ${t}`)}}};class x{constructor(e=0,t=0){this.x=e,this.y=t}set(e,t){return this.x=e,this.y=t,this}copy(e){return this.x=e.x,this.y=e.y,this}clone(){return new x(this.x,this.y)}add(e){return this.x+=e.x,this.y+=e.y,this}sub(e){return this.x-=e.x,this.y-=e.y,this}scale(e){return this.x*=e,this.y*=e,this}mul(e){return this.x*=e.x,this.y*=e.y,this}div(e){return e!==0?(this.x/=e,this.y/=e):(this.x=0,this.y=0),this}static dot(e,t){return e.x*t.x+e.y*t.y}static cross(e,t){return e.x*t.y-e.y*t.x}len(){return Math.sqrt(this.x*this.x+this.y*this.y)}lenSq(){return this.x*this.x+this.y*this.y}normalize(){const e=this.len();return e>0&&this.div(e),this}project(e){const t=e.lenSq();if(t===0)return this.scale(0);const i=x.dot(this,e);return this.copy(e).scale(i/t)}static distance(e,t){const i=e.x-t.x,s=e.y-t.y;return Math.sqrt(i*i+s*s)}angle(){return Math.atan2(this.y,this.x)}rot(e){const t=Math.cos(e),i=Math.sin(e),s=this.x*t-this.y*i,r=this.x*i+this.y*t;return this.x=s,this.y=r,this}static fromAngle(e,t=1){return new x(-Math.sin(e)*t,Math.cos(e)*t)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this}toString(){return`Vector(${this.x}, ${this.y})`}toArray(){return new Float32Array([this.x,this.y])}}class xe{constructor(e,t){this.position=new x,this.vw=0,this.vh=0,this.updateProjection(e,t)}updateProjection(e,t){this.vw=e,this.vh=t}getBounds(){return{min:this.position.clone(),max:this.position.clone().add(new x(this.vw,this.vh))}}}class ae{constructor(){this.position=new x,this.offset=new x,this.angle=0,this.isStatic=!1}getCenter(){return this.position.clone().add(this.offset)}}class ve extends ae{constructor(e){super(),this.radius=e}getType(){return"circle"}getBounds(){const e=this.getCenter(),t=this.radius;return{min:e.clone().sub(new x(t,t)),max:e.clone().add(new x(t,t))}}}class le extends ae{constructor(e){super(),this.points=e}getType(){return"polygon"}getWorldPoints(){return this.points.map(e=>e.clone().add(this.offset).rot(-this.angle).add(this.position))}getBounds(){let e=1/0,t=1/0,i=-1/0,s=-1/0;const r=this.getWorldPoints();for(const o of r)o.x<e&&(e=o.x),o.y<t&&(t=o.y),o.x>i&&(i=o.x),o.y>s&&(s=o.y);return{min:new x(e,t),max:new x(i,s)}}}class be extends le{constructor(e,t){const i=[new x(0,0),new x(e,0),new x(e,t),new x(0,t)];super(i),this.width=e,this.height=t}}const ye={CircleCollider:ve,PolygonCollider:le,BoxCollider:be};class w{constructor(e,t,i,s=1){this.r=e,this.g=t,this.b=i,this.a=s}set(e,t,i,s){this.r=e,this.g=t,this.b=i,this.a=s}copy(e){this.r=e.r,this.g=e.g,this.b=e.b,this.a=e.a}toArray(){return new Float32Array([this.r,this.g,this.b,this.a])}}class Te{constructor(e){this.position=e.position||new x,this.color=e.color||new w(1,1,1),this.intensity=e.intensity||1,this.radius=e.radius,this.direction=e.direction||new x(0,1),this.cutoff=e.cutoff||0,this.isStatic=e.isStatic||!1}getBounds(){const e=new x(this.radius,this.radius);return{min:this.position.clone().sub(e),max:this.position.clone().add(e)}}}const T=(()=>{const h=(o,l,a)=>Math.min(Math.max(o,l),a);return{clamp:h,lerp:(o,l,a)=>o+(l-o)*a,unlerp:(o,l,a)=>h((a-o)/(l-o),0,1),sat:o=>h(o,0,1),degToRad:o=>o/180*Math.PI,radToDeg:o=>o/Math.PI*180}})(),we={create:()=>new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]),identity:r=>(r[0]=1,r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[5]=1,r[6]=0,r[7]=0,r[8]=0,r[9]=0,r[10]=1,r[11]=0,r[12]=0,r[13]=0,r[14]=0,r[15]=1,r),createOrtho:(r,o,l,a,n)=>(r[0]=2/(l-o),r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[5]=2/(n-a),r[6]=0,r[7]=0,r[8]=0,r[9]=0,r[10]=1,r[11]=0,r[12]=-(l+o)/(l-o),r[13]=-(n+a)/(n-a),r[14]=0,r[15]=1,r),translate:(r,o)=>(r[12]+=o.x,r[13]+=o.y,r),scale:(r,o)=>(r[0]*=o.x,r[1]*=o.x,r[4]*=o.y,r[5]*=o.y,r)},B=(h,e)=>(e.min.x-h.max.x)*(e.max.x-h.min.x)<0&&(e.min.y-h.max.y)*(e.max.y-h.min.y)<0,b=(()=>{const h=new Float32Array([0,1,0,0,0,0,0,1,1,1,1,0,1,0,1,1]),e=new Float32Array([-1,1,0,0,-1,-1,0,1,1,1,1,0,1,-1,1,1]),t=68,i=(n,f=!1)=>{const u=f?1:4,d=t,m=new ArrayBuffer(n.length*u*d),c=new DataView(m);let g=0;for(const p of n){const k=p.position.x,D=p.position.y,R=p.scale.x,O=p.scale.y,oe=p.angle,ne=p.tilesetRegion.x*(p.tileset.tileWidth+p.tileset.spacing)+p.tileset.margin,V=p.tilesetRegion.y*(p.tileset.tileHeight+p.tileset.spacing)+p.tileset.margin,Y=p.tileset.tileWidth+((p.tilesetRegion.width||1)-1)*(p.tileset.tileWidth+p.tileset.spacing),gt=p.tileset.tileHeight+((p.tilesetRegion.height||1)-1)*(p.tileset.tileHeight+p.tileset.spacing);for(let pe=0;pe<u;++pe)c.setFloat32(g,k,!0),c.setFloat32(g+4,D,!0),c.setFloat32(g+8,R,!0),c.setFloat32(g+12,O,!0),c.setFloat32(g+16,oe,!0),c.setUint16(g+20,ne,!0),c.setUint16(g+22,V,!0),c.setUint16(g+24,Y,!0),c.setUint16(g+26,gt,!0),c.setFloat32(g+28,p.tintColor.r,!0),c.setFloat32(g+32,p.tintColor.g,!0),c.setFloat32(g+36,p.tintColor.b,!0),c.setFloat32(g+40,p.tintColor.a,!0),c.setFloat32(g+44,p.maskColor.r,!0),c.setFloat32(g+48,p.maskColor.g,!0),c.setFloat32(g+52,p.maskColor.b,!0),c.setFloat32(g+56,p.maskColor.a,!0),c.setFloat32(g+60,p.offset.x,!0),c.setFloat32(g+64,p.offset.y,!0),g+=d}return m},s=48,r=(n,f=!1)=>{const u=f?1:4,d=new Float32Array(n.length*64);let m=0;for(let c of n)for(let g=0;g<u;++g)d.set(c.position.toArray(),m),d[m+2]=c.radius,d.set(c.color.toArray(),m+4),d[m+7]=c.intensity,d.set(c.direction.toArray(),m+8),d[m+10]=c.cutoff,m+=64;return d},o=(n,f)=>{const u=f.getCenter(),d=u.sub(n.position).normalize(),m=new x(-d.y,d.x).scale(f.radius),c=u.clone().sub(m),g=u.clone().add(m),p=c.clone().sub(n.position).normalize(),k=g.clone().sub(n.position).normalize(),D=n.radius,R=c.clone().add(p.scale(D)),O=g.clone().add(k.scale(D));return[c.x,c.y,g.x,g.y,R.x,R.y,R.x,R.y,g.x,g.y,O.x,O.y]},l=(n,f)=>{const u=[],d=n.radius,m=f.getWorldPoints();for(let c=0;c<m.length;c++){const g=m[c],p=m[(c+1)%m.length],D=g.clone().add(p).scale(.5).clone().sub(n.position).normalize(),R=p.clone().sub(g).normalize(),O=new x(-R.y,R.x);if(x.dot(O,D)<=0)continue;const oe=g.clone().sub(n.position).normalize(),ne=p.clone().sub(n.position).normalize(),V=g.clone().add(oe.scale(d*100)),Y=p.clone().add(ne.scale(d*100));u.push(g.x,g.y,p.x,p.y,V.x,V.y,V.x,V.y,p.x,p.y,Y.x,Y.y)}return u};return{quad:h,fullscreenQuad:e,spriteStride:t,createSpritesData:i,lightStride:s,createLightsGeometry:r,createShadowsGeometry:(n,f,u,d=0)=>{for(let m of u){let c=[];switch(m.getType()){case"circle":c=o(f,m);break;case"polygon":c=l(f,m);break}n.set(c,d),d+=c.length}return d}}})(),Ce=h=>{switch(h){case"float":return 1;case"vec2":return 2;case"vec3":return 3;case"vec4":return 4}},z=class z{constructor(){this.functions=[],this.uniforms=[],this.uniformOffset=0,this.uniform("resolution","vec2"),this.uniform("time","float")}pushOp(e){if(!this.functions.length)throw new Error("No function declaration");this.functions[this.functions.length-1].ops.push(e)}declareFn(e,t,...i){return this.functions.push({declaration:[1,e,t,...i],ops:[]}),this}mainImage(){return this.declareFn("mainImage","vec4",["fragCoord","vec2"]).declareVar("fragColor","vec4")}return(e){return this.pushOp([2,e]),this}declareVar(e,t){return this.pushOp([0,e,t]),this}set(e,t){return this.pushOp([3,e,t]),this}add(e,t){return this.pushOp([4,e,t]),this}sub(e,t){return this.pushOp([5,e,t]),this}mul(e,t){return this.pushOp([6,e,t]),this}div(e,t){return this.pushOp([7,e,t]),this}if(e){return this.pushOp([9,e]),this}elseif(e){return this.pushOp([10,e]),this}else(){return this.pushOp([11]),this}endif(){return this.pushOp([12]),this}uniform(e,t){return this.uniforms.push({name:e,type:t,offset:this.uniformOffset}),this.uniformOffset+=Ce(t),this}getUniforms(){return this.uniforms}build(e){const t=[];for(let i=0;i<this.functions.length;++i){const s=[],[r,o,l,...a]=this.functions[i].declaration;s.push(`${e.getBuilderOptions().declareFn(o,l,...a)} {`);const n=[...this.functions[i].ops];o==="mainImage"&&n.push([2,"fragColor"]);let f=0;for(const u of n){const d=u[0];let m;switch(d){case 0:{const[c,g,p]=u;m=e.getBuilderOptions().declareVar(g,p);break}case 3:case 4:case 5:case 6:case 7:{const[c,g,p]=u;m=this.replaceExpression(e,`${g} ${this.getOpAssignmentSymbol(d)} ${p};`);break}case 9:case 10:{const c=u[1];m=`${d===9?"":"} else "}if (${this.replaceExpression(e,c)}) {`;break}case 11:case 12:{m="}"+(d===12?"":" else {");break}case 2:{const c=u[1];m=`return ${this.replaceExpression(e,c)};`;break}}m=m.split(`
`).map(c=>{for(let g=0;g<f+1;++g)c="    "+c;return c}).join(`
`),d===9?f+=1:d===12&&(f-=1),s.push(m)}s.push("}"),t.push(s.join(`
`))}return z.DEBUG&&console.log(t.join(`

`)),{functions:t,uniforms:this.uniforms.map(i=>e.getBuilderOptions().declareVar(i.name,i.type,!0))}}getOpAssignmentSymbol(e){switch(e){case 3:return"=";case 4:return"+=";case 5:return"-=";case 6:return"*=";case 7:return"/=";default:return""}}replaceExpression(e,t){if(e.getType()!=="webgpu")for(let i=0;i<_;++i)t=t.replace(new RegExp("texture\\s*\\(\\s*"+i+"\\s*,","g"),"texture(uChannel"+i+", ").replaceAll("float",e.getBuilderOptions().replaceType("float")).replaceAll("vec2",e.getBuilderOptions().replaceType("vec2")).replaceAll("vec3",e.getBuilderOptions().replaceType("vec3")).replaceAll("vec4",e.getBuilderOptions().replaceType("vec4"));return this.replaceComponents(e,t)}replaceComponents(e,t){const i=e.getBuilderOptions().componentMap;return t.replace(/\.[rgba]{1,4}\b/g,s=>{const r=s.substring(1);let o=".";for(let l=0;l<r.length;++l){const a=r[l];o+=i[a]??a}return o})}};z.DEBUG=!1;let P=z;const F=new P().mainImage().declareVar("uv","vec2").set("uv","fragCoord / uniforms.resolution").add("fragColor","texture(0, uv)"),H=new P().mainImage().declareVar("uv","vec2").declareVar("baseColor","vec4").set("uv","fragCoord / uniforms.resolution").set("baseColor","texture(0, uv)").add("fragColor","vec4(baseColor.rgb * texture(1, uv).rgb, baseColor.a)"),W=new P().mainImage().declareVar("uv","vec2").declareVar("w","float").declareVar("sum","vec4").set("uv","fragCoord / uniforms.resolution").set("w","1.0 / uniforms.resolution.x").set("sum",`(
    texture(0, uv + vec2(-3.0 * w, 0.0)) * 0.05 +
    texture(0, uv + vec2(-2.0 * w, 0.0)) * 0.1 +
    texture(0, uv + vec2(-1.0 * w, 0.0)) * 0.2 +
    texture(0, uv) * 0.3 +
    texture(0, uv + vec2(1.0 * w, 0.0)) * 0.2 +
    texture(0, uv + vec2(2.0 * w, 0.0)) * 0.1 +
    texture(0, uv + vec2(3.0 * w, 0.0)) * 0.05
)`).set("fragColor","sum"),q=new P().mainImage().declareVar("uv","vec2").declareVar("h","float").declareVar("sum","vec4").set("uv","fragCoord / uniforms.resolution").set("h","1.0 / uniforms.resolution.y").set("sum",`(
    texture(0, uv + vec2(0.0, -3.0 * h)) * 0.05 +
    texture(0, uv + vec2(0.0, -2.0 * h)) * 0.1 +
    texture(0, uv + vec2(0.0, -1.0 * h)) * 0.2 +
    texture(0, uv) * 0.3 +
    texture(0, uv + vec2(0.0, 1.0 * h)) * 0.2 +
    texture(0, uv + vec2(0.0, 2.0 * h)) * 0.1 +
    texture(0, uv + vec2(0.0, 3.0 * h)) * 0.05
)`).set("fragColor","sum");class he{constructor(e,t,i){this.gl=e,this.width=t,this.height=i,this.texture=e.createTexture(),e.bindTexture(e.TEXTURE_2D,this.texture),e.texImage2D(e.TEXTURE_2D,0,e.RGBA,t,i,0,e.RGBA,e.UNSIGNED_BYTE,null),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.LINEAR),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.LINEAR),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),this.fbo=e.createFramebuffer(),e.bindFramebuffer(e.FRAMEBUFFER,this.fbo),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,this.texture,0),e.checkFramebufferStatus(e.FRAMEBUFFER)!==e.FRAMEBUFFER_COMPLETE&&console.error("Framebuffer incomplete!"),e.bindFramebuffer(e.FRAMEBUFFER,null),e.bindTexture(e.TEXTURE_2D,null)}bind(){this.gl.bindFramebuffer(this.gl.FRAMEBUFFER,this.fbo),this.gl.viewport(0,0,this.width,this.height)}unbind(){this.gl.bindFramebuffer(this.gl.FRAMEBUFFER,null)}destroy(){this.gl.deleteFramebuffer(this.fbo),this.gl.deleteTexture(this.texture)}}class A{constructor(e,t,i){this.gl=e,this.uniforms=new Map,this.attribs=new Map;const s=this.compileShader(e.VERTEX_SHADER,t),r=this.compileShader(e.FRAGMENT_SHADER,i);if(this.program=e.createProgram(),e.attachShader(this.program,s),e.attachShader(this.program,r),e.linkProgram(this.program),!e.getProgramParameter(this.program,e.LINK_STATUS))throw new Error(e.getProgramInfoLog(this.program)??"Could not link program");e.deleteShader(s),e.deleteShader(r)}compileShader(e,t){const i=this.gl.createShader(e);if(!i)throw new Error("Could not create shader");if(this.gl.shaderSource(i,t),this.gl.compileShader(i),!this.gl.getShaderParameter(i,this.gl.COMPILE_STATUS))throw new Error(this.gl.getShaderInfoLog(i)??"Could not compile shader");return i}use(){this.gl.useProgram(this.program)}getUniform(e){if(!this.uniforms.has(e)){const t=this.gl.getUniformLocation(this.program,e);this.uniforms.set(e,t)}return this.uniforms.get(e)}getAttrib(e){return this.attribs.has(e)||this.attribs.set(e,this.gl.getAttribLocation(this.program,e)),this.attribs.get(e)}}const j=`
vec4 worldToClip(vec2 worldPos, vec2 cameraPos, vec2 viewport) {
    vec2 pixelPos = worldPos - cameraPos;
    vec2 clipPos = vec2(pixelPos.x / viewport.x, 1.0 - pixelPos.y / viewport.y) * 2.0 - 1.0;
    return vec4(clipPos, 0.0, 1.0);
}
`,ue=`

attribute vec2 aVertexPos;
attribute vec2 aTexCoord;
attribute vec2 aTilePos;
attribute float aTileAngle;
attribute vec2 aTileScale;
attribute vec4 aTileRegion;
attribute vec4 aTintColor;
attribute vec4 aMaskColor;
attribute vec2 aTileOffset;

uniform vec2 uViewportDimensions;
uniform vec2 uCameraPos;

uniform vec2 uTilesetDimensions;

varying vec2 uv;
varying vec4 tintColor;
varying vec4 maskColor;

${j}

void main() {
    tintColor = aTintColor;
    maskColor = aMaskColor;

    vec2 flippedTexCoord = vec2(aTexCoord.x, 1.0 - aTexCoord.y);
    uv = (vec2(aTileRegion.xy) + flippedTexCoord * vec2(aTileRegion.zw)) / uTilesetDimensions;

    float c = cos(aTileAngle);
    float s = sin(aTileAngle);
    vec2 offsetPos = (aVertexPos * abs(aTileScale) + aTileOffset) * sign(aTileScale);
    vec2 rotatedPos = vec2(
        offsetPos.x * c - offsetPos.y * s,
        offsetPos.x * s + offsetPos.y * c
    );
    vec2 worldPos = rotatedPos + aTilePos;

    gl_Position = worldToClip(worldPos, uCameraPos, uViewportDimensions);
}
`,Ae=`

precision mediump float;

varying vec2 uv;
varying vec4 tintColor;

uniform sampler2D uSampler;  

void main() {
    gl_FragColor = texture2D(uSampler, uv) * tintColor;
}
`,Re=`

precision mediump float;

varying vec2 uv;
varying vec4 maskColor;

uniform mediump sampler2D uSampler;  

void main() {
    vec4 texColor = texture2D(uSampler, uv);
    gl_FragColor = vec4(maskColor.rgb, texColor.a * maskColor.a);
}
`,Pe=`
precision mediump float;

attribute vec2 aVertexPos;

uniform vec2 uLightCenter;
uniform float uLightRadius;

uniform vec2 uCameraPos;
uniform vec2 uViewportDimensions;

varying vec2 worldPos;

${j}

void main() {
    worldPos = uLightCenter + (aVertexPos - 0.5) * 2.0 * uLightRadius;

    gl_Position = worldToClip(worldPos, uCameraPos, uViewportDimensions);
}
`,Ee=`

precision mediump float;

varying vec2 worldPos;

uniform vec2 uLightCenter;
uniform float uLightRadius;
uniform vec3 uLightColor;
uniform float uLightIntensity;
uniform vec2 uLightDir;
uniform float uLightCutoff;

void main() {
    vec2 toPixel = worldPos - uLightCenter;
    float dist = length(toPixel);

    float attenuation = clamp(1.0 - pow(dist / uLightRadius, 2.0), 0.0, 1.0);

    float spotFactor = 1.0;
    if (uLightCutoff > 0.0) {
        float cosAngle = dot(normalize(uLightDir), normalize(toPixel));
        spotFactor = clamp((cosAngle - uLightCutoff) / (1.0 - uLightCutoff), 0.0, 1.0);
    }

    gl_FragColor = vec4(uLightColor * uLightIntensity * attenuation * spotFactor, 1.0);
}
`,Se=`
attribute vec2 aPos;

uniform vec2 uCameraPos;
uniform vec2 uViewportDimensions;

${j}

void main() {
    gl_Position = worldToClip(aPos, uCameraPos, uViewportDimensions);
}
`,Be=`
precision mediump float;

uniform vec2 uLightPos;

void main() {
    gl_FragColor = vec4(vec3(0.0), 1.0);
}
`,Fe=`

attribute vec2 aPos;

void main() {
    gl_Position = vec4(aPos, 0.0, 1.0);
}
`,Ue=h=>`
#define texture texture2D

precision mediump float;

struct Uniforms {
${h.uniforms.map(e=>"    "+e).join(`
`)}
};

uniform sampler2D uChannel0;
uniform sampler2D uChannel1;
uniform sampler2D uChannel2;
uniform sampler2D uChannel3;
uniform sampler2D uChannel4;
uniform sampler2D uChannel5;
uniform sampler2D uChannel6;
uniform sampler2D uChannel7;

uniform Uniforms uniforms;

${h.functions.join(`

`)}

void main() {
    vec2 fragCoord = vec2(gl_FragCoord.x, gl_FragCoord.y);
    gl_FragColor = mainImage(fragCoord);
}
`,_e={componentMap:{r:"r",g:"g",b:"b",a:"a"},replaceType(h){return h},declareFn(h,e,...t){return`${e===null?"void":e} ${h}(${t.map(i=>`${i[1]} ${i[0]}`).join(", ")})`},declareVar(h,e){return`${e} ${h};`}};class Le{constructor(e){this.canvas=e,this.layersMap=new Map,this.texturesMap=new Map,this.clearColor=new w(0,0,0,0),this.shaderMap=new Map,this.initialized=!1,this.pass=[ee],this.framebuffers=[],this.shaderCache=new Map,this.time=0,this.resizeRequested=!1}getType(){return"webgl"}getBuilderOptions(){return _e}addTextures(e,t){for(const i of e)t[i.name]&&this.texturesMap.set(i.name,{tileset:i,image:t[i.name]})}registerShader(e,t,i="none"){this.shaderMap.set(e,{builder:t,blendMode:i})}setClearColor(e){this.clearColor.copy(e)}setSize(e,t){this.canvas.width=e,this.canvas.height=t,this.initialized&&(this.resizeRequested=!0)}getCanvas(){return this.canvas}initFramebuffers(){for(let e=0;e<C;++e){const t=te(e);this.framebuffers[e]?.destroy(),this.framebuffers[e]=new he(this.gl,this.canvas.width*t,this.canvas.height*t)}}blend(e){switch(e){case"alpha":this.gl.enable(this.gl.BLEND),this.gl.blendFunc(this.gl.SRC_ALPHA,this.gl.ONE_MINUS_SRC_ALPHA);break;case"additive":this.gl.enable(this.gl.BLEND),this.gl.blendFunc(this.gl.ONE,this.gl.ONE);break;default:this.gl.disable(this.gl.BLEND)}}async init(){const e=this.canvas.getContext("webgl");if(!e)throw new Error("WebGL not supported");this.gl=e;for(const r of this.texturesMap.values())r.tileset&&(r.texture=this.createTexture(r.image));this.registerShader("default",F),this.registerShader("default_additive",F,"additive"),this.registerShader("light",H),this.registerShader("blurHorizontal",W),this.registerShader("blurVertical",q);for(const r of this.shaderMap.values()){if(!this.shaderCache.has(r.builder)){const o=r.builder.build(this),l=new A(e,Fe,Ue(o));this.shaderCache.set(r.builder,l)}r.shader=this.shaderCache.get(r.builder)}this.shaderProgram=new A(e,ue,Ae),this.maskShaderProgram=new A(e,ue,Re),this.lightShaderProgram=new A(e,Pe,Ee),this.shadowShaderProgram=new A(e,Se,Be),this.vbo=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.vbo);const t=new Float32Array(E*4*4);for(let r=0;r<E;++r)t.set(b.quad,r*4*4);e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW);const i=[0,1,2,1,2,3];this.ebo=e.createBuffer(),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,this.ebo);const s=new Uint16Array(E*6);for(let r=0;r<E;++r)for(let o=0;o<6;++o)s[r*6+o]=i[o]+4*r;e.bufferData(e.ELEMENT_ARRAY_BUFFER,s,e.STATIC_DRAW),this.initFramebuffers(),this.fullscreenVbo=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.fullscreenVbo),e.bufferData(e.ARRAY_BUFFER,b.fullscreenQuad,e.STATIC_DRAW),this.shadowsVbo=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.shadowsVbo),e.bufferData(e.ARRAY_BUFFER,N*L*8,e.DYNAMIC_DRAW),this.initialized=!0}renderScene(e,t,i,s,r){e.bind(),this.blend("alpha"),s&&(this.gl.clearColor(s.r,s.g,s.b,s.a),this.gl.clear(this.gl.COLOR_BUFFER_BIT)),this.gl.activeTexture(this.gl.TEXTURE0),t.use(),this.gl.uniform2f(t.getUniform("uViewportDimensions"),i.vw,i.vh),this.gl.uniform2f(t.getUniform("uCameraPos"),i.position.x,i.position.y);for(let o of r)o.render(t);e.unbind()}renderLights(e,t){const i=t.getBounds(),s=e.getLights().filter(f=>B(i,f.getBounds())),r=new Float32Array(s.length*L*2),o=[];let l=0;for(let f of s){const u=e.getColliders(f.getBounds()),d=b.createShadowsGeometry(r,f,u,l);o.push({count:(d-l)/2,offset:l/2}),l=d}this.gl.bindBuffer(this.gl.ARRAY_BUFFER,this.shadowsVbo),this.gl.bufferSubData(this.gl.ARRAY_BUFFER,0,r),this.framebuffers[y].bind(),this.gl.clearColor(e.ambientColor.r*e.ambientIntensity,e.ambientColor.g*e.ambientIntensity,e.ambientColor.b*e.ambientIntensity,1),this.gl.clear(this.gl.COLOR_BUFFER_BIT),this.framebuffers[y].unbind();const a=this.lightShaderProgram.getAttrib("aVertexPos"),n=this.shadowShaderProgram.getAttrib("aPos");for(let f=0;f<s.length;++f){const u=s[f];this.framebuffers[y+1].bind(),this.blend("none"),this.gl.clearColor(0,0,0,1),this.gl.clear(this.gl.COLOR_BUFFER_BIT),this.lightShaderProgram.use(),this.gl.uniform2f(this.lightShaderProgram.getUniform("uViewportDimensions"),t.vw,t.vh),this.gl.uniform2f(this.lightShaderProgram.getUniform("uCameraPos"),t.position.x,t.position.y),this.gl.uniform2f(this.lightShaderProgram.getUniform("uLightCenter"),u.position.x,u.position.y),this.gl.uniform1f(this.lightShaderProgram.getUniform("uLightRadius"),u.radius),this.gl.uniform3f(this.lightShaderProgram.getUniform("uLightColor"),u.color.r,u.color.g,u.color.b),this.gl.uniform1f(this.lightShaderProgram.getUniform("uLightIntensity"),u.intensity),this.gl.uniform2f(this.lightShaderProgram.getUniform("uLightDir"),u.direction.x,u.direction.y),this.gl.uniform1f(this.lightShaderProgram.getUniform("uLightCutoff"),u.cutoff),this.gl.bindBuffer(this.gl.ARRAY_BUFFER,this.vbo),this.gl.enableVertexAttribArray(a),this.gl.vertexAttribPointer(a,2,this.gl.FLOAT,!1,16,0),this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),this.gl.disableVertexAttribArray(a);const d=o[f];d.count!==0&&(this.shadowShaderProgram.use(),this.gl.uniform2f(this.shadowShaderProgram.getUniform("uViewportDimensions"),t.vw,t.vh),this.gl.uniform2fv(this.shadowShaderProgram.getUniform("uCameraPos"),t.position.toArray()),this.gl.uniform2fv(this.shadowShaderProgram.getUniform("uLightPos"),u.position.toArray()),this.gl.bindBuffer(this.gl.ARRAY_BUFFER,this.shadowsVbo),this.gl.enableVertexAttribArray(n),this.gl.vertexAttribPointer(n,2,this.gl.FLOAT,!1,8,0),this.gl.drawArrays(this.gl.TRIANGLES,d.offset,d.count),this.gl.disableVertexAttribArray(n)),this.framebuffers[y+1].unbind(),this.renderFullscreenPass({shader:"blurHorizontal",inputs:[y+1],output:4}),this.renderFullscreenPass({shader:"blurVertical",inputs:[4],output:5}),this.renderFullscreenPass({shader:"default_additive",inputs:[5],output:y})}}renderFullscreenPass(e){const t=this.shaderMap.get(e.shader);if(!t)throw new Error("Unknown shader "+e.shader);e.clearColor&&(this.gl.clearColor(this.clearColor.r,this.clearColor.g,this.clearColor.b,this.clearColor.a),this.gl.clear(this.gl.COLOR_BUFFER_BIT));const i=t.shader;let s=this.canvas.width,r=this.canvas.height;if(e.output!==-1){const n=this.framebuffers[T.clamp(e.output,0,C-1)];s=n.width,r=n.height,n.bind()}else this.gl.viewport(0,0,s,r);this.blend(t.blendMode),i.use();const o=[{name:"time",value:this.time},{name:"resolution",value:[s,r]}].concat(e.uniforms??[]),l=t.builder.getUniforms();for(let n of l){const f=o.find(u=>u.name===n.name);if(f){const u=typeof f.value=="number"?[f.value]:f.value,d=i.getUniform("uniforms."+n.name);switch(n.type){case"float":this.gl.uniform1f(d,u[0]);break;case"vec2":this.gl.uniform2fv(d,u);break;case"vec3":this.gl.uniform3fv(d,u);break;case"vec4":this.gl.uniform4fv(d,u);break}}}for(let n=0;n<_;n++){const f=e.inputs[n]??e.inputs[0],u=this.framebuffers[T.clamp(f,0,C-1)].texture;this.gl.activeTexture(this.gl.TEXTURE0+n),this.gl.bindTexture(this.gl.TEXTURE_2D,u);const d=i.getUniform(`uChannel${n}`);this.gl.uniform1i(d,n)}const a=i.getAttrib("aPos");this.gl.bindBuffer(this.gl.ARRAY_BUFFER,this.fullscreenVbo),this.gl.enableVertexAttribArray(a),this.gl.vertexAttribPointer(a,2,this.gl.FLOAT,!1,16,0),this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),this.gl.disableVertexAttribArray(a);for(let n=0;n<_;n++)this.gl.activeTexture(this.gl.TEXTURE0+n),this.gl.bindTexture(this.gl.TEXTURE_2D,null);e.output!==-1&&this.framebuffers[T.clamp(e.output,0,C-1)].unbind()}render(e,t){if(!this.initialized)throw new Error("Renderer is not initialized");this.resizeRequested&&(this.initFramebuffers(),this.resizeRequested=!1);const i=t.getBounds();this.time=performance.now()*.001;const s=[];for(const r of e.getLayersOrdered()){let o;if(this.layersMap.has(r)||this.layersMap.set(r,new Ie(this.gl,this,r.isStatic)),o=this.layersMap.get(r),o.needsUpdate){let l=r.getSpritesOrdered();o.isStatic||(l=l.filter(a=>B(i,a.getBounds()))),o.uploadSprites(r.getSpritesOrdered())}s.push(o)}this.renderScene(this.framebuffers[0],this.shaderProgram,t,this.clearColor,s),this.renderFullscreenPass({shader:"default",inputs:[0],output:-1}),this.renderLights(e,t),this.renderScene(this.framebuffers[I],this.shaderProgram,t,this.clearColor,s),this.renderFullscreenPass({shader:"light",inputs:[I,y],output:0}),this.renderScene(this.framebuffers[Z],this.maskShaderProgram,t,ie,s);for(let r=0;r<this.pass.length;++r){const o=this.pass[r];this.renderFullscreenPass(o)}for(const[r,o]of this.layersMap)o.lifetime<=0&&(this.layersMap.delete(r),o.destroy())}getTextureInfo(e){const t=this.texturesMap.get(e);if(!t)throw new Error("Texture not found: "+e);return t}getVBO(){return this.vbo}getEBO(){return this.ebo}createTexture(e){const t=this.gl,i=t.createTexture();return t.bindTexture(t.TEXTURE_2D,i),t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,e),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.NEAREST),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,t.NEAREST),i}}let Ie=class{constructor(e,t,i){this.gl=e,this.renderer=t,this.isStatic=i,this.needsUpdate=!0,this.drawCalls=[],this.lifetime=U,this.spriteBuffer=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.spriteBuffer),e.bufferData(e.ARRAY_BUFFER,(this.isStatic?E:Q)*b.spriteStride*4,this.isStatic?e.STATIC_DRAW:e.DYNAMIC_DRAW)}uploadSprites(e){const t=this.gl;t.bindBuffer(t.ARRAY_BUFFER,this.spriteBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,b.createSpritesData(e,!1)),this.isStatic&&(this.needsUpdate=!1),this.drawCalls.length=0;let i=null;for(let s=0;s<e.length;++s){const r=e[s].tileset.name;!i||r!==i.texName?(i={texName:r,spriteOffset:s,spriteCount:1},this.drawCalls.push(i)):i.spriteCount++}}render(e){const t=this.gl;t.bindBuffer(t.ARRAY_BUFFER,this.renderer.getVBO());const i={vertexPos:e.getAttrib("aVertexPos"),texCoord:e.getAttrib("aTexCoord"),tilePos:e.getAttrib("aTilePos"),tileScale:e.getAttrib("aTileScale"),tileAngle:e.getAttrib("aTileAngle"),tileRegion:e.getAttrib("aTileRegion"),tintColor:e.getAttrib("aTintColor"),maskColor:e.getAttrib("aMaskColor"),tileOffset:e.getAttrib("aTileOffset")};t.enableVertexAttribArray(i.vertexPos),t.vertexAttribPointer(i.vertexPos,2,t.FLOAT,!1,16,0),t.enableVertexAttribArray(i.texCoord),t.vertexAttribPointer(i.texCoord,2,t.FLOAT,!1,16,8),t.bindBuffer(t.ARRAY_BUFFER,this.spriteBuffer);const s=b.spriteStride;t.enableVertexAttribArray(i.tilePos),t.vertexAttribPointer(i.tilePos,2,t.FLOAT,!1,s,0),t.enableVertexAttribArray(i.tileScale),t.vertexAttribPointer(i.tileScale,2,t.FLOAT,!1,s,8),t.enableVertexAttribArray(i.tileAngle),t.vertexAttribPointer(i.tileAngle,1,t.FLOAT,!1,s,16),t.enableVertexAttribArray(i.tileRegion),t.vertexAttribPointer(i.tileRegion,4,t.UNSIGNED_SHORT,!1,s,20),t.enableVertexAttribArray(i.tintColor),t.vertexAttribPointer(i.tintColor,4,t.FLOAT,!1,s,28),t.enableVertexAttribArray(i.maskColor),t.vertexAttribPointer(i.maskColor,4,t.FLOAT,!1,s,44),t.enableVertexAttribArray(i.tileOffset),t.vertexAttribPointer(i.tileOffset,2,t.FLOAT,!1,s,60),t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.renderer.getEBO());for(const r of this.drawCalls){const o=this.renderer.getTextureInfo(r.texName);t.bindTexture(t.TEXTURE_2D,o.texture),this.gl.uniform2f(e.getUniform("uTilesetDimensions"),o.tileset.imageWidth,o.tileset.imageHeight),t.drawElements(t.TRIANGLES,6*r.spriteCount,t.UNSIGNED_SHORT,r.spriteOffset*6*2)}t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null),t.disableVertexAttribArray(i.vertexPos),t.disableVertexAttribArray(i.texCoord),t.disableVertexAttribArray(i.tilePos),t.disableVertexAttribArray(i.tileScale),t.disableVertexAttribArray(i.tileAngle),t.disableVertexAttribArray(i.tileRegion),t.disableVertexAttribArray(i.tintColor),t.disableVertexAttribArray(i.maskColor),this.lifetime=U}destroy(){this.gl.deleteBuffer(this.spriteBuffer)}};const K=`
vec4 worldToClip(vec2 worldPos, vec2 cameraPos, vec2 viewport) {
    vec2 pixelPos = worldPos - cameraPos;
    vec2 clipPos = vec2(pixelPos.x / viewport.x, 1.0 - pixelPos.y / viewport.y) * 2.0 - 1.0;
    return vec4(clipPos, 0.0, 1.0);
}
`,ce=`#version 300 es

layout(location = 0) in vec2 aVertexPos;
layout(location = 1) in vec2 aTexCoord;

layout(location = 2) in vec2 aTilePos;
layout(location = 3) in vec2 aTileScale;
layout(location = 4) in float aTileAngle;
layout(location = 5) in uvec4 aTileRegion;

layout(location = 6) in vec4 aTintColor;
layout(location = 7) in vec4 aMaskColor;

layout(location = 8) in vec2 aTileOffset;

uniform vec2 uViewportDimensions;
uniform vec2 uCameraPos;

uniform vec2 uTilesetDimensions;

out vec2 uv;
out vec4 tintColor;
out vec4 maskColor;

${K}

void main() {
    tintColor = aTintColor;
    maskColor = aMaskColor;

    vec2 flippedTexCoord = vec2(aTexCoord.x, 1.0 - aTexCoord.y);
    uv = (vec2(aTileRegion.xy) + flippedTexCoord * vec2(aTileRegion.zw)) / uTilesetDimensions;

    float c = cos(aTileAngle);
    float s = sin(aTileAngle);
    vec2 offsetPos = (aVertexPos * abs(aTileScale) + aTileOffset) * sign(aTileScale);
    vec2 rotatedPos = vec2(
        offsetPos.x * c - offsetPos.y * s,
        offsetPos.x * s + offsetPos.y * c
    );
    vec2 worldPos = rotatedPos + aTilePos;

    gl_Position = worldToClip(worldPos, uCameraPos, uViewportDimensions);
}
`,De=`#version 300 es

precision mediump float;

in vec2 uv;
in vec4 tintColor;

uniform mediump sampler2D uSampler;

out vec4 fragColor;

void main() {
    fragColor = texture(uSampler, uv) * tintColor;
}
`,Oe=`#version 300 es

precision mediump float;

in vec2 uv;
in vec4 maskColor;

uniform mediump sampler2D uSampler;  

out vec4 fragColor;

void main() {
    vec4 texColor = texture(uSampler, uv);
    fragColor = vec4(maskColor.rgb, texColor.a * maskColor.a);
}
`,Ve=`#version 300 es
precision mediump float;

layout(location = 0) in vec2 aVertexPos;

uniform vec2 uLightCenter;
uniform float uLightRadius;

uniform vec2 uCameraPos;
uniform vec2 uViewportDimensions;

out vec2 worldPos;

${K}

void main() {
    worldPos = uLightCenter + (aVertexPos - 0.5) * 2.0 * uLightRadius;

    gl_Position = worldToClip(worldPos, uCameraPos, uViewportDimensions);
}
`,Me=`#version 300 es

precision mediump float;

in vec2 worldPos;

uniform vec2 uLightCenter;
uniform float uLightRadius;
uniform vec3 uLightColor;
uniform float uLightIntensity;
uniform vec2 uLightDir;
uniform float uLightCutoff;

out vec4 fragColor;

void main() {
    vec2 toPixel = worldPos - uLightCenter;
    float dist = length(toPixel);

    float attenuation = clamp(1.0 - pow(dist / uLightRadius, 2.0), 0.0, 1.0);

    float spotFactor = 1.0;
    if (uLightCutoff > 0.0) {
        float cosAngle = dot(normalize(uLightDir), normalize(toPixel));
        spotFactor = clamp((cosAngle - uLightCutoff) / (1.0 - uLightCutoff), 0.0, 1.0);
    }

    fragColor = vec4(uLightColor * uLightIntensity * attenuation * spotFactor, 1.0);
}
`,Ge=`#version 300 es

layout(location = 0) in vec2 aPos;

uniform vec2 uCameraPos;
uniform vec2 uViewportDimensions;

${K}

void main() {
    gl_Position = worldToClip(aPos, uCameraPos, uViewportDimensions);
}
`,Ne=`#version 300 es

precision mediump float;

uniform vec2 uLightPos;

out vec4 fragColor;

void main() {
    fragColor = vec4(vec3(0.0), 1.0);
}
`,ze=`#version 300 es

out vec2 uv;

void main() {
    float x = float((gl_VertexID & 1) << 2);
    float y = float((gl_VertexID & 2) << 1);

    gl_Position = vec4(x - 1.0, y - 1.0, 0.0, 1.0);
}
`,Xe=h=>`#version 300 es
precision mediump float;

struct Uniforms {
${h.uniforms.map(e=>"    "+e).join(`
`)}
};

uniform sampler2D uChannel0;
uniform sampler2D uChannel1;
uniform sampler2D uChannel2;
uniform sampler2D uChannel3;
uniform sampler2D uChannel4;
uniform sampler2D uChannel5;
uniform sampler2D uChannel6;
uniform sampler2D uChannel7;

uniform Uniforms uniforms;

out vec4 glFragColor;

${h.functions.join(`

`)}

void main() {
    vec2 fragCoord = gl_FragCoord.xy;
    glFragColor = mainImage(fragCoord);
}
`,ke={componentMap:{r:"r",g:"g",b:"b",a:"a"},replaceType(h){return h},declareFn(h,e,...t){return`${e===null?"void":e} ${h}(${t.map(i=>`${i[1]} ${i[0]}`).join(", ")})`},declareVar(h,e){return`${e} ${h};`}};class Ye{constructor(e){this.canvas=e,this.layersMap=new Map,this.texturesMap=new Map,this.clearColor=new w(0,0,0,0),this.shaderMap=new Map,this.initialized=!1,this.pass=[ee],this.framebuffers=[],this.time=0,this.shaderCache=new Map,this.resizeRequested=!1}getType(){return"webgl2"}getBuilderOptions(){return ke}addTextures(e,t){for(const i of e)t[i.name]&&this.texturesMap.set(i.name,{tileset:i,image:t[i.name]})}registerShader(e,t,i="none"){this.shaderMap.set(e,{builder:t,blendMode:i})}setClearColor(e){this.clearColor.copy(e)}setSize(e,t){this.canvas.width=e,this.canvas.height=t,this.initialized&&(this.resizeRequested=!0)}getCanvas(){return this.canvas}initFramebuffers(){for(let e=0;e<C;++e){const t=te(e);this.framebuffers[e]?.destroy(),this.framebuffers[e]=new he(this.gl,this.canvas.width*t,this.canvas.height*t)}}blend(e){switch(e){case"alpha":this.gl.enable(this.gl.BLEND),this.gl.blendFunc(this.gl.SRC_ALPHA,this.gl.ONE_MINUS_SRC_ALPHA);break;case"additive":this.gl.enable(this.gl.BLEND),this.gl.blendFunc(this.gl.ONE,this.gl.ONE);break;default:this.gl.disable(this.gl.BLEND)}}async init(){const e=this.canvas.getContext("webgl2");if(!e)throw new Error("WebGL2 not supported");this.gl=e;for(const t of this.texturesMap.values())t.tileset&&(t.texture=this.createTexture(t.image));this.initFramebuffers(),this.registerShader("default",F),this.registerShader("default_additive",F,"additive"),this.registerShader("light",H),this.registerShader("blurHorizontal",W),this.registerShader("blurVertical",q);for(const t of this.shaderMap.values()){if(!this.shaderCache.has(t.builder)){const i=t.builder.build(this),s=new A(e,ze,Xe(i));this.shaderCache.set(t.builder,s)}t.shader=this.shaderCache.get(t.builder)}this.shaderProgram=new A(e,ce,De),this.maskShaderProgram=new A(e,ce,Oe),this.lightShaderProgram=new A(e,Ve,Me),this.shadowShaderProgram=new A(e,Ge,Ne),this.vbo=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.vbo),e.bufferData(e.ARRAY_BUFFER,b.quad,e.STATIC_DRAW),this.lightVao=e.createVertexArray(),e.bindVertexArray(this.lightVao),e.bindBuffer(e.ARRAY_BUFFER,this.vbo),e.enableVertexAttribArray(0),e.vertexAttribPointer(0,2,e.FLOAT,!1,16,0),e.bindVertexArray(null),this.shadowsVbo=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.shadowsVbo),e.bufferData(e.ARRAY_BUFFER,N*L*8,e.DYNAMIC_DRAW),this.shadowsVao=e.createVertexArray(),e.bindVertexArray(this.shadowsVao),e.bindBuffer(e.ARRAY_BUFFER,this.shadowsVbo),e.enableVertexAttribArray(0),e.vertexAttribPointer(0,2,e.FLOAT,!1,8,0),e.bindVertexArray(null),this.initialized=!0}renderScene(e,t,i,s,r){e.bind(),this.blend("alpha"),s&&(this.gl.clearColor(s.r,s.g,s.b,s.a),this.gl.clear(this.gl.COLOR_BUFFER_BIT)),this.gl.activeTexture(this.gl.TEXTURE0),t.use(),this.gl.uniform2f(t.getUniform("uViewportDimensions"),i.vw,i.vh),this.gl.uniform2f(t.getUniform("uCameraPos"),i.position.x,i.position.y);for(let o of r)o.render(t);e.unbind()}renderLights(e,t){const i=t.getBounds(),s=e.getLights().filter(a=>B(i,a.getBounds())),r=new Float32Array(s.length*L*2),o=[];let l=0;for(let a of s){const n=e.getColliders(a.getBounds()),f=b.createShadowsGeometry(r,a,n,l);o.push({count:(f-l)/2,offset:l/2}),l=f}this.gl.bindBuffer(this.gl.ARRAY_BUFFER,this.shadowsVbo),this.gl.bufferSubData(this.gl.ARRAY_BUFFER,0,r,0,l),this.framebuffers[y].bind(),this.gl.clearColor(e.ambientColor.r*e.ambientIntensity,e.ambientColor.g*e.ambientIntensity,e.ambientColor.b*e.ambientIntensity,1),this.gl.clear(this.gl.COLOR_BUFFER_BIT),this.framebuffers[y].unbind();for(let a=0;a<s.length;++a){const n=s[a];this.framebuffers[y+1].bind(),this.blend("none"),this.gl.clearColor(0,0,0,1),this.gl.clear(this.gl.COLOR_BUFFER_BIT),this.lightShaderProgram.use(),this.gl.uniform2f(this.lightShaderProgram.getUniform("uViewportDimensions"),t.vw,t.vh),this.gl.uniform2f(this.lightShaderProgram.getUniform("uCameraPos"),t.position.x,t.position.y),this.gl.uniform2f(this.lightShaderProgram.getUniform("uLightCenter"),n.position.x,n.position.y),this.gl.uniform1f(this.lightShaderProgram.getUniform("uLightRadius"),n.radius),this.gl.uniform3f(this.lightShaderProgram.getUniform("uLightColor"),n.color.r,n.color.g,n.color.b),this.gl.uniform1f(this.lightShaderProgram.getUniform("uLightIntensity"),n.intensity),this.gl.uniform2f(this.lightShaderProgram.getUniform("uLightDir"),n.direction.x,n.direction.y),this.gl.uniform1f(this.lightShaderProgram.getUniform("uLightCutoff"),n.cutoff),this.gl.bindVertexArray(this.lightVao),this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),this.gl.bindVertexArray(null);const f=o[a];f.count!==0&&(this.shadowShaderProgram.use(),this.gl.uniform2f(this.shadowShaderProgram.getUniform("uViewportDimensions"),t.vw,t.vh),this.gl.uniform2fv(this.shadowShaderProgram.getUniform("uCameraPos"),t.position.toArray()),this.gl.uniform2fv(this.shadowShaderProgram.getUniform("uLightPos"),n.position.toArray()),this.gl.bindVertexArray(this.shadowsVao),this.gl.drawArrays(this.gl.TRIANGLES,f.offset,f.count),this.gl.bindVertexArray(null)),this.framebuffers[y+1].unbind(),this.renderFullscreenPass({shader:"blurHorizontal",inputs:[y+1],output:4}),this.renderFullscreenPass({shader:"blurVertical",inputs:[4],output:5}),this.renderFullscreenPass({shader:"default_additive",inputs:[5],output:y})}}renderFullscreenPass(e){const t=this.shaderMap.get(e.shader);if(!t)throw new Error("Unknown shader "+e.shader);e.clearColor&&(this.gl.clearColor(this.clearColor.r,this.clearColor.g,this.clearColor.b,this.clearColor.a),this.gl.clear(this.gl.COLOR_BUFFER_BIT));const i=t.shader;let s=this.canvas.width,r=this.canvas.height;if(e.output!==-1){const a=this.framebuffers[T.clamp(e.output,0,C-1)];s=a.width,r=a.height,a.bind()}else this.gl.viewport(0,0,s,r);this.blend(t.blendMode),i.use();const o=[{name:"time",value:this.time},{name:"resolution",value:[s,r]}].concat(e.uniforms??[]),l=t.builder.getUniforms();for(let a of l){const n=o.find(f=>f.name===a.name);if(n){const f=typeof n.value=="number"?[n.value]:n.value,u=i.getUniform("uniforms."+a.name);switch(a.type){case"float":this.gl.uniform1f(u,f[0]);break;case"vec2":this.gl.uniform2fv(u,f);break;case"vec3":this.gl.uniform3fv(u,f);break;case"vec4":this.gl.uniform4fv(u,f);break}}}for(let a=0;a<_;a++){const n=e.inputs[a]??e.inputs[0],f=this.framebuffers[T.clamp(n,0,C-1)].texture;this.gl.activeTexture(this.gl.TEXTURE0+a),this.gl.bindTexture(this.gl.TEXTURE_2D,f);const u=i.getUniform(`uChannel${a}`);this.gl.uniform1i(u,a)}this.gl.drawArrays(this.gl.TRIANGLES,0,3);for(let a=0;a<_;a++)this.gl.activeTexture(this.gl.TEXTURE0+a),this.gl.bindTexture(this.gl.TEXTURE_2D,null);e.output!==-1&&this.framebuffers[T.clamp(e.output,0,C-1)].unbind()}render(e,t){if(!this.initialized)throw new Error("Renderer is not initialized");this.resizeRequested&&(this.initFramebuffers(),this.resizeRequested=!1);const i=t.getBounds();this.time=performance.now()*.001;const s=[];for(const r of e.getLayersOrdered()){let o;if(this.layersMap.has(r)||this.layersMap.set(r,new $e(this.gl,this,r.isStatic)),o=this.layersMap.get(r),o.needsUpdate){let l=r.getSpritesOrdered();o.isStatic||(l=l.filter(a=>B(i,a.getBounds()))),o.uploadSprites(r.getSpritesOrdered())}s.push(o)}this.renderLights(e,t),this.renderScene(this.framebuffers[I],this.shaderProgram,t,this.clearColor,s),this.renderFullscreenPass({shader:"light",inputs:[I,y],output:0}),this.renderScene(this.framebuffers[Z],this.maskShaderProgram,t,ie,s);for(let r=0;r<this.pass.length;++r){const o=this.pass[r];this.renderFullscreenPass(o)}for(const[r,o]of this.layersMap)o.lifetime<=0&&(this.layersMap.delete(r),o.destroy())}getTextureInfo(e){const t=this.texturesMap.get(e);if(!t)throw new Error("Texture not found: "+e);return t}getVBO(){return this.vbo}createTexture(e){const t=this.gl,i=t.createTexture();return t.bindTexture(t.TEXTURE_2D,i),t.texImage2D(t.TEXTURE_2D,0,t.RGBA8,t.RGBA,t.UNSIGNED_BYTE,e),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.NEAREST),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,t.NEAREST),i}createTextureArray(e,t){const i=this.gl,s=i.createBuffer();i.bindBuffer(i.PIXEL_UNPACK_BUFFER,s),i.bufferData(i.PIXEL_UNPACK_BUFFER,t,i.STATIC_DRAW),i.pixelStorei(i.UNPACK_ROW_LENGTH,e.imageWidth),i.pixelStorei(i.UNPACK_IMAGE_HEIGHT,e.imageHeight);const r=i.createTexture();i.bindTexture(i.TEXTURE_2D_ARRAY,r),i.texStorage3D(i.TEXTURE_2D_ARRAY,4,i.RGBA8,e.tileWidth,e.tileHeight,e.tileCount);for(let o=0;o<e.tileCount;++o){const l=o%e.columns,a=Math.floor(o/e.columns);i.pixelStorei(i.UNPACK_SKIP_PIXELS,l*e.tileWidth),i.pixelStorei(i.UNPACK_SKIP_ROWS,a*e.tileHeight),i.texSubImage3D(i.TEXTURE_2D_ARRAY,0,0,0,o,e.tileWidth,e.tileHeight,1,i.RGBA,i.UNSIGNED_BYTE,0)}return i.deleteBuffer(s),i.generateMipmap(i.TEXTURE_2D_ARRAY),i.texParameteri(i.TEXTURE_2D_ARRAY,i.TEXTURE_MAG_FILTER,i.NEAREST),i.texParameteri(i.TEXTURE_2D_ARRAY,i.TEXTURE_MIN_FILTER,i.NEAREST),r}}class $e{constructor(e,t,i){this.gl=e,this.renderer=t,this.isStatic=i,this.needsUpdate=!0,this.drawCalls=[],this.lifetime=U,this.vao=e.createVertexArray(),e.bindVertexArray(this.vao),e.bindBuffer(e.ARRAY_BUFFER,t.getVBO()),e.enableVertexAttribArray(0),e.vertexAttribPointer(0,2,e.FLOAT,!1,16,0),e.enableVertexAttribArray(1),e.vertexAttribPointer(1,2,e.FLOAT,!1,16,8),this.instanceBuffer=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.instanceBuffer);const s=b.spriteStride;e.bufferData(e.ARRAY_BUFFER,(this.isStatic?E:Q)*s,this.isStatic?e.STATIC_DRAW:e.DYNAMIC_DRAW);for(let r=2;r<=8;++r)e.enableVertexAttribArray(r),e.vertexAttribDivisor(r,1);e.bindVertexArray(null)}uploadSprites(e){const t=this.gl;t.bindBuffer(t.ARRAY_BUFFER,this.instanceBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,b.createSpritesData(e,!0)),this.isStatic&&(this.needsUpdate=!1),this.drawCalls.length=0;let i=null;for(let s=0;s<e.length;++s){const r=e[s].tileset.name;!i||r!==i.texName?(i={texName:r,offset:s,count:1},this.drawCalls.push(i)):i.count++}}render(e){const t=this.gl;t.bindVertexArray(this.vao);for(const i of this.drawCalls){const s=this.renderer.getTextureInfo(i.texName);t.bindTexture(t.TEXTURE_2D,s.texture),this.gl.uniform2f(e.getUniform("uTilesetDimensions"),s.tileset.imageWidth,s.tileset.imageHeight),t.bindBuffer(t.ARRAY_BUFFER,this.instanceBuffer);const r=b.spriteStride,o=i.offset*r;t.vertexAttribPointer(2,2,t.FLOAT,!1,r,0+o),t.vertexAttribPointer(3,2,t.FLOAT,!1,r,8+o),t.vertexAttribPointer(4,1,t.FLOAT,!1,r,16+o),t.vertexAttribIPointer(5,4,t.UNSIGNED_SHORT,r,20+o),t.vertexAttribPointer(6,4,t.FLOAT,!1,r,28+o),t.vertexAttribPointer(7,4,t.FLOAT,!1,r,44+o),t.vertexAttribPointer(8,2,t.FLOAT,!1,r,60+o),t.drawArraysInstanced(t.TRIANGLE_STRIP,0,4,i.count)}t.bindVertexArray(null),this.lifetime=U}destroy(){this.gl.deleteBuffer(this.instanceBuffer),this.gl.deleteVertexArray(this.vao)}}const He=async()=>{const e=await(await navigator.gpu?.requestAdapter())?.requestDevice();if(!e)return null;const t=navigator.gpu.getPreferredCanvasFormat();return{device:e,format:t}},J=`
fn worldToClip(worldPos: vec2f, cameraPos: vec2f, viewport: vec2f) -> vec4f {
    let pixelPos = worldPos - cameraPos;
    let clipPos = vec2f(pixelPos.x / viewport.x, 1.0 - pixelPos.y / viewport.y) * 2.0 - 1.0;
    return vec4f(clipPos, 0.0, 1.0);
}
`,fe=`
struct VSInput {
    @location(0) vertexPos: vec2f,
    @location(1) texCoord: vec2f,
    
    @location(2) tilePos: vec2f,
    @location(3) tileScale: vec2f,
    @location(4) tileAngle: f32,
    @location(5) tileRegion: vec2u,

    @location(6) tintColor: vec4f,
    @location(7) maskColor: vec4f,

    @location(8) tileOffset: vec2f
}

struct Camera {
    pos: vec2f,
    viewportDimensions: vec2f
}

@group(0) @binding(0)
var<uniform> camera: Camera;

@group(1) @binding(2)
var<uniform> tilesetDimensions: vec2f;

struct VSOutput {
    @builtin(position) pos: vec4f,
    @location(0) uv: vec2f,
    @location(1) tintColor: vec4f,
    @location(2) maskColor: vec4f
}

${J}

@vertex
fn vs_main(input: VSInput) -> VSOutput {
    var out: VSOutput;

    out.tintColor = input.tintColor;
    out.maskColor = input.maskColor;

    let x = f32(input.tileRegion.x & 0xFFFFu);
    let y = f32(input.tileRegion.x >> 16);
    let w = f32(input.tileRegion.y & 0xFFFFu);
    let h = f32(input.tileRegion.y >> 16);

    let tileRegion = vec4f(x, y, w, h);

    let flippedTexCoord = vec2f(input.texCoord.x, 1.0 - input.texCoord.y);
    out.uv = (tileRegion.xy + flippedTexCoord * tileRegion.zw) / tilesetDimensions;

    let c = cos(input.tileAngle);
    let s = sin(input.tileAngle);
    let offsetPos = (input.vertexPos * abs(input.tileScale) + input.tileOffset) * sign(input.tileScale);
    let rotatedPos = vec2f(
        offsetPos.x * c - offsetPos.y * s,
        offsetPos.x * s + offsetPos.y * c
    );
    let worldPos = rotatedPos + input.tilePos;

    out.pos = worldToClip(worldPos, camera.pos, camera.viewportDimensions);
    return out;
}`,We=`

@group(1) @binding(0)
var spriteSampler: sampler;

@group(1) @binding(1)
var spriteTexture: texture_2d<f32>;

@fragment
fn fs_main(input: VSOutput) -> @location(0) vec4f {
    return textureSample(spriteTexture, spriteSampler, input.uv) * input.tintColor;
}
`,qe=`
@group(1) @binding(0)
var spriteSampler: sampler;

@group(1) @binding(1)
var spriteTexture: texture_2d<f32>;

@fragment
fn fs_main(input: VSOutput) -> @location(0) vec4f {
    let texColor: vec4f = textureSample(spriteTexture, spriteSampler, input.uv);
    return vec4f(input.maskColor.xyz, texColor.w * input.maskColor.a);
}
`,je=fe+We,Ke=fe+qe,Je=`
struct VSInput {
    @location(0) pos: vec2f
}

struct VSOutput {
    @builtin(position) pos: vec4f,
    @location(0) worldPos: vec2f
}

struct Camera {
    pos: vec2f,
    viewportDimensions: vec2f
}

struct Light {
    center: vec2f,
    radius: f32,
    color: vec3f,
    intensity: f32,
    direction: vec2f,
    cutoff: f32
}

@group(0) @binding(0)
var<uniform> camera: Camera;

@group(1) @binding(0)
var<uniform> light: Light;

${J}

@vertex
fn vs_main(input: VSInput) -> VSOutput {
    var out: VSOutput;

    out.worldPos = light.center + (input.pos - 0.5) * 2.0 * light.radius;

    out.pos = worldToClip(out.worldPos, camera.pos, camera.viewportDimensions);
    return out;
}

@fragment
fn fs_main(input: VSOutput) -> @location(0) vec4f {
    let toPixel = input.worldPos - light.center;
    let dist = length(toPixel);

    let attenuation = clamp(1.0 - pow(dist / light.radius, 2.0), 0.0, 1.0);

    var spotFactor = 1.0;
    if (light.cutoff > 0.0) {
        let cosAngle = dot(normalize(toPixel), normalize(light.direction));
        spotFactor = clamp((cosAngle - light.cutoff) / (1.0 - light.cutoff), 0.0, 1.0);
    }

    return vec4f(light.color * light.intensity * attenuation * spotFactor, 1.0);
}
`,Qe=`
struct VSInput {
    @location(0) pos: vec2f
}

struct VSOutput {
    @builtin(position) pos: vec4f
}

struct Camera {
    pos: vec2f,
    viewportDimensions: vec2f
}

@group(0) @binding(0)
var<uniform> camera: Camera;

${J}

@vertex
fn vs_main(input: VSInput) -> VSOutput {
    var out: VSOutput;

    out.pos = worldToClip(input.pos, camera.pos, camera.viewportDimensions);
    return out;
}

@fragment
fn fs_main(input: VSOutput) -> @location(0) vec4f {
    return vec4f(0.0, 0.0, 0.0, 1.0);
}
`,Ze=h=>`

struct VSOutput {
    @builtin(position) pos: vec4f,
    @location(0) uv: vec2f
}

@vertex
fn vs_main(@builtin(vertex_index) vertexIndex: u32) -> VSOutput {
    var out: VSOutput;

    let x = f32((vertexIndex & 1) << 2);
    let y = f32((vertexIndex & 2) << 1);

    out.uv = vec2f(x, 2.0 - y) / 2.0;
    out.pos = vec4f(x - 1.0, y - 1.0, 0.0, 1.0);
    return out;
}

struct Uniforms {
${h.uniforms.map(e=>"    "+e).join(`,
`)}
}

@group(0) @binding(0)
var<uniform> uniforms: Uniforms;

@group(1) @binding(0)
var defaultSampler: sampler;

@group(1) @binding(1)
var channel0: texture_2d<f32>;

@group(1) @binding(2)
var channel1: texture_2d<f32>;

@group(1) @binding(3)
var channel2: texture_2d<f32>;

@group(1) @binding(4)
var channel3: texture_2d<f32>;

@group(1) @binding(5)
var channel4: texture_2d<f32>;

@group(1) @binding(6)
var channel5: texture_2d<f32>;

@group(1) @binding(7)
var channel6: texture_2d<f32>;

@group(1) @binding(8)
var channel7: texture_2d<f32>;

fn texture(ch: i32, uv: vec2f) -> vec4f {
    let scaledUV = uv;

    switch (ch) {
        case 1:  { return textureSample(channel1, defaultSampler, scaledUV); }
        case 2:  { return textureSample(channel2, defaultSampler, scaledUV); }
        case 3:  { return textureSample(channel3, defaultSampler, scaledUV); }
        case 4:  { return textureSample(channel4, defaultSampler, scaledUV); }
        case 5:  { return textureSample(channel5, defaultSampler, scaledUV); }
        case 6:  { return textureSample(channel6, defaultSampler, scaledUV); }
        case 7:  { return textureSample(channel7, defaultSampler, scaledUV); }
        default: { return textureSample(channel0, defaultSampler, scaledUV); }
    }
}

${h.functions.join(`

`)}

@fragment
fn fs_main(input: VSOutput) -> @location(0) vec4f {
    let fragCoord = input.uv * uniforms.resolution;
    return mainImage(fragCoord);
}
`,et={componentMap:{r:"x",g:"y",b:"z",a:"w"},replaceType(h){return`${h==="float"?"f32":h+"<f32>"}`},declareFn(h,e,...t){return`fn ${h}(${t.map(i=>`${i[0]}: ${this.replaceType(i[1])}`).join(", ")}) ${e!==null?"-> "+this.replaceType(e):""}`},declareVar(h,e,t=!1){const i=`${h}: ${this.replaceType(e)}`;return t?i:`var ${i};`}};class tt{constructor(e){this.shaderMap=new Map,this.layersMap=new Map,this.texturesMap=new Map,this.canvas=e,this.clearColor=new w(0,0,0,0),this.shaderMap=new Map,this.initialized=!1,this.pass=[ee],this.offscreenTextures=[],this.time=0,this.shaderCache=new Map,this.renderPassUniformMap=new Map,this.fullscreenPassStages={mainLight:{shader:"light",inputs:[I,y],output:0},lightBlurHorizontal:{shader:"blurHorizontal",inputs:[y+1],output:4},lightBlurVertical:{shader:"blurVertical",inputs:[4],output:5},lightAdditive:{shader:"default_additive",inputs:[5],output:y}},this.resizeRequested=!1}getType(){return"webgpu"}getBuilderOptions(){return et}addTextures(e,t){for(const i of e)t[i.name]&&this.texturesMap.set(i.name,{tileset:i,image:t[i.name]})}registerShader(e,t,i="none"){this.shaderMap.set(e,{builder:t,blendMode:i})}setClearColor(e){this.clearColor.copy(e)}setSize(e,t){this.canvas.width=e,this.canvas.height=t,this.initialized&&(this.resizeRequested=!0)}getCanvas(){return this.canvas}initOffscreenTextures(){for(let e=0;e<C;++e){this.offscreenTextures[e]?.destroy();const t=te(e);this.offscreenTextures[e]=this.cfg.device.createTexture({size:{width:this.canvas.width*t,height:this.canvas.height*t,depthOrArrayLayers:1},format:this.cfg.format,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING,label:"offscreen texture "+e})}for(let[e,t]of this.renderPassUniformMap)t.textureBindGroup=this.renderPassCreateTextureBindGroup(e)}getBlendOptions(e){switch(e){case"alpha":return{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha",operation:"add"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"}};case"additive":return{color:{srcFactor:"one",dstFactor:"one",operation:"add"},alpha:{srcFactor:"zero",dstFactor:"one",operation:"add"}};default:return}}async init(){const e=await He();if(!e)throw new Error("WebGPU not supported");this.cfg=e;const t=this.cfg.device,i=this.canvas.getContext("webgpu");this.ctx=i,this.ctx.configure(this.cfg);for(const a of this.texturesMap.values())a.tileset&&(a.texture=this.createTexture(a.tileset,a.image));this.initOffscreenTextures(),this.sampler=t.createSampler({magFilter:"nearest",minFilter:"nearest",addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge"}),this.fullscreenSampler=t.createSampler({magFilter:"linear",minFilter:"linear",addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge"}),this.registerShader("default",F),this.registerShader("default_additive",F,"additive"),this.registerShader("light",H),this.registerShader("blurHorizontal",W),this.registerShader("blurVertical",q);for(const[a,n]of this.shaderMap.entries()){if(!this.shaderCache.has(n.builder)){const d=Ze(n.builder.build(this)),m=t.createShaderModule({label:a+" shader module",code:d});this.shaderCache.set(n.builder,m)}const f=this.shaderCache.get(n.builder),u=t.createRenderPipeline({layout:"auto",vertex:{module:f,entryPoint:"vs_main"},fragment:{module:f,entryPoint:"fs_main",targets:[{format:this.cfg.format,blend:this.getBlendOptions(n.blendMode)}]},primitive:{topology:"triangle-strip"}});n.pipeline=u}this.commonBGL=this.cfg.device.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.FRAGMENT,sampler:{}},{binding:1,visibility:GPUShaderStage.FRAGMENT,texture:{}},{binding:2,visibility:GPUShaderStage.VERTEX,buffer:{type:"uniform"}}]}),this.cameraBGL=this.cfg.device.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.VERTEX,buffer:{type:"uniform"}}]}),this.lightBGL=this.cfg.device.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,buffer:{type:"uniform",hasDynamicOffset:!0}}]}),this.pipeline=this.createMainPipeline(je),this.maskPipeline=this.createMainPipeline(Ke),this.lightUniformBuffer=this.cfg.device.createBuffer({label:"Light uniform buffer",size:N*256,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});const s=this.cfg.device.createPipelineLayout({bindGroupLayouts:[this.cameraBGL,this.lightBGL]}),r=this.cfg.device.createShaderModule({code:Je});this.lightPipeline=this.cfg.device.createRenderPipeline({label:"Light pipeline",layout:s,vertex:{module:r,entryPoint:"vs_main",buffers:[{arrayStride:16,attributes:[{shaderLocation:0,offset:0,format:"float32x2"}]}]},fragment:{module:r,entryPoint:"fs_main",targets:[{format:this.cfg.format}]},primitive:{topology:"triangle-strip"}}),this.lightUniformBindGroup=this.cfg.device.createBindGroup({label:"Light uniform bind group",layout:this.lightPipeline.getBindGroupLayout(1),entries:[{binding:0,resource:{buffer:this.lightUniformBuffer,size:b.lightStride}}]});const o=this.cfg.device.createPipelineLayout({bindGroupLayouts:[this.cameraBGL]}),l=this.cfg.device.createShaderModule({code:Qe});this.shadowPipeline=this.cfg.device.createRenderPipeline({label:"Shadow pipeline",layout:o,vertex:{module:l,entryPoint:"vs_main",buffers:[{arrayStride:8,attributes:[{shaderLocation:0,offset:0,format:"float32x2"}]}]},fragment:{module:l,entryPoint:"fs_main",targets:[{format:this.cfg.format}]}}),this.cameraBuffer=t.createBuffer({size:16,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),this.cameraBindGroup=t.createBindGroup({label:"Camera bind group",layout:this.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:this.cameraBuffer}}]}),this.vbo=t.createBuffer({size:b.quad.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST}),t.queue.writeBuffer(this.vbo,0,b.quad),this.shadowsVbo=this.cfg.device.createBuffer({size:N*L*8,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST}),this.initialized=!0}createMainPipeline(e){const t=this.cfg.device.createShaderModule({code:e}),i=this.cfg.device.createPipelineLayout({bindGroupLayouts:[this.cameraBGL,this.commonBGL]});return this.cfg.device.createRenderPipeline({layout:i,vertex:{module:t,entryPoint:"vs_main",buffers:[{arrayStride:16,stepMode:"vertex",attributes:[{shaderLocation:0,offset:0,format:"float32x2"},{shaderLocation:1,offset:8,format:"float32x2"}]},{arrayStride:b.spriteStride,stepMode:"instance",attributes:[{shaderLocation:2,offset:0,format:"float32x2"},{shaderLocation:3,offset:8,format:"float32x2"},{shaderLocation:4,offset:16,format:"float32"},{shaderLocation:5,offset:20,format:"uint32x2"},{shaderLocation:6,offset:28,format:"float32x4"},{shaderLocation:7,offset:44,format:"float32x4"},{shaderLocation:8,offset:60,format:"float32x2"}]}]},fragment:{module:t,entryPoint:"fs_main",targets:[{format:this.cfg.format,blend:this.getBlendOptions("alpha")}]},primitive:{topology:"triangle-strip"}})}renderScene(e,t,i,s,r){const o=e.beginRenderPass({colorAttachments:[{clearValue:s||void 0,view:i.createView(),loadOp:s?"clear":"load",storeOp:"store"}]});o.setPipeline(t),o.setBindGroup(0,this.cameraBindGroup),o.setVertexBuffer(0,this.vbo);for(const l of r)l.render(o);o.end()}renderLights(e,t,i){const s=i.getBounds(),r=t.getLights().filter(m=>B(s,m.getBounds())),o=new Float32Array(r.length*L*2),l=[];let a=0;for(let m of r){const c=t.getColliders(m.getBounds()),g=b.createShadowsGeometry(o,m,c,a);l.push({count:(g-a)/2,offset:a/2}),a=g}this.cfg.device.queue.writeBuffer(this.shadowsVbo,0,o,0,a);const n=new w(t.ambientColor.r*t.ambientIntensity,t.ambientColor.g*t.ambientIntensity,t.ambientColor.b*t.ambientIntensity,1);e.beginRenderPass({colorAttachments:[{view:this.offscreenTextures[y].createView(),clearValue:n,loadOp:"clear",storeOp:"store"}]}).end();const u=b.createLightsGeometry(r,!0);this.cfg.device.queue.writeBuffer(this.lightUniformBuffer,0,u);const d=this.offscreenTextures[y+1].createView();for(let m=0;m<r.length;++m){const c=e.beginRenderPass({colorAttachments:[{view:d,clearValue:new w(0,0,0,1),loadOp:"clear",storeOp:"store"}]});c.setPipeline(this.lightPipeline),c.setVertexBuffer(0,this.vbo),c.setBindGroup(0,this.cameraBindGroup),c.setBindGroup(1,this.lightUniformBindGroup,[m*256]),c.draw(4);const g=l[m];g.count!==0&&(c.setPipeline(this.shadowPipeline),c.setVertexBuffer(0,this.shadowsVbo),c.setBindGroup(0,this.cameraBindGroup),c.draw(g.count,1,g.offset)),c.end(),this.renderFullscreenPass(e,this.fullscreenPassStages.lightBlurHorizontal),this.renderFullscreenPass(e,this.fullscreenPassStages.lightBlurVertical),this.renderFullscreenPass(e,this.fullscreenPassStages.lightAdditive)}}renderPassCreateTextureBindGroup(e){const t=this.shaderMap.get(e.shader);if(!t)throw new Error("Unknown shader "+e.shader);const i=[{binding:0,resource:this.fullscreenSampler}];for(let r=0;r<_;r++){const o=e.inputs[r]??e.inputs[0],l=this.offscreenTextures[T.clamp(o,0,C-1)];i.push({binding:r+1,resource:l.createView()})}return this.cfg.device.createBindGroup({label:e.shader+" texture bind group",layout:t.pipeline.getBindGroupLayout(1),entries:i})}renderFullscreenPass(e,t){const i=this.shaderMap.get(t.shader);if(!i)throw new Error("Unknown shader "+t.shader);const s=t.output===-1?this.ctx.getCurrentTexture():this.offscreenTextures[T.clamp(t.output,0,C-1)],r=i.builder.getUniforms(),o=[{name:"time",value:this.time},{name:"resolution",value:[s.width,s.height]}].concat(t.uniforms??[]),l=new Float32Array(st);for(let f of r){const u=o.find(d=>d.name===f.name);if(u){const d=typeof u.value=="number"?[u.value]:u.value;l.set(d,f.offset)}}if(!this.renderPassUniformMap.has(t)){const f=this.cfg.device.createBuffer({size:256,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),u=this.cfg.device.createBindGroup({layout:i.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:f}}]}),d=this.renderPassCreateTextureBindGroup(t);this.renderPassUniformMap.set(t,{ubo:f,uniformBindGroup:u,textureBindGroup:d})}const a=this.renderPassUniformMap.get(t);this.cfg.device.queue.writeBuffer(a.ubo,0,l);const n=e.beginRenderPass({colorAttachments:[{view:s.createView(),loadOp:t.clearColor?"clear":"load",clearValue:t.clearColor,storeOp:"store"}]});n.setPipeline(i.pipeline),n.setBindGroup(0,a.uniformBindGroup),n.setBindGroup(1,a.textureBindGroup),n.draw(3),n.end()}render(e,t){if(!this.initialized)throw new Error("Renderer is not initialized");this.resizeRequested&&(this.initOffscreenTextures(),this.resizeRequested=!1);const i=t.getBounds();this.time=performance.now()*.001;const s=[];for(const l of e.getLayersOrdered()){if(!this.layersMap.has(l)){const n=new it(this,l.isStatic);this.layersMap.set(l,n)}const a=this.layersMap.get(l);if(a.needsUpdate){let n=l.getSpritesOrdered();a.isStatic||(n=n.filter(f=>B(i,f.getBounds()))),a.uploadSprites(n)}s.push(a)}this.cfg.device.queue.writeBuffer(this.cameraBuffer,0,new Float32Array([t.position.x,t.position.y,t.vw,t.vh]));const r=this.cfg.device.createCommandEncoder();this.renderLights(r,e,t),this.renderScene(r,this.pipeline,this.offscreenTextures[I],this.clearColor,s),this.renderFullscreenPass(r,this.fullscreenPassStages.mainLight),this.renderScene(r,this.maskPipeline,this.offscreenTextures[Z],ie,s);for(let l=0;l<this.pass.length;++l){const a=this.pass[l];this.renderFullscreenPass(r,a)}const o=r.finish();this.cfg.device.queue.submit([o]);for(const[l,a]of this.layersMap)a.lifetime<=0&&(a.destroy(),this.layersMap.delete(l))}createTexture(e,t){const i=this.cfg.device.createTexture({size:{width:e.imageWidth,height:e.imageHeight,depthOrArrayLayers:1},format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT});return this.cfg.device.queue.copyExternalImageToTexture,this.cfg.device.queue.copyExternalImageToTexture({source:t},{texture:i},[e.imageWidth,e.imageHeight,1]),i}createTextureArray(e,t){const i=e.tileWidth,s=e.tileHeight,r=this.cfg.device.createTexture({size:{width:i,height:s,depthOrArrayLayers:e.tileCount},format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT});for(let o=0;o<e.tileCount;++o){const l=Math.floor(o/e.columns),a=o%e.columns,n=new Uint8Array(i*s*4);for(let f=0;f<s;++f){const u=((l*s+f)*e.columns+a)*i*4,d=u+i*4;n.set(t.slice(u,d),f*i*4)}this.cfg.device.queue.writeTexture({texture:r,origin:{x:0,y:0,z:o}},n,{bytesPerRow:i*4,rowsPerImage:s},{width:i,height:s,depthOrArrayLayers:1})}return r}getConfig(){return this.cfg}getTextureInfo(e){const t=this.texturesMap.get(e);if(!t)throw new Error("Texture not found: "+e);return t}getPipeline(){return this.pipeline}getSampler(){return this.sampler}}class it{constructor(e,t){this.renderer=e,this.isStatic=t,this.needsUpdate=!0,this.drawCalls=[],this.bindGroups=new Map,this.lifetime=U,this.lastTexIdx=0,this.instanceBuffer=e.getConfig().device.createBuffer({label:"Instance Buffer",size:b.spriteStride*(t?E:Q),usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST}),this.tilesetDimBuffer=e.getConfig().device.createBuffer({label:"Tileset Dimensions Buffer",size:rt*256,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST})}uploadSprites(e){const t=this.renderer.getConfig().device,i=this.renderer.getPipeline(),s=this.renderer.getSampler();t.queue.writeBuffer(this.instanceBuffer,0,b.createSpritesData(e,!0)),this.isStatic&&(this.needsUpdate=!1),this.drawCalls.length=0;let r=null;for(let o=0;o<e.length;++o){const l=e[o].tileset.name;if(!r||l!==r.texName){const a=this.renderer.getTextureInfo(l);t.queue.writeBuffer(this.tilesetDimBuffer,this.lastTexIdx*256,new Float32Array([a.tileset.imageWidth,a.tileset.imageHeight]));const n=t.createBindGroup({layout:i.getBindGroupLayout(1),entries:[{binding:0,resource:s},{binding:1,resource:a.texture.createView()},{binding:2,resource:{buffer:this.tilesetDimBuffer,offset:this.lastTexIdx*256,size:8}}]});r={texName:l,instanceOffset:o,instanceCount:1},this.bindGroups.has(r.texName)||(this.bindGroups.set(r.texName,n),++this.lastTexIdx),this.drawCalls.push(r)}else r.instanceCount++}}render(e){e.setVertexBuffer(1,this.instanceBuffer);for(const t of this.drawCalls)e.setBindGroup(1,this.bindGroups.get(t.texName)),e.draw(4,t.instanceCount,0,t.instanceOffset);this.lifetime=U}destroy(){this.instanceBuffer.destroy(),this.tilesetDimBuffer.destroy()}}const E=1e5,Q=5e4,U=30,rt=16,C=12,_=8,st=64,N=1e3,L=768,I=3,Z=1,y=1,ee={shader:"default",inputs:[0],output:-1},te=h=>1/(1<<Math.max(0,Math.floor((h-2)*.5))),ie=new w(0,0,0,1),ot=h=>{const e=document.createElement("canvas");switch(h){case"webgl":return new Le(e);case"webgl2":return new Ye(e);case"webgpu":return new tt(e);default:throw new Error("Unknown renderer type")}};class nt{constructor(e){this.prev=null,this.next=null,this.value=e}}class at{constructor(){this.head=null}insert(e){const t=new nt(e);return t.next=this.head,this.head=t,t}remove(e){e.next&&(e.next.prev=e.prev),e.prev&&(e.prev.next=e.next),this.head===e&&(this.head=e.next),e.prev=null,e.next=null}[Symbol.iterator](){let e=this.head;return{next(){if(e){const t=e.value;return e=e.next,{value:t,done:!1}}return{value:void 0,done:!0}}}}}class lt{constructor(e,t){this.bounds=t,this.parent=e,this.queryId=0}}const X=class X{constructor(e){this.bounds=e.bounds,this.dimensions=e.dimensions,this.cells=this.cells=Array.from({length:e.dimensions[1]},()=>Array.from({length:e.dimensions[0]},()=>new at))}findNearby(e){const t=++X.queryIds,i=this.getCellIndices(e.min),s=this.getCellIndices(e.max),r=[];for(let o=i[1];o<=s[1];++o)for(let l=i[0];l<=s[0];++l)for(let a of this.cells[o][l])a.queryId!==t&&(a.queryId=t,r.push(a));return r}createClient(e,t){const i=new lt(e,t);return this.insert(i),i}updateClient(e){const t=this.getCellIndices(e.bounds.min),i=this.getCellIndices(e.bounds.max);t[0]===e.cells.min[0]&&t[1]===e.cells.min[1]&&i[0]===e.cells.max[0]&&i[1]===e.cells.max[1]||(this.removeClient(e),this.insert(e))}removeClient(e){for(let t=e.cells.min[1];t<=e.cells.max[1];++t)for(let i=e.cells.min[0];i<=e.cells.max[0];++i)this.cells[t][i].remove(e.cells.nodes[t-e.cells.min[1]][i-e.cells.min[0]])}insert(e){const t=this.getCellIndices(e.bounds.min),i=this.getCellIndices(e.bounds.max),s=[];for(let r=t[1];r<=i[1];++r){s.push([]);for(let o=t[0];o<=i[0];++o){const l=this.cells[r][o].insert(e);s[r-t[1]].push(l)}}e.cells={min:t,max:i,nodes:s}}getCellIndices(e){const t=T.clamp(Math.floor((e.x-this.bounds.min.x)/(this.bounds.max.x-this.bounds.min.x)*this.dimensions[0]),0,this.dimensions[0]-1),i=T.clamp(Math.floor((e.y-this.bounds.min.y)/(this.bounds.max.y-this.bounds.min.y)*this.dimensions[1]),0,this.dimensions[1]-1);return[t,i]}};X.queryIds=0;let re=X;class de{constructor(e){this.zIndex=e.zIndex||0,this.tileset=e.tileset,this.tilesetRegion=e.tilesetRegion||{x:0,y:0},this.isStatic=e.isStatic||!1,this.position=new x,this.offset=new x,this.scale=new x(this.tileset.tileWidth*(this.tilesetRegion.width||1),this.tileset.tileHeight*(this.tilesetRegion.height||1)),this.angle=0,this.tintColor=new w(1,1,1,1),this.maskColor=new w(0,0,0,1)}setTilesetRegion(e,t,i=1,s=1){this.tilesetRegion.x=e,this.tilesetRegion.y=t,this.tilesetRegion.width=i,this.tilesetRegion.height=s}getTile(){return this.tileset.getTile(this.tilesetRegion.x,this.tilesetRegion.y)}getBounds(){const e=Math.max(Math.abs(this.scale.x),Math.abs(this.scale.y)),t=new x(e,e),i=this.position.clone().add(this.offset).sub(t),s=i.clone().add(t).add(t);return{min:i,max:s}}}class ht{constructor(e={}){this.layers=[],this.ambientIntensity=e.ambientIntensity||1,this.ambientColor=e.ambientColor||new w(1,1,1),this.lights=[],this.colliders=[],this.collidersHashGrid=new re(e.collidersHashGrid||{bounds:{min:new x(-1e3,-1e3),max:new x(1e3,1e3)},dimensions:[20,20]})}findLayerBySprite(e){return this.layers.find(t=>t.isStatic===e.isStatic&&t.zIndex===e.zIndex)}addLight(e){this.lights.push(e)}removeLight(e){const t=this.lights.indexOf(e);t!==-1&&this.lights.splice(t,1)}addSprite(e){let t;return t=this.findLayerBySprite(e),t||(t=this.createLayer({zIndex:e.zIndex,isStatic:e.isStatic})),t.add(e),e}removeSprite(e){const t=this.findLayerBySprite(e);t&&t.remove(e)}addTilemap(e,t={}){const i=e.getLayers(),s=t.tileWidth||e.tileWidth,r=t.tileHeight||e.tileHeight;let o=0;const l=[],a=[];for(const n of i){const f=t.layers?.find(u=>u.name===n.name);switch(f?.zIndex&&(o=f.zIndex),n.renderOrder!=="manual"&&this.createLayer({zIndex:o,renderOrder:n.renderOrder,isStatic:!1}),n.type){case"tilelayer":{for(let u=0;u<n.height;++u)for(let d=0;d<n.width;++d){const m=n.getTile(d,u);if(!m)continue;const c=new de({isStatic:m.animation===void 0,zIndex:o,tileset:m.tileset,tilesetRegion:{x:m.x,y:m.y}});if(c.position.set((d+n.x)*s,(u+n.y)*r),c.scale.set(s,r),l.push(this.addSprite(c)),m.animation){const g=new S(c);g.play({x:m.x,y:m.y},{repeat:!0}),a.push(g)}}break}case"objectgroup":{if(t.onObject){const u=n.getObjects();for(const d of u){const m=d.x*s/e.tileWidth,c=d.y*r/e.tileHeight,g=d.width*s/e.tileWidth,p=d.height*r/e.tileHeight;t.onObject(d,m,c,g,p,o,this,n)}}break}}++o}return{sprites:l,animators:a}}createLayer(e){const t=new ut(e);return this.layers.push(t),t}getLayersOrdered(){return this.layers.sort((e,t)=>e.zIndex-t.zIndex)}getLights(){return this.lights}addCollider(e){return this.colliders.push({collider:e,hashGridClient:this.collidersHashGrid.createClient(e,e.getBounds())}),e}removeCollider(e){const t=this.colliders.findIndex(i=>i.collider===e);t!==-1&&(this.collidersHashGrid.removeClient(this.colliders[t].hashGridClient),this.colliders.splice(t,1))}getColliders(e){return this.colliders.map(t=>t.collider)}update(){for(let e of this.colliders)e.collider.isStatic||(e.hashGridClient.bounds=e.collider.getBounds(),this.collidersHashGrid.updateClient(e.hashGridClient))}getInfo(){const e=this.layers.reduce((i,s)=>i+s.sprites.length,0),t=this.layers.reduce((i,s)=>i+s.sprites.filter(r=>r.isStatic).length,0);return{lights:this.lights.length,colliders:this.colliders.length,sprites:e,staticSprites:t,dynamicSprites:e-t,layers:this.layers.length}}}class ut{constructor(e){this.zIndex=e.zIndex,this.isStatic=e.isStatic,this.renderOrder=e.renderOrder||"manual",this.sprites=[]}add(e){if(this.renderOrder==="manual"){let t=-1;for(let i=this.sprites.length-1;i>=0;--i)if(this.sprites[i].tileset.name<=e.tileset.name){t=i;break}t===-1?this.sprites.unshift(e):this.sprites.splice(t+1,0,e)}else this.sprites.push(e)}remove(e){const t=this.sprites.indexOf(e);t!==-1&&this.sprites.splice(t,1)}getSpritesOrdered(){switch(this.renderOrder){case"topdown":return this.sprites.sort((e,t)=>e.position.y-t.position.y);default:return this.sprites}}}class ge{constructor(e,t,i,s,r){this.tileset=e,this.id=t,this.x=i,this.y=s,this.properties=r?.properties,this.animation=r?.animation}getProperty(e){return this.properties?.find(t=>t.name===e)?.value}}const G=class G{constructor(e){if(this.name=e.name,this.imageWidth=e.imagewidth,this.imageHeight=e.imageheight,this.tileWidth=e.tilewidth,this.tileHeight=e.tileheight,this.columns=e.columns,this.tileCount=e.tilecount,this.margin=e.margin||0,this.spacing=e.spacing||0,this.tiledata=new Map,e.tiles)for(let t of e.tiles)this.tiledata.set(t.id,t)}static async load(e){if(!this.cache.has(e)){const t=await $.loadJson(e);this.cache.set(e,new G(t))}return this.cache.get(e)}static fromImage(e,t){const i=t.width,s=t.height;return new G({tilewidth:i,tileheight:s,imagewidth:i,imageheight:s,tilecount:1,columns:1,name:e})}getTile(e,t){if(e<0||e>=this.columns||t<0||t>=Math.ceil(this.tileCount/this.columns))return null;const i=t*this.columns+e,s=this.tiledata.get(i);return new ge(this,i,e,t,s)}getTileById(e){if(e>=this.tileCount||e<0)return null;const t=e%this.columns,i=Math.floor(e/this.columns),s=this.tiledata.get(e);return new ge(this,e,t,i,s)}getTileXY(e){const t=e%this.columns,i=Math.floor(e/this.columns);return{x:t,y:i}}};G.cache=new Map;let M=G;class me{constructor(e){this.name=e.name,this.x=e.x,this.y=e.y,this.width=e.width,this.height=e.height,this.type=e.type,this.renderOrder=e.draworder||"manual"}}class ct extends me{constructor(e){super(e),this.data=e.data}getTile(e,t){const i=this.data[t*this.width+e];return i-1==-1?null:this.tilemap.getTileById(i)}}class ft{constructor(e){this.name=e.name,this.type=e.type,this.x=e.x,this.y=e.y,this.width=e.width||0,this.height=e.height||0,this.rotation=T.degToRad(e.rotation||0),this.properties=e.properties}getProperty(e){return this.properties?.find(t=>t.name===e)?.value}}class dt extends me{constructor(e){super(e),this.objects=e.objects}getObjects(){return this.objects.map(e=>new ft(e))}}class se{constructor(e,t,i,s){this.width=e,this.height=t,this.tileWidth=i,this.tileHeight=s,this.tilesets=[],this.layers=[]}static async load(e,t){const i=await $.loadJson(e),s=new se(i.width,i.height,i.tilewidth,i.tileheight);for(const r of i.layers)switch(r.type){case"tilelayer":s.addLayer(new ct(r));break;case"objectgroup":s.addLayer(new dt(r));break}for(let r of i.tilesets){let o;if(r.source){const l=r.source.split(/(\/|\\\/)/),a=l[l.length-1].split(".tsj")[0];if(!t[a])throw new Error("Source is missing for tileset: "+a);o=await M.load(t[a])}else o=new M(r);s.tilesets.push({tileset:o,firstGlobalId:r.firstgid})}return s}addLayer(e){e.tilemap=this,this.layers.push(e)}getTilesets(){return this.tilesets.map(e=>e.tileset)}getTilesetByName(e){const t=this.tilesets.find(i=>i.tileset.name===e);if(!t)throw new Error(`Tilemap doesn't include tileset "`+e+'"');return t.tileset}getLayers(){return this.layers}getLayerByName(e){return this.layers.find(t=>t.name===e)||null}getTileById(e){const t=this.tilesets;for(let i of t){let s=i.tileset.getTileById(e-i.firstGlobalId);if(s)return s}return null}}v.Animator=S,v.Camera=xe,v.Color=w,v.Light=Te,v.Scene=ht,v.ShaderBuilder=P,v.Sprite=de,v.Tilemap=se,v.Tileset=M,v.Vector=x,v.assets=$,v.colliders=ye,v.createRenderer=ot,v.math=T,v.matrix=we,Object.defineProperty(v,Symbol.toStringTag,{value:"Module"})}));
