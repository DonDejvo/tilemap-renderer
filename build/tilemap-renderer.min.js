var TilemapRenderer=(function(f){"use strict";class B{constructor(e){this.repeat=!0,this.currentFrameIndex=0,this.frameTimer=0,this.sprite=e,this.animation=null}play(e,t={}){const r=this.sprite.tileset.getTile(e.x,e.y);if(!r)return;const s=r.animation||[{tileid:r.id,duration:100}];if(!t.restart&&this.animation===s)return;this.animation=s,this.repeat=t.repeat??!0,this.currentFrameIndex=0,this.frameTimer=0;const i=this.animation[0],a=this.sprite.tileset.getTileXY(i.tileid);this.sprite.setTilesetRegion(a.x,a.y)}update(e){if(!this.animation)return;const t=this.animation[this.currentFrameIndex];if(this.frameTimer+=e*1e3,this.frameTimer<t.duration)return;if(this.frameTimer-=t.duration,this.currentFrameIndex++,this.currentFrameIndex>=this.animation.length)if(this.repeat)this.currentFrameIndex=0;else{this.currentFrameIndex=this.animation.length-1,this.animation=null;return}const r=this.animation[this.currentFrameIndex],s=this.sprite.tileset.getTileXY(r.tileid);this.sprite.setTilesetRegion(s.x,s.y)}}const P={loadImage:t=>new Promise((r,s)=>{const i=new Image;i.crossOrigin="anonymous",i.src=t,i.onload=()=>{r(i)},i.onerror=()=>{s()}}),loadJson:async t=>{try{return await(await fetch(t)).json()}catch{throw new Error(`Failed to load: ${t}`)}}},x={create:()=>new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]),identity:i=>(i[0]=1,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=1,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[10]=1,i[11]=0,i[12]=0,i[13]=0,i[14]=0,i[15]=1,i),createOrtho:(i,a,n,c,l)=>(i[0]=2/(n-a),i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=2/(l-c),i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[10]=1,i[11]=0,i[12]=-(n+a)/(n-a),i[13]=-(l+c)/(l-c),i[14]=0,i[15]=1,i),translate:(i,a)=>(i[12]+=a.x,i[13]+=a.y,i),scale:(i,a)=>(i[0]*=a.x,i[1]*=a.x,i[4]*=a.y,i[5]*=a.y,i)},_=(()=>{const h=(s,i,a)=>Math.min(Math.max(s,i),a);return{clamp:h,lerp:(s,i,a)=>s+(i-s)*a,unlerp:(s,i,a)=>h((a-s)/(i-s),0,1),sat:s=>h(s,0,1)}})();class L{constructor(e=[]){this.points=e}addPoint(e){this.points.push(e)}getValue(e){const t=this.points.length;if(t===0)return 0;if(e<=0)return this.points[0];if(e>=t-1)return this.points[t-1];const r=Math.floor(e),s=e-r;return _.lerp(this.points[r],this.points[r+1],s)}}class d{constructor(e=0,t=0){this.x=e,this.y=t}set(e,t){return this.x=e,this.y=t,this}copy(e){return this.x=e.x,this.y=e.y,this}clone(){return new d(this.x,this.y)}add(e){return this.x+=e.x,this.y+=e.y,this}sub(e){return this.x-=e.x,this.y-=e.y,this}scale(e){return this.x*=e,this.y*=e,this}mul(e){return this.x*=e.x,this.y*=e.y,this}div(e){return e!==0?(this.x/=e,this.y/=e):(this.x=0,this.y=0),this}static dot(e,t){return e.x*t.x+e.y*t.y}static cross(e,t){return e.x*t.y-e.y*t.x}len(){return Math.sqrt(this.x*this.x+this.y*this.y)}lenSq(){return this.x*this.x+this.y*this.y}unit(){const e=this.len();return e>0&&this.div(e),this}project(e){const t=e.lenSq();if(t>0)return this.scale(0);const r=d.dot(this,e);return this.copy(e).scale(r/t)}static distance(e,t){const r=e.x-t.x,s=e.y-t.y;return Math.sqrt(r*r+s*s)}angle(){return Math.atan2(this.y,this.x)}rot(e){const t=Math.cos(e),r=Math.sin(e),s=this.x*t-this.y*r,i=this.x*r+this.y*t;return this.x=s,this.y=i,this}fromAngle(e,t=1){return this.x=Math.cos(e)*t,this.y=Math.sin(e)*t,this}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this}toString(){return`Vector(${this.x}, ${this.y})`}toArray(){return new Float32Array([this.x,this.y])}}class O{constructor(e=[]){this.points=e.slice().sort((t,r)=>t.x-r.x)}addPoint(e){this.points.push(e),this.points.sort((t,r)=>t.x-r.x)}getValue(e){const t=this.points.length;if(t===0)return new d;if(e<=this.points[0].x)return this.points[0].clone();if(e>=this.points[t-1].x)return this.points[t-1].clone();for(let r=0;r<t-1;r++){const s=this.points[r],i=this.points[r+1];if(e>=s.x&&e<=i.x){const a=_.unlerp(s.x,i.x,e);return s.clone().lerp(i,a)}}return new d}}class V{constructor(e,t){this.projectionMatrix=x.create(),this.viewMatrix=x.create(),this.position=new d,this.zoom=1,this.vw=0,this.vh=0,this.updateProjection(e,t)}updateProjection(e,t){this.vw=e,this.vh=t}update(){x.identity(this.viewMatrix),x.translate(this.viewMatrix,new d(-this.position.x,-this.position.y));const e=this.vw*.5/this.zoom,t=this.vh*.5/this.zoom;x.createOrtho(this.projectionMatrix,-e,e,-t,t)}}class b{constructor(e,t,r,s=1){this.r=e,this.g=t,this.b=r,this.a=s}copy(e){this.r=e.r,this.g=e.g,this.b=e.b,this.a=e.a}}const g=(()=>{const h=new Float32Array([0,1,0,0,0,0,0,1,1,1,1,0,1,0,1,1]),e=new Float32Array([-1,1,0,0,-1,-1,0,1,1,1,1,0,1,-1,1,1]);return{quad:h,fullscreenQuad:e,createSpritesData:(r,s=!1)=>{const i=s?1:4,a=28,n=new ArrayBuffer(r.length*i*a),c=new DataView(n);let l=0;for(const o of r){const u=o.position.x+o.offset.x,p=o.position.y+o.offset.y,w=o.scale.x,ce=o.scale.y,ue=o.angle,fe=o.tilesetRegion.x*(o.tileset.tileWidth+o.tileset.spacing)+o.tileset.margin,de=o.tilesetRegion.y*(o.tileset.tileHeight+o.tileset.spacing)+o.tileset.margin,ge=o.tileset.tileWidth+((o.tilesetRegion.width||1)-1)*(o.tileset.tileWidth+o.tileset.spacing),me=o.tileset.tileHeight+((o.tilesetRegion.height||1)-1)*(o.tileset.tileHeight+o.tileset.spacing);for(let D=0;D<i;++D)c.setFloat32(l,u,!0),c.setFloat32(l+4,p,!0),c.setFloat32(l+8,w,!0),c.setFloat32(l+12,ce,!0),c.setFloat32(l+16,ue,!0),c.setUint16(l+20,fe,!0),c.setUint16(l+22,de,!0),c.setUint16(l+24,ge,!0),c.setUint16(l+26,me,!0),l+=a}return n}}})();class v{constructor(){this.ops=[]}declare(e,t,r=!0){return this.ops.push([0,e,t,r]),this}set(e,t){return this.ops.push([1,e,t]),this}add(e,t){return this.ops.push([2,e,t]),this}sub(e,t){return this.ops.push([3,e,t]),this}mul(e,t){return this.ops.push([4,e,t]),this}div(e,t){return this.ops.push([5,e,t]),this}build(e){const t=[];for(const r of this.ops){const[s,i,a]=r;switch(s){case 0:{const[n,c,l,o]=r,u=e.getBuilderOptions().declareVar(c,l,o);t.push(u);break}case 1:case 2:case 3:case 4:case 5:{const n=this.replaceVariables(e,i),c=this.replaceVariables(e,a),l=`${n} ${this.getOpAssignmentSymbol(s)} ${c};`;t.push(this.replaceComponents(e,l));break}}}return t.join(`
`)}getOpAssignmentSymbol(e){switch(e){case 1:return"=";case 2:return"+=";case 3:return"-=";case 4:return"*=";case 5:return"/=";default:return""}}replaceComponents(e,t){const r=e.getBuilderOptions().componentMap;return t.replace(/\.[rgba]{1,4}\b/g,s=>{const i=s.substring(1);let a=".";for(let n=0;n<i.length;++n){const c=i[n];a+=r[c]??c}return a})}replaceVariables(e,t){return t.replace(/\$[A-Za-z0-9_]+/g,r=>e.getBuilderOptions().uniformMap[r]||r.slice(1))}}class A{constructor(e,t,r){this.gl=e,this.width=t,this.height=r,this.texture=e.createTexture(),e.bindTexture(e.TEXTURE_2D,this.texture),e.texImage2D(e.TEXTURE_2D,0,e.RGBA,t,r,0,e.RGBA,e.UNSIGNED_BYTE,null),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.LINEAR),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.LINEAR),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),this.fbo=e.createFramebuffer(),e.bindFramebuffer(e.FRAMEBUFFER,this.fbo),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,this.texture,0),e.checkFramebufferStatus(e.FRAMEBUFFER)!==e.FRAMEBUFFER_COMPLETE&&console.error("Framebuffer incomplete!"),e.bindFramebuffer(e.FRAMEBUFFER,null),e.bindTexture(e.TEXTURE_2D,null)}bind(){this.gl.bindFramebuffer(this.gl.FRAMEBUFFER,this.fbo),this.gl.viewport(0,0,this.width,this.height)}unbind(){this.gl.bindFramebuffer(this.gl.FRAMEBUFFER,null)}destroy(){this.gl.deleteFramebuffer(this.fbo),this.gl.deleteTexture(this.texture)}}class R{constructor(e,t,r){this.gl=e,this.uniforms=new Map;const s=this.compileShader(e.VERTEX_SHADER,t),i=this.compileShader(e.FRAGMENT_SHADER,r);if(this.program=e.createProgram(),e.attachShader(this.program,s),e.attachShader(this.program,i),e.linkProgram(this.program),!e.getProgramParameter(this.program,e.LINK_STATUS))throw new Error(e.getProgramInfoLog(this.program)??"Could not link program");e.deleteShader(s),e.deleteShader(i)}compileShader(e,t){const r=this.gl.createShader(e);if(!r)throw new Error("Could not create shader");if(this.gl.shaderSource(r,t),this.gl.compileShader(r),!this.gl.getShaderParameter(r,this.gl.COMPILE_STATUS))throw new Error(this.gl.getShaderInfoLog(r)??"Could not compile shader");return r}use(){this.gl.useProgram(this.program)}getUniform(e){if(!this.uniforms.has(e)){const t=this.gl.getUniformLocation(this.program,e);t||console.log("Could not get uniform location:",e),this.uniforms.set(e,t)}return this.uniforms.get(e)}getAttrib(e){return this.gl.getAttribLocation(this.program,e)}}const G=`

attribute vec2 aVertexPos;
attribute vec2 aTexCoord;
attribute vec2 aTilePos;
attribute float aTileAngle;
attribute vec2 aTileScale;
attribute vec4 aTileRegion;

uniform vec2 uViewportDimensions;
uniform vec2 uCameraPos;

uniform vec2 uTilesetDimensions;

varying vec2 uv;

void main() {
    vec2 flippedTexCoord = vec2(aTexCoord.x, 1.0 - aTexCoord.y);
    uv = (vec2(aTileRegion.xy) + flippedTexCoord * vec2(aTileRegion.zw)) / uTilesetDimensions;

    float c = cos(aTileAngle);
    float s = sin(aTileAngle);
    vec2 rotatedPos = vec2(
        aVertexPos.x * c - aVertexPos.y * s,
        aVertexPos.x * s + aVertexPos.y * c
    );
    vec2 worldPos = rotatedPos * aTileScale + aTilePos;
    vec2 pixelPos = worldPos - uCameraPos;
    vec2 clipPos = vec2(pixelPos.x / uViewportDimensions.x, 1.0 - pixelPos.y / uViewportDimensions.y) * 2.0 - 1.0;
    gl_Position = vec4(clipPos, 0.0, 1.0);
}
`,N=`

precision mediump float;

varying vec2 uv;

uniform sampler2D uSampler;  

void main() {
    gl_FragColor = texture2D(uSampler, uv);
}
`,X=`

attribute vec2 aPos;
attribute vec2 aUv;

varying vec2 uv;

void main() {
    uv = aUv;
    gl_Position = vec4(aPos, 0.0, 1.0);
}
`,Y=(h="")=>`
precision mediump float;

varying vec2 uv;

uniform sampler2D uSampler;
uniform vec2 u_resolution;
uniform float u_time;

vec4 mainImage(vec4 inColor, vec2 fragCoord) {
    vec4 fragColor = inColor;
${h.split(`
`).map(e=>"    "+e).join(`
`)}
    return fragColor;
}

void main() {
    gl_FragColor = texture2D(uSampler, vec2(uv.x, 1.0 - uv.y));
    vec2 fragCoord = vec2(gl_FragCoord.x, u_resolution.y - gl_FragCoord.y);
    gl_FragColor = mainImage(gl_FragColor, fragCoord);
}
`,W={componentMap:{r:"r",g:"g",b:"b",a:"a"},uniformMap:{$time:"u_time",$resolution:"u_resolution"},declareVar:(h,e,t=!0)=>`${e} ${h};`};class z{constructor(e){this.canvas=e,this.layersMap=new Map,this.texturesMap=new Map,this.clearColor=new b(0,0,0,0),this.shaderMap=new Map,this.initialized=!1}getBuilderOptions(){return W}addTextures(e,t){for(const r of e)t[r.name]&&this.texturesMap.set(r.name,{tileset:r,image:t[r.name]})}addShader(e,t){this.shaderMap.set(e,{builder:t})}setShader(e){const t=this.shaderMap.get(e);if(!t)throw new Error(`Program not found: ${e}`);this.fullscreenProgram=t.shader}setClearColor(e){this.clearColor.copy(e)}setSize(e,t){this.canvas.width=e,this.canvas.height=t,this.initialized&&(this.framebuffer.destroy(),this.framebuffer=new A(this.gl,e,t))}getCanvas(){return this.canvas}async init(){const e=this.canvas.getContext("webgl");if(!e)throw new Error("WebGL not supported");this.gl=e;for(const i of this.texturesMap.values())i.tileset&&(i.texture=this.createTexture(i.image));this.addShader("default",new v);for(const i of this.shaderMap.values()){const a=i.builder.build(this);i.shader=new R(e,X,Y(a))}this.setShader("default"),this.mainProgram=new R(e,G,N),this.attribLocations={vertexPos:this.mainProgram.getAttrib("aVertexPos"),texCoord:this.mainProgram.getAttrib("aTexCoord"),tilePos:this.mainProgram.getAttrib("aTilePos"),tileScale:this.mainProgram.getAttrib("aTileScale"),tileAngle:this.mainProgram.getAttrib("aTileAngle"),tileRegion:this.mainProgram.getAttrib("aTileRegion")},this.vbo=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.vbo);const t=new Float32Array(m*4*4);for(let i=0;i<m;++i)t.set(g.quad,i*4*4);e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW);const r=[0,1,2,1,2,3];this.ebo=e.createBuffer(),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,this.ebo);const s=new Uint16Array(m*6);for(let i=0;i<m;++i)for(let a=0;a<6;++a)s[i*6+a]=r[a]+4*i;e.bufferData(e.ELEMENT_ARRAY_BUFFER,s,e.STATIC_DRAW),e.enable(e.BLEND),e.blendFunc(e.SRC_ALPHA,e.ONE_MINUS_SRC_ALPHA),this.framebuffer=new A(e,this.canvas.width,this.canvas.height),this.fullscreenVbo=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.fullscreenVbo),e.bufferData(e.ARRAY_BUFFER,g.fullscreenQuad,e.STATIC_DRAW),this.initialized=!0}render(e,t){const r=[];for(const a of e.getLayersOrdered()){if(!this.layersMap.has(a)){const c=new H(this.gl,this,a.isStatic);this.layersMap.set(a,c)}const n=this.layersMap.get(a);n.needsUpdate&&n.upload(a.getSpritesOrdered()),r.push(n)}this.framebuffer.bind(),this.gl.clearColor(this.clearColor.r,this.clearColor.g,this.clearColor.b,this.clearColor.a),this.gl.clear(this.gl.COLOR_BUFFER_BIT),this.mainProgram.use(),this.gl.uniform2f(this.mainProgram.getUniform("uViewportDimensions"),t.vw,t.vh),this.gl.uniform2f(this.mainProgram.getUniform("uCameraPos"),t.position.x,t.position.y);for(let a of r)a.render();this.framebuffer.unbind(),this.gl.viewport(0,0,this.canvas.width,this.canvas.height),this.fullscreenProgram.use();const s=performance.now()*.001;this.gl.uniform1f(this.fullscreenProgram.getUniform("u_time"),s),this.gl.uniform2f(this.fullscreenProgram.getUniform("u_resolution"),this.canvas.width,this.canvas.height),this.gl.bindBuffer(this.gl.ARRAY_BUFFER,this.fullscreenVbo);const i={pos:this.fullscreenProgram.getAttrib("aPos"),uv:this.fullscreenProgram.getAttrib("aUv")};this.gl.enableVertexAttribArray(i.pos),this.gl.vertexAttribPointer(i.pos,2,this.gl.FLOAT,!1,16,0),this.gl.enableVertexAttribArray(i.uv),this.gl.vertexAttribPointer(i.uv,2,this.gl.FLOAT,!1,16,8),this.gl.bindTexture(this.gl.TEXTURE_2D,this.framebuffer.texture),this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4);for(const[a,n]of this.layersMap)n.lifetime<=0&&(this.layersMap.delete(a),n.destroy())}getTextureInfo(e){const t=this.texturesMap.get(e);if(!t)throw new Error("Texture not found: "+e);return t}getVBO(){return this.vbo}getEBO(){return this.ebo}getShaderProgram(){return this.mainProgram}getAttribLocations(){return this.attribLocations}createTexture(e){const t=this.gl,r=t.createTexture();return t.bindTexture(t.TEXTURE_2D,r),t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,e),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.NEAREST),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,t.NEAREST),r}}let H=class{constructor(e,t,r){this.gl=e,this.renderer=t,this.isStatic=r,this.needsUpdate=!0,this.drawCalls=[],this.lifetime=T,this.spriteBuffer=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.spriteBuffer),e.bufferData(e.ARRAY_BUFFER,(this.isStatic?m:S)*5*4*4,this.isStatic?e.STATIC_DRAW:e.DYNAMIC_DRAW)}upload(e){const t=this.gl;t.bindBuffer(t.ARRAY_BUFFER,this.spriteBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,g.createSpritesData(e)),this.isStatic&&(this.needsUpdate=!1),this.drawCalls.length=0;let r=null;for(let s=0;s<e.length;++s){const i=e[s].tileset.name;!r||i!==r.texName?(r={texName:i,spriteOffset:s,spriteCount:1},this.drawCalls.push(r)):r.spriteCount++}}render(){const e=this.gl,t=this.renderer.getAttribLocations();e.bindBuffer(e.ARRAY_BUFFER,this.renderer.getVBO()),e.enableVertexAttribArray(t.vertexPos),e.vertexAttribPointer(t.vertexPos,2,e.FLOAT,!1,16,0),e.enableVertexAttribArray(t.texCoord),e.vertexAttribPointer(t.texCoord,2,e.FLOAT,!1,16,8),e.bindBuffer(e.ARRAY_BUFFER,this.spriteBuffer);const r=28;e.enableVertexAttribArray(t.tilePos),e.vertexAttribPointer(t.tilePos,2,e.FLOAT,!1,r,0),e.enableVertexAttribArray(t.tileScale),e.vertexAttribPointer(t.tileScale,2,e.FLOAT,!1,r,8),e.enableVertexAttribArray(t.tileAngle),e.vertexAttribPointer(t.tileAngle,1,e.FLOAT,!1,r,16),e.enableVertexAttribArray(t.tileRegion),e.vertexAttribPointer(t.tileRegion,4,e.UNSIGNED_SHORT,!1,r,20),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,this.renderer.getEBO());for(const s of this.drawCalls){const i=this.renderer.getTextureInfo(s.texName);e.bindTexture(e.TEXTURE_2D,i.texture),this.gl.uniform2f(this.renderer.getShaderProgram().getUniform("uTilesetDimensions"),i.tileset.imageWidth,i.tileset.imageHeight),e.drawElements(e.TRIANGLES,6*s.spriteCount,e.UNSIGNED_SHORT,s.spriteOffset*6*2)}this.lifetime=T}destroy(){this.gl.deleteBuffer(this.spriteBuffer)}};const $=`#version 300 es

layout(location = 0) in vec2 aVertexPos;
layout(location = 1) in vec2 aTexCoord;

layout(location = 2) in vec2 aTilePos;
layout(location = 3) in vec2 aTileScale;
layout(location = 4) in float aTileAngle;
layout(location = 5) in uvec4 aTileRegion;

uniform vec2 uViewportDimensions;
uniform vec2 uCameraPos;

uniform vec2 uTilesetDimensions;

out vec2 uv;

void main() {
    vec2 flippedTexCoord = vec2(aTexCoord.x, 1.0 - aTexCoord.y);
    uv = (vec2(aTileRegion.xy) + flippedTexCoord * vec2(aTileRegion.zw)) / uTilesetDimensions;

    float c = cos(aTileAngle);
    float s = sin(aTileAngle);
    vec2 rotatedPos = vec2(
        aVertexPos.x * c - aVertexPos.y * s,
        aVertexPos.x * s + aVertexPos.y * c
    );
    vec2 worldPos = rotatedPos * aTileScale + aTilePos;
    vec2 pixelPos = worldPos - uCameraPos;
    vec2 clipPos = vec2(pixelPos.x / uViewportDimensions.x, 1.0 - pixelPos.y / uViewportDimensions.y) * 2.0 - 1.0;
    gl_Position = vec4(clipPos, 0.0, 1.0);
}
`,q=`#version 300 es

precision mediump float;

in vec2 uv;

uniform mediump sampler2D uSampler;  

out vec4 fragColor;

void main() {
    fragColor = texture(uSampler, uv);
}
`,j=`#version 300 es

layout(location=0) in vec2 aPos;
layout(location=1) in vec2 aUv;

out vec2 uv;

void main() {
    uv = aUv;
    gl_Position = vec4(aPos, 0.0, 1.0);
}
`,k=(h="")=>`#version 300 es
precision mediump float;

in vec2 uv;

uniform sampler2D uSampler;
uniform vec2 u_resolution;
uniform float u_time;

out vec4 fragColor;

void mainImage(out vec4 fragColor, in vec4 inColor, in vec2 fragCoord) {
    fragColor = inColor;
${h.split(`
`).map(e=>"    "+e).join(`
`)}
}

void main() {
    fragColor = texture(uSampler, vec2(uv.x, 1.0 - uv.y));
    vec2 fragCoord = vec2(gl_FragCoord.x, u_resolution.y - gl_FragCoord.y);
    mainImage(fragColor, fragColor, fragCoord);
}
`,K={componentMap:{r:"r",g:"g",b:"b",a:"a"},uniformMap:{$time:"u_time",$resolution:"u_resolution"},declareVar:(h,e,t=!0)=>`${e} ${h};`};class Q{constructor(e){this.canvas=e,this.layersMap=new Map,this.texturesMap=new Map,this.clearColor=new b(0,0,0,0),this.shaderMap=new Map,this.initialized=!1}getBuilderOptions(){return K}addTextures(e,t){for(const r of e)t[r.name]&&this.texturesMap.set(r.name,{tileset:r,image:t[r.name]})}addShader(e,t){this.shaderMap.set(e,{builder:t})}setShader(e){const t=this.shaderMap.get(e);if(!t)throw new Error(`Program not found: ${e}`);this.fullscreenProgram=t.shader}setClearColor(e){this.clearColor.copy(e)}setSize(e,t){this.canvas.width=e,this.canvas.height=t,this.initialized&&(this.framebuffer.destroy(),this.framebuffer=new A(this.gl,e,t))}getCanvas(){return this.canvas}async init(){const e=this.canvas.getContext("webgl2");if(!e)throw new Error("WebGL2 not supported");this.gl=e;for(const i of this.texturesMap.values())i.tileset&&(i.texture=this.createTexture(i.image));this.addShader("default",new v);for(const i of this.shaderMap.values()){const a=i.builder.build(this);i.shader=new R(e,j,k(a))}this.setShader("default"),this.shaderProgram=new R(e,$,q),this.vbo=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.vbo);const t=new Float32Array(m*4*4);for(let i=0;i<m;++i)t.set(g.quad,i*4*4);e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW);const r=[0,1,2,1,2,3];this.ebo=e.createBuffer(),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,this.ebo);const s=new Uint32Array(m*6);for(let i=0;i<m;++i)for(let a=0;a<6;++a)s[i*6+a]=r[a]+4*i;e.bufferData(e.ELEMENT_ARRAY_BUFFER,s,e.STATIC_DRAW),e.enable(e.BLEND),e.blendFunc(e.SRC_ALPHA,e.ONE_MINUS_SRC_ALPHA),this.framebuffer=new A(e,this.canvas.width,this.canvas.height),this.fullscreenVbo=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.fullscreenVbo),e.bufferData(e.ARRAY_BUFFER,g.fullscreenQuad,e.STATIC_DRAW),this.initialized=!0}render(e,t){const r=[];for(const i of e.getLayersOrdered()){if(!this.layersMap.has(i)){const n=new J(this.gl,this,i.isStatic);this.layersMap.set(i,n)}const a=this.layersMap.get(i);a.needsUpdate&&a.upload(i.getSpritesOrdered()),r.push(a)}this.framebuffer.bind(),this.gl.clearColor(this.clearColor.r,this.clearColor.g,this.clearColor.b,this.clearColor.a),this.gl.clear(this.gl.COLOR_BUFFER_BIT),this.shaderProgram.use(),this.gl.uniform2f(this.shaderProgram.getUniform("uViewportDimensions"),t.vw,t.vh),this.gl.uniform2f(this.shaderProgram.getUniform("uCameraPos"),t.position.x,t.position.y);for(let i of r)i.render();this.framebuffer.unbind(),this.gl.viewport(0,0,this.canvas.width,this.canvas.height),this.fullscreenProgram.use();const s=performance.now()*.001;this.gl.uniform1f(this.fullscreenProgram.getUniform("u_time"),s),this.gl.uniform2f(this.fullscreenProgram.getUniform("u_resolution"),this.canvas.width,this.canvas.height),this.gl.bindBuffer(this.gl.ARRAY_BUFFER,this.fullscreenVbo),this.gl.enableVertexAttribArray(0),this.gl.vertexAttribPointer(0,2,this.gl.FLOAT,!1,16,0),this.gl.enableVertexAttribArray(1),this.gl.vertexAttribPointer(1,2,this.gl.FLOAT,!1,16,8),this.gl.bindTexture(this.gl.TEXTURE_2D,this.framebuffer.texture),this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4);for(const[i,a]of this.layersMap)a.lifetime<=0&&(this.layersMap.delete(i),a.destroy())}getTextureInfo(e){const t=this.texturesMap.get(e);if(!t)throw new Error("Texture not found: "+e);return t}getVBO(){return this.vbo}getEBO(){return this.ebo}getShaderProgram(){return this.shaderProgram}createTexture(e){const t=this.gl,r=t.createTexture();return t.bindTexture(t.TEXTURE_2D,r),t.texImage2D(t.TEXTURE_2D,0,t.RGBA8,t.RGBA,t.UNSIGNED_BYTE,e),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.NEAREST),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,t.NEAREST),r}createTextureArray(e,t){const r=this.gl,s=r.createBuffer();r.bindBuffer(r.PIXEL_UNPACK_BUFFER,s),r.bufferData(r.PIXEL_UNPACK_BUFFER,t,r.STATIC_DRAW),r.pixelStorei(r.UNPACK_ROW_LENGTH,e.imageWidth),r.pixelStorei(r.UNPACK_IMAGE_HEIGHT,e.imageHeight);const i=r.createTexture();r.bindTexture(r.TEXTURE_2D_ARRAY,i),r.texStorage3D(r.TEXTURE_2D_ARRAY,4,r.RGBA8,e.tileWidth,e.tileHeight,e.tileCount);for(let a=0;a<e.tileCount;++a){const n=a%e.columns,c=Math.floor(a/e.columns);r.pixelStorei(r.UNPACK_SKIP_PIXELS,n*e.tileWidth),r.pixelStorei(r.UNPACK_SKIP_ROWS,c*e.tileHeight),r.texSubImage3D(r.TEXTURE_2D_ARRAY,0,0,0,a,e.tileWidth,e.tileHeight,1,r.RGBA,r.UNSIGNED_BYTE,0)}return r.deleteBuffer(s),r.generateMipmap(r.TEXTURE_2D_ARRAY),r.texParameteri(r.TEXTURE_2D_ARRAY,r.TEXTURE_MAG_FILTER,r.NEAREST),r.texParameteri(r.TEXTURE_2D_ARRAY,r.TEXTURE_MIN_FILTER,r.NEAREST),i}}class J{constructor(e,t,r){this.gl=e,this.renderer=t,this.isStatic=r,this.needsUpdate=!0,this.drawCalls=[],this.lifetime=T,this.vao=e.createVertexArray(),e.bindVertexArray(this.vao),e.bindBuffer(e.ARRAY_BUFFER,t.getVBO()),e.enableVertexAttribArray(0),e.vertexAttribPointer(0,2,e.FLOAT,!1,16,0),e.enableVertexAttribArray(1),e.vertexAttribPointer(1,2,e.FLOAT,!1,16,8);const s=28;this.spriteBuffer=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.spriteBuffer),e.bufferData(e.ARRAY_BUFFER,(this.isStatic?m:S)*4*s,this.isStatic?e.STATIC_DRAW:e.DYNAMIC_DRAW),e.enableVertexAttribArray(2),e.vertexAttribPointer(2,2,e.FLOAT,!1,s,0),e.enableVertexAttribArray(3),e.vertexAttribPointer(3,2,e.FLOAT,!1,s,8),e.enableVertexAttribArray(4),e.vertexAttribPointer(4,1,e.FLOAT,!1,s,16),e.enableVertexAttribArray(5),e.vertexAttribIPointer(5,4,e.UNSIGNED_SHORT,s,20),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,t.getEBO()),e.bindVertexArray(null)}upload(e){const t=this.gl;t.bindBuffer(t.ARRAY_BUFFER,this.spriteBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,g.createSpritesData(e)),this.isStatic&&(this.needsUpdate=!1),this.drawCalls.length=0;let r=null;for(let s=0;s<e.length;++s){const i=e[s].tileset.name;!r||i!==r.texName?(r={texName:i,spriteOffset:s,spriteCount:1},this.drawCalls.push(r)):r.spriteCount++}}render(){const e=this.gl;e.bindVertexArray(this.vao);for(const t of this.drawCalls){const r=this.renderer.getTextureInfo(t.texName);e.bindTexture(e.TEXTURE_2D,r.texture),this.gl.uniform2f(this.renderer.getShaderProgram().getUniform("uTilesetDimensions"),r.tileset.imageWidth,r.tileset.imageHeight),e.drawElements(e.TRIANGLES,6*t.spriteCount,e.UNSIGNED_INT,t.spriteOffset*6*4)}e.bindVertexArray(null),this.lifetime=T}destroy(){this.gl.deleteBuffer(this.spriteBuffer),this.gl.deleteVertexArray(this.vao)}}const Z=async()=>{const e=await(await navigator.gpu?.requestAdapter())?.requestDevice();if(!e)return null;const t=navigator.gpu.getPreferredCanvasFormat();return{device:e,format:t}},ee=`
struct VSInput {
    @location(0) vertexPos: vec2f,
    @location(1) texCoord: vec2f,
    
    @location(2) tilePos: vec2f,
    @location(3) tileScale: vec2f,
    @location(4) tileAngle: f32,
    @location(5) tileRegion: vec2u
}

struct Camera {
    pos: vec2f,
    viewportDimensions: vec2f
}

@group(0) @binding(0)
var<uniform> camera: Camera;

@group(1) @binding(2)
var<uniform> tilesetDimensions: vec2f;

struct VSOutput {
    @builtin(position) pos: vec4f,
    @location(0) uv: vec2f,
}

@vertex
fn vs_main(input: VSInput) -> VSOutput {
    var out: VSOutput;

    let x = f32(input.tileRegion.x & 0xFFFFu);
    let y = f32(input.tileRegion.x >> 16);
    let w = f32(input.tileRegion.y & 0xFFFFu);
    let h = f32(input.tileRegion.y >> 16);

    let tileRegion = vec4f(x, y, w, h);

    let flippedTexCoord = vec2f(input.texCoord.x, 1.0 - input.texCoord.y);
    out.uv = (tileRegion.xy + flippedTexCoord * tileRegion.zw) / tilesetDimensions;

    let c = cos(input.tileAngle);
    let s = sin(input.tileAngle);
    let rotatedPos = vec2f(
        input.vertexPos.x * c - input.vertexPos.y * s,
        input.vertexPos.x * s + input.vertexPos.y * c
    );
    let worldPos = rotatedPos * input.tileScale + input.tilePos;
    let pixelPos = worldPos - camera.pos;
    let clipPos = vec2f(pixelPos.x / camera.viewportDimensions.x, 1.0 - pixelPos.y / camera.viewportDimensions.y) * 2.0 - 1.0;
    out.pos = vec4f(clipPos, 0.0, 1.0);

    return out;
}

@group(1) @binding(0)
var spriteSampler: sampler;

@group(1) @binding(1)
var spriteTexture: texture_2d<f32>;

@fragment
fn fs_main(input: VSOutput) -> @location(0) vec4f {
    return textureSample(spriteTexture, spriteSampler, input.uv);
}
`,te=(h="")=>`
struct VSInput {
    @location(0) pos: vec2f,
    @location(1) uv: vec2f
}

struct VSOutput {
    @builtin(position) pos: vec4f,
    @location(0) uv: vec2f,
}

@vertex
fn vs_main(input: VSInput) -> VSOutput {
    var out: VSOutput;
    out.pos = vec4f(input.pos, 0.0, 1.0);
    out.uv = input.uv;
    return out;
}

struct Uniforms {
    resolution: vec2f,
    time: f32,
}

@group(0) @binding(0)
var<uniform> uniforms: Uniforms;

@group(1) @binding(0)
var screenSampler: sampler;

@group(1) @binding(1)
var screenTexture: texture_2d<f32>;

fn mainImage(inColor: vec4f, fragCoord: vec2f) -> vec4f {
    var fragColor = inColor;
${h.split(`
`).map(e=>"    "+e).join(`
`)}
    return fragColor;
}

@fragment
fn fs_main(input: VSOutput) -> @location(0) vec4f {
    _ = uniforms.resolution.x;
    let fragCoord = input.pos.xy;
    var fragColor = textureSample(screenTexture, screenSampler, input.uv);
    fragColor = mainImage(fragColor, fragCoord);
    return fragColor;
}
`,re={componentMap:{r:"x",g:"y",b:"z",a:"w"},uniformMap:{$time:"uniforms.time",$resolution:"uniforms.resolution"},declareVar:(h,e,t=!0)=>`var ${h}: ${e==="float"?"f32":e+"f"};`};class ie{constructor(e){this.shaderMap=new Map,this.layersMap=new Map,this.texturesMap=new Map,this.canvas=e,this.clearColor=new b(0,0,0,0),this.shaderMap=new Map,this.initialized=!1}getBuilderOptions(){return re}addTextures(e,t){for(const r of e)t[r.name]&&this.texturesMap.set(r.name,{tileset:r,image:t[r.name]})}addShader(e,t){this.shaderMap.set(e,{builder:t})}setShader(e){const t=this.shaderMap.get(e);if(!t)throw new Error(`Shader not found: ${e}`);this.activeFullscreenShader=t}setClearColor(e){this.clearColor.copy(e)}setSize(e,t){if(this.canvas.width=e,this.canvas.height=t,this.initialized){this.offscreenTexture.destroy(),this.offscreenTexture=this.cfg.device.createTexture({size:{width:this.canvas.width,height:this.canvas.height,depthOrArrayLayers:1},format:this.cfg.format,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});for(const[r,s]of this.shaderMap.entries())s.textureBindGroup=this.cfg.device.createBindGroup({label:r+" texture bind group",layout:s.pipeline.getBindGroupLayout(1),entries:[{binding:0,resource:this.fullscreenSampler},{binding:1,resource:this.offscreenTexture.createView()}]})}}getCanvas(){return this.canvas}async init(){const e=await Z();if(!e)throw new Error("WebGPU not supported");this.cfg=e;const t=this.cfg.device,r=this.canvas.getContext("webgpu");this.ctx=r,this.ctx.configure(this.cfg);for(const i of this.texturesMap.values())i.tileset&&(i.texture=this.createTexture(i.tileset,i.image));this.offscreenTexture=this.cfg.device.createTexture({size:{width:this.canvas.width,height:this.canvas.height,depthOrArrayLayers:1},format:this.cfg.format,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING}),this.sampler=t.createSampler({magFilter:"nearest",minFilter:"nearest",addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge"}),this.fullscreenSampler=t.createSampler({magFilter:"linear",minFilter:"linear",addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge"}),this.addShader("default",new v);for(const[i,a]of this.shaderMap.entries()){const n=te(a.builder.build(this)),c=t.createShaderModule({label:i+" shader module",code:n}),l=t.createRenderPipeline({layout:"auto",vertex:{module:c,entryPoint:"vs_main",buffers:[{arrayStride:16,stepMode:"vertex",attributes:[{shaderLocation:0,offset:0,format:"float32x2"},{shaderLocation:1,offset:8,format:"float32x2"}]}]},fragment:{module:c,entryPoint:"fs_main",targets:[{format:this.cfg.format}]},primitive:{topology:"triangle-strip"}}),o=t.createBuffer({size:16,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),u=t.createBindGroup({label:i+" uniform bind group",layout:l.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:o}}]}),p=t.createBindGroup({label:i+" texture bind group",layout:l.getBindGroupLayout(1),entries:[{binding:0,resource:this.fullscreenSampler},{binding:1,resource:this.offscreenTexture.createView()}]});a.module=c,a.pipeline=l,a.uniformBuffer=o,a.uniformBindGroup=u,a.textureBindGroup=p}this.setShader("default");const s=t.createShaderModule({code:ee});this.pipeline=t.createRenderPipeline({layout:"auto",vertex:{module:s,entryPoint:"vs_main",buffers:[{arrayStride:16,stepMode:"vertex",attributes:[{shaderLocation:0,offset:0,format:"float32x2"},{shaderLocation:1,offset:8,format:"float32x2"}]},{arrayStride:28,stepMode:"instance",attributes:[{shaderLocation:2,offset:0,format:"float32x2"},{shaderLocation:3,offset:8,format:"float32x2"},{shaderLocation:4,offset:16,format:"float32"},{shaderLocation:5,offset:20,format:"uint32x2"}]}]},fragment:{module:s,entryPoint:"fs_main",targets:[{format:this.cfg.format,blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha",operation:"add"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"}}}]},primitive:{topology:"triangle-strip"}}),this.cameraBuffer=t.createBuffer({size:16,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),this.cameraBindGroup=t.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:this.cameraBuffer}}]}),this.vbo=t.createBuffer({size:g.quad.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST}),t.queue.writeBuffer(this.vbo,0,g.quad),this.fullscreenVbo=t.createBuffer({size:g.fullscreenQuad.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST}),t.queue.writeBuffer(this.fullscreenVbo,0,g.fullscreenQuad)}render(e,t){const r=[];for(const l of e.getLayersOrdered()){if(!this.layersMap.has(l)){const u=new se(this,l.isStatic);this.layersMap.set(l,u)}const o=this.layersMap.get(l);o.needsUpdate&&o.upload(l.getSpritesOrdered()),r.push(o)}this.cfg.device.queue.writeBuffer(this.cameraBuffer,0,t.position.toArray()),this.cfg.device.queue.writeBuffer(this.cameraBuffer,8,new Float32Array([t.vw,t.vh]));const s=performance.now()*.001;this.cfg.device.queue.writeBuffer(this.activeFullscreenShader.uniformBuffer,0,new Float32Array([this.canvas.width,this.canvas.height,s]));const i=this.cfg.device.createCommandEncoder(),a=i.beginRenderPass({colorAttachments:[{clearValue:this.clearColor,view:this.offscreenTexture.createView(),loadOp:"clear",storeOp:"store"}]});a.setPipeline(this.pipeline),a.setBindGroup(0,this.cameraBindGroup),a.setVertexBuffer(0,this.vbo);for(const l of r)l.render(a);a.end();const n=i.beginRenderPass({colorAttachments:[{view:this.ctx.getCurrentTexture().createView(),loadOp:"clear",storeOp:"store"}]});n.setPipeline(this.activeFullscreenShader.pipeline),n.setBindGroup(0,this.activeFullscreenShader.uniformBindGroup),n.setBindGroup(1,this.activeFullscreenShader.textureBindGroup),n.setVertexBuffer(0,this.fullscreenVbo),n.draw(4,1,0,0),n.end();const c=i.finish();this.cfg.device.queue.submit([c]);for(const[l,o]of this.layersMap)o.lifetime<=0&&(o.destroy(),this.layersMap.delete(l))}createTexture(e,t){const r=this.cfg.device.createTexture({size:{width:e.imageWidth,height:e.imageHeight,depthOrArrayLayers:1},format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT});return this.cfg.device.queue.copyExternalImageToTexture,this.cfg.device.queue.copyExternalImageToTexture({source:t},{texture:r},[e.imageWidth,e.imageHeight,1]),r}createTextureArray(e,t){const r=e.tileWidth,s=e.tileHeight,i=this.cfg.device.createTexture({size:{width:r,height:s,depthOrArrayLayers:e.tileCount},format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT});for(let a=0;a<e.tileCount;++a){const n=Math.floor(a/e.columns),c=a%e.columns,l=new Uint8Array(r*s*4);for(let o=0;o<s;++o){const u=((n*s+o)*e.columns+c)*r*4,p=u+r*4;l.set(t.slice(u,p),o*r*4)}this.cfg.device.queue.writeTexture({texture:i,origin:{x:0,y:0,z:a}},l,{bytesPerRow:r*4,rowsPerImage:s},{width:r,height:s,depthOrArrayLayers:1})}return i}getConfig(){return this.cfg}getTextureInfo(e){const t=this.texturesMap.get(e);if(!t)throw new Error("Texture not found: "+e);return t}getPipeline(){return this.pipeline}getSampler(){return this.sampler}}class se{constructor(e,t){this.renderer=e,this.isStatic=t,this.needsUpdate=!0,this.drawCalls=[],this.bindGroups=new Map,this.lifetime=T,this.lastTexIdx=0,this.instanceBuffer=e.getConfig().device.createBuffer({label:"Instance Buffer",size:24*(t?m:S),usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST}),this.tilesetDimBuffer=e.getConfig().device.createBuffer({label:"Tileset Dimensions Buffer",size:ae*256,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST})}upload(e){const t=this.renderer.getConfig().device,r=this.renderer.getPipeline(),s=this.renderer.getSampler();t.queue.writeBuffer(this.instanceBuffer,0,g.createSpritesData(e,!0)),this.isStatic&&(this.needsUpdate=!1),this.drawCalls.length=0;let i=null;for(let a=0;a<e.length;++a){const n=e[a].tileset.name;if(!i||n!==i.texName){const c=this.renderer.getTextureInfo(n);t.queue.writeBuffer(this.tilesetDimBuffer,this.lastTexIdx*256,new Float32Array([c.tileset.imageWidth,c.tileset.imageHeight]));const l=t.createBindGroup({layout:r.getBindGroupLayout(1),entries:[{binding:0,resource:s},{binding:1,resource:c.texture.createView()},{binding:2,resource:{buffer:this.tilesetDimBuffer,offset:this.lastTexIdx*256,size:8}}]});i={texName:n,instanceOffset:a,instanceCount:1},this.bindGroups.has(i.texName)||(this.bindGroups.set(i.texName,l),++this.lastTexIdx),this.drawCalls.push(i)}else i.instanceCount++}}render(e){e.setVertexBuffer(1,this.instanceBuffer);for(const t of this.drawCalls)e.setBindGroup(1,this.bindGroups.get(t.texName)),e.draw(4,t.instanceCount,0,t.instanceOffset);this.lifetime=T}destroy(){this.instanceBuffer.destroy(),this.tilesetDimBuffer.destroy()}}const m=1e5,S=1e5,T=30,ae=16,ne=h=>{const e=document.createElement("canvas");switch(h){case"webgl":return new z(e);case"webgl2":return new Q(e);case"webgpu":return new ie(e);default:throw new Error("Unknwn renderer type")}};class U{constructor(e){this.zIndex=e.zIndex||0,this.tileset=e.tileset,this.tilesetRegion=e.tilesetRegion,this.isStatic=e.isStatic||!1,this.position=new d,this.offset=new d,this.scale=new d(1,1),this.angle=e.angle||0}setTilesetRegion(e,t,r=1,s=1){this.tilesetRegion.x=e,this.tilesetRegion.y=t,this.tilesetRegion.width=r,this.tilesetRegion.height=s}getTile(){return this.tileset.getTile(this.tilesetRegion.x,this.tilesetRegion.y)}}class oe{constructor(){this.layers=[]}addSprite(e){let t=this.layers.find(r=>r.isStatic===e.isStatic&&r.zIndex===e.zIndex);return t||(t=new F({zIndex:e.zIndex,isStatic:e.isStatic}),this.layers.push(t)),t.add(e),e}addTilemap(e,t={}){const r=e.getLayers();let s=0;const i=[],a=[];for(const n of r){const c=t.layers?.find(l=>l.name===n.name);switch(c?.zIndex&&(s=c.zIndex),n.renderOrder!=="manual"&&this.createLayer({zIndex:s,renderOrder:n.renderOrder,isStatic:!1}),n.type){case"tilelayer":{for(let l=0;l<n.height;++l)for(let o=0;o<n.width;++o){const u=n.getTile(o,l);if(!u)continue;const p=new U({isStatic:u.animation===void 0,zIndex:s,tileset:u.tileset,tilesetRegion:{x:u.x,y:u.y}});if(p.position.set((o+n.x)*e.tileWidth,(l+n.y)*e.tileHeight),p.scale.set(e.tileWidth,e.tileHeight),i.push(this.addSprite(p)),u.animation){const w=new B(p);w.play({x:u.x,y:u.y},{repeat:!0}),a.push(w)}}break}case"objectgroup":{if(t.onObject){const l=n.getObjects();for(const o of l)t.onObject(this,o,n,s)}break}}++s}return{sprites:i,animators:a}}createLayer(e){const t=new F(e);return this.layers.push(t),t}getLayersOrdered(){return this.layers.sort((e,t)=>e.zIndex-t.zIndex)}}class F{constructor(e){this.zIndex=e.zIndex,this.isStatic=e.isStatic,this.renderOrder=e.renderOrder||"manual",this.sprites=[]}add(e){if(this.renderOrder==="manual"){let t=-1;for(let r=this.sprites.length-1;r>=0;--r)if(this.sprites[r].tileset.name<=e.tileset.name){t=r;break}t===-1?this.sprites.unshift(e):this.sprites.splice(t+1,0,e)}else this.sprites.push(e)}getSpritesOrdered(){switch(this.renderOrder){case"topdown":return this.sprites.sort((e,t)=>e.position.y-t.position.y);default:return this.sprites}}}class I{constructor(e,t,r,s,i){this.tileset=e,this.id=t,this.x=r,this.y=s,this.properties=i?.properties,this.animation=i?.animation}getProperty(e){return this.properties?.find(t=>t.name===e)??null}}const E=class E{constructor(e){if(this.name=e.name,this.imageWidth=e.imagewidth,this.imageHeight=e.imageheight,this.tileWidth=e.tilewidth,this.tileHeight=e.tileheight,this.columns=e.columns,this.tileCount=e.tilecount,this.margin=e.margin||0,this.spacing=e.spacing||0,this.tiledata=new Map,e.tiles)for(let t of e.tiles)this.tiledata.set(t.id,t)}static async load(e){if(!this.cache.has(e)){const t=await P.loadJson(e);this.cache.set(e,new E(t))}return this.cache.get(e)}static getByName(e){return this.cache.values().find(t=>t.name===e)||null}getTile(e,t){if(e<0||e>=this.columns||t<0||t>=Math.ceil(this.tileCount/this.columns))return null;const r=t*this.columns+e,s=this.tiledata.get(r);return new I(this,r,e,t,s)}getTileById(e){if(e>=this.tileCount||e<0)return null;const t=e%this.columns,r=Math.floor(e/this.columns),s=this.tiledata.get(e);return new I(this,e,t,r,s)}getTileXY(e){const t=e%this.columns,r=Math.floor(e/this.columns);return{x:t,y:r}}};E.cache=new Map;let y=E;class M{constructor(e){this.name=e.name,this.x=e.x,this.y=e.y,this.width=e.width,this.height=e.height,this.type=e.type,this.renderOrder=e.draworder||"manual"}}class le extends M{constructor(e){super(e),this.data=e.data}getTile(e,t){const r=this.data[t*this.width+e];return r-1==-1?null:this.tilemap.getTileById(r)}}class he extends M{constructor(e){super(e),this.objects=e.objects}getObjects(){return this.objects}}class C{constructor(e,t,r,s){this.width=e,this.height=t,this.tileWidth=r,this.tileHeight=s,this.tilesets=[],this.layers=[]}static async load(e,t){const r=await P.loadJson(e),s=new C(r.width,r.height,r.tilewidth,r.tileheight);for(const i of r.layers)switch(i.type){case"tilelayer":s.addLayer(new le(i));break;case"objectgroup":s.addLayer(new he(i));break}for(let i of r.tilesets){let a;if(i.source){const n=i.source.split(/(\/|\\\/)/),c=n[n.length-1].split(".tsj")[0];if(!t[c])throw new Error("Source is missing for tileset: "+c);a=await y.load(t[c])}else a=new y(i);s.tilesets.push({tileset:a,firstGlobalId:i.firstgid})}return s}addLayer(e){e.tilemap=this,this.layers.push(e)}getTilesets(){return this.tilesets.map(e=>e.tileset)}getTilesetByName(e){return this.tilesets.find(t=>t.tileset.name===e)?.tileset||null}getLayers(){return this.layers}getLayerByName(e){return this.layers.find(t=>t.name===e)||null}getTileById(e){const t=this.tilesets;for(let r of t){let s=r.tileset.getTileById(e-r.firstGlobalId);if(s)return s}return null}}return f.Animator=B,f.Camera=V,f.Color=b,f.LinearSpline=L,f.LinearSplineVector=O,f.Scene=oe,f.ShaderBuilder=v,f.Sprite=U,f.Tilemap=C,f.Tileset=y,f.Vector=d,f.assets=P,f.createRenderer=ne,f.math=_,f.matrix=x,Object.defineProperty(f,Symbol.toStringTag,{value:"Module"}),f})({});
