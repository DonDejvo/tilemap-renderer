var TilemapRenderer=(function(c){"use strict";const A={loadImage:t=>new Promise((s,r)=>{const i=new Image;i.crossOrigin="anonymous",i.src=t,i.onload=()=>{s(i)},i.onerror=()=>{r()}}),loadJson:async t=>{try{return await(await fetch(t)).json()}catch{throw new Error(`Failed to load: ${t}`)}}},p={create:()=>new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]),identity:i=>(i[0]=1,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=1,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[10]=1,i[11]=0,i[12]=0,i[13]=0,i[14]=0,i[15]=1,i),createOrtho:(i,a,n,h,o)=>(i[0]=2/(n-a),i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=2/(o-h),i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[10]=1,i[11]=0,i[12]=-(n+a)/(n-a),i[13]=-(o+h)/(o-h),i[14]=0,i[15]=1,i),translate:(i,a)=>(i[12]+=a.x,i[13]+=a.y,i),scale:(i,a)=>(i[0]*=a.x,i[1]*=a.x,i[4]*=a.y,i[5]*=a.y,i)},w=(()=>{const l=(r,i,a)=>Math.min(Math.max(r,i),a);return{clamp:l,lerp:(r,i,a)=>r+(i-r)*a,unlerp:(r,i,a)=>l((a-r)/(i-r),0,1),sat:r=>l(r,0,1)}})();class M{constructor(e=[]){this.points=e}addPoint(e){this.points.push(e)}getValue(e){const t=this.points.length;if(t===0)return 0;if(e<=0)return this.points[0];if(e>=t-1)return this.points[t-1];const s=Math.floor(e),r=e-s;return w.lerp(this.points[s],this.points[s+1],r)}}class u{constructor(e=0,t=0){this.x=e,this.y=t}set(e,t){return this.x=e,this.y=t,this}copy(e){return this.x=e.x,this.y=e.y,this}clone(){return new u(this.x,this.y)}add(e){return this.x+=e.x,this.y+=e.y,this}sub(e){return this.x-=e.x,this.y-=e.y,this}scale(e){return this.x*=e,this.y*=e,this}mul(e){return this.x*=e.x,this.y*=e.y,this}div(e){return e!==0?(this.x/=e,this.y/=e):(this.x=0,this.y=0),this}static dot(e,t){return e.x*t.x+e.y*t.y}static cross(e,t){return e.x*t.y-e.y*t.x}len(){return Math.sqrt(this.x*this.x+this.y*this.y)}lenSq(){return this.x*this.x+this.y*this.y}unit(){const e=this.len();return e>0&&this.div(e),this}project(e){const t=e.lenSq();if(t>0)return this.scale(0);const s=u.dot(this,e);return this.copy(e).scale(s/t)}static distance(e,t){const s=e.x-t.x,r=e.y-t.y;return Math.sqrt(s*s+r*r)}angle(){return Math.atan2(this.y,this.x)}rot(e){const t=Math.cos(e),s=Math.sin(e),r=this.x*t-this.y*s,i=this.x*s+this.y*t;return this.x=r,this.y=i,this}fromAngle(e,t=1){return this.x=Math.cos(e)*t,this.y=Math.sin(e)*t,this}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this}toString(){return`Vector(${this.x}, ${this.y})`}}class I{constructor(e=[]){this.points=e.slice().sort((t,s)=>t.x-s.x)}addPoint(e){this.points.push(e),this.points.sort((t,s)=>t.x-s.x)}getValue(e){const t=this.points.length;if(t===0)return new u;if(e<=this.points[0].x)return this.points[0].clone();if(e>=this.points[t-1].x)return this.points[t-1].clone();for(let s=0;s<t-1;s++){const r=this.points[s],i=this.points[s+1];if(e>=r.x&&e<=i.x){const a=w.unlerp(r.x,i.x,e);return r.clone().lerp(i,a)}}return new u}}class L{constructor(e,t){this.projectionMatrix=p.create(),this.viewMatrix=p.create(),this.position=new u,this.zoom=1,this.vw=0,this.vh=0,this.updateProjection(e,t)}updateProjection(e,t){this.vw=e,this.vh=t}update(){p.identity(this.viewMatrix),p.translate(this.viewMatrix,new u(-this.position.x,-this.position.y));const e=this.vw*.5/this.zoom,t=this.vh*.5/this.zoom;p.createOrtho(this.projectionMatrix,-e,e,-t,t)}}class y{constructor(e,t,s,r=1){this.r=e,this.g=t,this.b=s,this.a=r}copy(e){this.r=e.r,this.g=e.g,this.b=e.b,this.a=e.a}}const g={quad:new Float32Array([-.5,.5,0,0,-.5,-.5,0,1,.5,.5,1,0,.5,-.5,1,1]),createSpritesData:(t,s=!1)=>{const r=s?1:4,i=24,a=new ArrayBuffer(t.length*r*i),n=new DataView(a);let h=0;for(const o of t){const d=Math.round(o.position.x+o.offset.x*o.scale.x),m=Math.round(o.position.y+o.offset.y*o.scale.y),E=Math.round(o.scale.x),v=Math.round(o.scale.y),Z=o.tilesetRegion.x*(o.tileset.tileWidth+o.tileset.spacing)+o.tileset.margin,ee=o.tilesetRegion.y*(o.tileset.tileHeight+o.tileset.spacing)+o.tileset.margin,te=o.tileset.tileWidth+((o.tilesetRegion.width||1)-1)*(o.tileset.tileWidth+o.tileset.spacing),re=o.tileset.tileHeight+((o.tilesetRegion.height||1)-1)*(o.tileset.tileHeight+o.tileset.spacing);for(let B=0;B<r;++B)n.setFloat32(h,d,!0),n.setFloat32(h+4,m,!0),n.setFloat32(h+8,E,!0),n.setFloat32(h+12,v,!0),n.setUint16(h+16,Z,!0),n.setUint16(h+18,ee,!0),n.setUint16(h+20,te,!0),n.setUint16(h+22,re,!0),h+=i}return a}};class _{constructor(e,t,s){this.gl=e,this.uniforms=new Map;const r=this.compileShader(e.VERTEX_SHADER,t),i=this.compileShader(e.FRAGMENT_SHADER,s);if(this.program=e.createProgram(),e.attachShader(this.program,r),e.attachShader(this.program,i),e.linkProgram(this.program),!e.getProgramParameter(this.program,e.LINK_STATUS))throw new Error(e.getProgramInfoLog(this.program)??"Could not link program");e.deleteShader(r),e.deleteShader(i)}compileShader(e,t){const s=this.gl.createShader(e);if(!s)throw new Error("Could not create shader");if(this.gl.shaderSource(s,t),this.gl.compileShader(s),!this.gl.getShaderParameter(s,this.gl.COMPILE_STATUS))throw new Error(this.gl.getShaderInfoLog(s)??"Could not compile shader");return s}use(){this.gl.useProgram(this.program)}getUniform(e){if(!this.uniforms.has(e)){const t=this.gl.getUniformLocation(this.program,e);t||console.log("Could not get uniform location:",e),this.uniforms.set(e,t)}return this.uniforms.get(e)}getAttrib(e){return this.gl.getAttribLocation(this.program,e)}}const F=`

attribute vec2 aVertexPos;
attribute vec2 aTexCoord;
attribute vec2 aTilePos;
attribute vec2 aTileScale;
attribute vec4 aTileRegion;

uniform mat4 uProjectionMatrix;
uniform mat4 uViewMatrix;

uniform vec2 uTilesetDimensions;

varying vec2 uv;

void main() {
    uv = (vec2(aTileRegion.xy) + aTexCoord * vec2(aTileRegion.zw)) / uTilesetDimensions;

    vec2 worldPos = aVertexPos * aTileScale + aTilePos;
    gl_Position = uProjectionMatrix * uViewMatrix * vec4(worldPos, 0.0, 1.0);
}
`,D=`

precision mediump float;

varying vec2 uv;

uniform sampler2D uSampler;  

void main() {
    gl_FragColor = texture2D(uSampler, uv);
}
`;class O{constructor(e){this.canvas=e,this.layersMap=new Map,this.texturesMap=new Map,this.clearColor=new y(0,0,0,0),this.texturesInfo=[]}addTextures(e,t){for(const s of e)t[s.name]&&this.texturesInfo.push({tileset:s,image:t[s.name]})}setClearColor(e){this.clearColor.copy(e)}setSize(e,t){this.canvas.width=e,this.canvas.height=t}getCanvas(){return this.canvas}async init(){const e=this.canvas.getContext("webgl");if(!e)throw new Error("WebGL not supported");this.gl=e;for(const i of this.texturesInfo)i.tileset&&this.createTexture(i.tileset,i.tileset.name,i.image);this.shaderProgram=new _(e,F,D),this.attribLocations={vertexPos:this.shaderProgram.getAttrib("aVertexPos"),texCoord:this.shaderProgram.getAttrib("aTexCoord"),tilePos:this.shaderProgram.getAttrib("aTilePos"),tileScale:this.shaderProgram.getAttrib("aTileScale"),tileRegion:this.shaderProgram.getAttrib("aTileRegion")},this.vbo=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.vbo);const t=new Float32Array(f*4*4);for(let i=0;i<f;++i)t.set(g.quad,i*4*4);e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW);const s=[0,1,2,1,2,3];this.ebo=e.createBuffer(),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,this.ebo);const r=new Uint16Array(f*6);for(let i=0;i<f;++i)for(let a=0;a<6;++a)r[i*6+a]=s[a]+4*i;e.bufferData(e.ELEMENT_ARRAY_BUFFER,r,e.STATIC_DRAW),e.enable(e.BLEND),e.blendFunc(e.SRC_ALPHA,e.ONE_MINUS_SRC_ALPHA)}render(e,t){const s=[];for(const r of e.getLayersOrdered()){if(!this.layersMap.has(r)){const a=new N(this.gl,this,r.isStatic);this.layersMap.set(r,a)}const i=this.layersMap.get(r);i.needsUpdate&&i.upload(r.getSpritesOrdered()),s.push(i)}this.gl.viewport(0,0,t.vw,t.vh),this.gl.clearColor(this.clearColor.r,this.clearColor.g,this.clearColor.b,this.clearColor.a),this.gl.clear(this.gl.COLOR_BUFFER_BIT),this.shaderProgram.use(),this.gl.uniformMatrix4fv(this.shaderProgram.getUniform("uProjectionMatrix"),!1,t.projectionMatrix),this.gl.uniformMatrix4fv(this.shaderProgram.getUniform("uViewMatrix"),!1,t.viewMatrix);for(let r of s)r.render();for(const[r,i]of this.layersMap)i.lifetime<=0&&(this.layersMap.delete(r),i.destroy())}getTextureInfo(e){const t=this.texturesMap.get(e);if(!t)throw new Error("Texture not found: "+e);return t}getVBO(){return this.vbo}getEBO(){return this.ebo}getShaderProgram(){return this.shaderProgram}getAttribLocations(){return this.attribLocations}createTexture(e,t,s){const r=this.gl,i=r.createTexture();r.bindTexture(r.TEXTURE_2D,i),r.texImage2D(r.TEXTURE_2D,0,r.RGBA,r.RGBA,r.UNSIGNED_BYTE,s),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_WRAP_S,r.CLAMP_TO_EDGE),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_WRAP_T,r.CLAMP_TO_EDGE),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_MIN_FILTER,r.NEAREST),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_MAG_FILTER,r.NEAREST),this.texturesMap.set(t,{texture:i,tileset:e})}}let N=class{constructor(e,t,s){this.gl=e,this.renderer=t,this.isStatic=s,this.needsUpdate=!0,this.drawCalls=[],this.lifetime=x,this.spriteBuffer=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.spriteBuffer),e.bufferData(e.ARRAY_BUFFER,(this.isStatic?f:b)*5*4*4,this.isStatic?e.STATIC_DRAW:e.DYNAMIC_DRAW)}upload(e){const t=this.gl;t.bindBuffer(t.ARRAY_BUFFER,this.spriteBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,g.createSpritesData(e)),this.isStatic&&(this.needsUpdate=!1),this.drawCalls.length=0;let s=null;for(let r=0;r<e.length;++r){const i=e[r].tileset.name;!s||i!==s.texName?(s={texName:i,spriteOffset:r,spriteCount:1},this.drawCalls.push(s)):s.spriteCount++}}render(){const e=this.gl,t=this.renderer.getAttribLocations();e.bindBuffer(e.ARRAY_BUFFER,this.renderer.getVBO()),e.enableVertexAttribArray(t.vertexPos),e.vertexAttribPointer(t.vertexPos,2,e.FLOAT,!1,16,0),e.enableVertexAttribArray(t.texCoord),e.vertexAttribPointer(t.texCoord,2,e.FLOAT,!1,16,8),e.bindBuffer(e.ARRAY_BUFFER,this.spriteBuffer),e.enableVertexAttribArray(t.tilePos),e.vertexAttribPointer(t.tilePos,2,e.FLOAT,!1,24,0),e.enableVertexAttribArray(t.tileScale),e.vertexAttribPointer(t.tileScale,2,e.FLOAT,!1,24,8),e.enableVertexAttribArray(t.tileRegion),e.vertexAttribPointer(t.tileRegion,4,e.UNSIGNED_SHORT,!1,24,16),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,this.renderer.getEBO());for(const s of this.drawCalls){const r=this.renderer.getTextureInfo(s.texName);e.bindTexture(e.TEXTURE_2D,r.texture),this.gl.uniform2f(this.renderer.getShaderProgram().getUniform("uTilesetDimensions"),r.tileset.imageWidth,r.tileset.imageHeight),e.drawElements(e.TRIANGLES,6*s.spriteCount,e.UNSIGNED_SHORT,s.spriteOffset*6*2)}this.lifetime=x}destroy(){this.gl.deleteBuffer(this.spriteBuffer)}};const G=`#version 300 es

layout(location = 0) in vec2 aVertexPos;
layout(location = 1) in vec2 aTexCoord;

layout(location = 2) in vec2 aTilePos;
layout(location = 3) in vec2 aTileScale;
layout(location = 4) in uvec4 aTileRegion;

uniform mat4 uProjectionMatrix;
uniform mat4 uViewMatrix;

uniform vec2 uTilesetDimensions;

out vec2 uv;

void main() {
    uv = (vec2(aTileRegion.xy) + aTexCoord * vec2(aTileRegion.zw)) / uTilesetDimensions;

    vec2 worldPos = aVertexPos * aTileScale + aTilePos;
    gl_Position = uProjectionMatrix * uViewMatrix * vec4(worldPos, 0.0, 1.0);
}
`,V=`#version 300 es

precision mediump float;

in vec2 uv;

uniform mediump sampler2D uSampler;  

out vec4 fragColor;

void main() {
    fragColor = texture(uSampler, uv);
}
`;class W{constructor(e){this.canvas=e,this.layersMap=new Map,this.texturesMap=new Map,this.clearColor=new y(0,0,0,0),this.texturesInfo=[]}addTextures(e,t){for(const s of e)t[s.name]&&this.texturesInfo.push({tileset:s,image:t[s.name]})}setClearColor(e){this.clearColor.copy(e)}setSize(e,t){this.canvas.width=e,this.canvas.height=t}getCanvas(){return this.canvas}async init(){const e=this.canvas.getContext("webgl2");if(!e)throw new Error("WebGL2 not supported");this.gl=e;for(const i of this.texturesInfo)i.tileset&&this.createTexture(i.tileset,i.tileset.name,i.image);this.shaderProgram=new _(e,G,V),this.vbo=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.vbo);const t=new Float32Array(f*4*4);for(let i=0;i<f;++i)t.set(g.quad,i*4*4);e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW);const s=[0,1,2,1,2,3];this.ebo=e.createBuffer(),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,this.ebo);const r=new Uint32Array(f*6);for(let i=0;i<f;++i)for(let a=0;a<6;++a)r[i*6+a]=s[a]+4*i;e.bufferData(e.ELEMENT_ARRAY_BUFFER,r,e.STATIC_DRAW),e.enable(e.BLEND),e.blendFunc(e.SRC_ALPHA,e.ONE_MINUS_SRC_ALPHA)}render(e,t){const s=[];for(const r of e.getLayersOrdered()){if(!this.layersMap.has(r)){const a=new Y(this.gl,this,r.isStatic);this.layersMap.set(r,a)}const i=this.layersMap.get(r);i.needsUpdate&&i.upload(r.getSpritesOrdered()),s.push(i)}this.gl.viewport(0,0,this.canvas.width,this.canvas.height),this.gl.clearColor(this.clearColor.r,this.clearColor.g,this.clearColor.b,this.clearColor.a),this.gl.clear(this.gl.COLOR_BUFFER_BIT),this.shaderProgram.use(),this.gl.uniformMatrix4fv(this.shaderProgram.getUniform("uProjectionMatrix"),!1,t.projectionMatrix),this.gl.uniformMatrix4fv(this.shaderProgram.getUniform("uViewMatrix"),!1,t.viewMatrix);for(let r of s)r.render();for(const[r,i]of this.layersMap)i.lifetime<=0&&(this.layersMap.delete(r),i.destroy())}getTextureInfo(e){const t=this.texturesMap.get(e);if(!t)throw new Error("Texture not found: "+e);return t}getVBO(){return this.vbo}getEBO(){return this.ebo}getShaderProgram(){return this.shaderProgram}createTexture(e,t,s){const r=this.gl,i=r.createTexture();r.bindTexture(r.TEXTURE_2D,i),r.texImage2D(r.TEXTURE_2D,0,r.RGBA8,r.RGBA,r.UNSIGNED_BYTE,s),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_WRAP_S,r.CLAMP_TO_EDGE),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_WRAP_T,r.CLAMP_TO_EDGE),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_MIN_FILTER,r.NEAREST),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_MAG_FILTER,r.NEAREST),this.texturesMap.set(t,{texture:i,tileset:e})}createTextureArray(e,t,s){const r=this.gl,i=r.createBuffer();r.bindBuffer(r.PIXEL_UNPACK_BUFFER,i),r.bufferData(r.PIXEL_UNPACK_BUFFER,s,r.STATIC_DRAW),r.pixelStorei(r.UNPACK_ROW_LENGTH,e.imageWidth),r.pixelStorei(r.UNPACK_IMAGE_HEIGHT,e.imageHeight);const a=r.createTexture();r.bindTexture(r.TEXTURE_2D_ARRAY,a),r.texStorage3D(r.TEXTURE_2D_ARRAY,4,r.RGBA8,e.tileWidth,e.tileHeight,e.tileCount);for(let n=0;n<e.tileCount;++n){const h=n%e.columns,o=Math.floor(n/e.columns);r.pixelStorei(r.UNPACK_SKIP_PIXELS,h*e.tileWidth),r.pixelStorei(r.UNPACK_SKIP_ROWS,o*e.tileHeight),r.texSubImage3D(r.TEXTURE_2D_ARRAY,0,0,0,n,e.tileWidth,e.tileHeight,1,r.RGBA,r.UNSIGNED_BYTE,0)}r.deleteBuffer(i),r.generateMipmap(r.TEXTURE_2D_ARRAY),r.texParameteri(r.TEXTURE_2D_ARRAY,r.TEXTURE_MAG_FILTER,r.NEAREST),r.texParameteri(r.TEXTURE_2D_ARRAY,r.TEXTURE_MIN_FILTER,r.NEAREST),this.texturesMap.set(t,{texture:a,tileset:e})}}class Y{constructor(e,t,s){this.gl=e,this.renderer=t,this.isStatic=s,this.needsUpdate=!0,this.drawCalls=[],this.lifetime=x,this.vao=e.createVertexArray(),e.bindVertexArray(this.vao),e.bindBuffer(e.ARRAY_BUFFER,t.getVBO()),e.enableVertexAttribArray(0),e.vertexAttribPointer(0,2,e.FLOAT,!1,16,0),e.enableVertexAttribArray(1),e.vertexAttribPointer(1,2,e.FLOAT,!1,16,8);const r=24;this.spriteBuffer=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.spriteBuffer),e.bufferData(e.ARRAY_BUFFER,(this.isStatic?f:b)*4*r,this.isStatic?e.STATIC_DRAW:e.DYNAMIC_DRAW),e.enableVertexAttribArray(2),e.vertexAttribPointer(2,2,e.FLOAT,!1,r,0),e.enableVertexAttribArray(3),e.vertexAttribPointer(3,2,e.FLOAT,!1,r,8),e.enableVertexAttribArray(4),e.vertexAttribIPointer(4,4,e.UNSIGNED_SHORT,r,16),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,t.getEBO()),e.bindVertexArray(null)}upload(e){const t=this.gl;t.bindBuffer(t.ARRAY_BUFFER,this.spriteBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,g.createSpritesData(e)),this.isStatic&&(this.needsUpdate=!1),this.drawCalls.length=0;let s=null;for(let r=0;r<e.length;++r){const i=e[r].tileset.name;!s||i!==s.texName?(s={texName:i,spriteOffset:r,spriteCount:1},this.drawCalls.push(s)):s.spriteCount++}}render(){const e=this.gl;e.bindVertexArray(this.vao);for(const t of this.drawCalls){const s=this.renderer.getTextureInfo(t.texName);e.bindTexture(e.TEXTURE_2D,s.texture),this.gl.uniform2f(this.renderer.getShaderProgram().getUniform("uTilesetDimensions"),s.tileset.imageWidth,s.tileset.imageHeight),e.drawElements(e.TRIANGLES,6*t.spriteCount,e.UNSIGNED_INT,t.spriteOffset*6*4)}e.bindVertexArray(null),this.lifetime=x}destroy(){this.gl.deleteBuffer(this.spriteBuffer),this.gl.deleteVertexArray(this.vao)}}const X=async()=>{const e=await(await navigator.gpu?.requestAdapter())?.requestDevice();if(!e)return null;const t=navigator.gpu.getPreferredCanvasFormat();return{device:e,format:t}},H=`
struct VSInput {
    @location(0) vertexPos: vec2f,
    @location(1) texCoord: vec2f,
    
    @location(2) tilePos: vec2f,
    @location(3) tileScale: vec2f,
    @location(4) tileRegion: vec2u
}

struct Camera {
    projectionMatrix: mat4x4f,
    viewMatrix: mat4x4f
}

@group(0) @binding(0)
var<uniform> camera: Camera;

@group(1) @binding(2)
var<uniform> tilesetDimensions: vec2f;

struct VSOutput {
    @builtin(position) pos: vec4f,
    @location(0) uv: vec2f,
}

@vertex
fn vs_main(input: VSInput) -> VSOutput {
    var out: VSOutput;

    let x = f32(input.tileRegion.x & 0xFFFFu);
    let y = f32(input.tileRegion.x >> 16);
    let w = f32(input.tileRegion.y & 0xFFFFu);
    let h = f32(input.tileRegion.y >> 16);

    let tileRegion = vec4f(x, y, w, h);

    out.uv = (tileRegion.xy + input.texCoord * tileRegion.zw) / tilesetDimensions;

    let worldPos = input.vertexPos * input.tileScale + input.tilePos;
    out.pos = camera.projectionMatrix * camera.viewMatrix * vec4f(worldPos, 0.0, 1.0);

    return out;
}

@group(1) @binding(0)
var spriteSampler: sampler;

@group(1) @binding(1)
var spriteTexture: texture_2d<f32>;

@fragment
fn fs_main(input: VSOutput) -> @location(0) vec4f {
    return textureSample(spriteTexture, spriteSampler, input.uv);
}
`;class z{constructor(e){this.layersMap=new Map,this.texturesMap=new Map,this.canvas=e,this.clearColor=new y(0,0,0,0),this.texturesInfo=[]}addTextures(e,t){for(const s of e)t[s.name]&&this.texturesInfo.push({tileset:s,image:t[s.name]})}setClearColor(e){this.clearColor.copy(e)}setSize(e,t){this.canvas.width=e,this.canvas.height=t}getCanvas(){return this.canvas}async init(){const e=await X();if(!e)throw new Error("WebGPU not supported");this.cfg=e;const t=this.cfg.device,s=this.canvas.getContext("webgpu");this.ctx=s,this.ctx.configure(this.cfg);for(const i of this.texturesInfo)i.tileset&&this.createTexture(i.tileset,i.tileset.name,i.image);const r=t.createShaderModule({code:H});this.pipeline=t.createRenderPipeline({layout:"auto",vertex:{module:r,entryPoint:"vs_main",buffers:[{arrayStride:16,stepMode:"vertex",attributes:[{shaderLocation:0,offset:0,format:"float32x2"},{shaderLocation:1,offset:8,format:"float32x2"}]},{arrayStride:24,stepMode:"instance",attributes:[{shaderLocation:2,offset:0,format:"float32x2"},{shaderLocation:3,offset:8,format:"float32x2"},{shaderLocation:4,offset:16,format:"uint32x2"}]}]},fragment:{module:r,entryPoint:"fs_main",targets:[{format:this.cfg.format,blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha",operation:"add"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"}}}]},primitive:{topology:"triangle-strip"}}),this.cameraBuffer=t.createBuffer({size:128,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),this.cameraBindGroup=t.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:this.cameraBuffer}}]}),this.sampler=t.createSampler({magFilter:"nearest",minFilter:"nearest",addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge"}),this.vbo=t.createBuffer({size:g.quad.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST}),t.queue.writeBuffer(this.vbo,0,g.quad)}render(e,t){const s=[];for(const n of e.getLayersOrdered()){if(!this.layersMap.has(n)){const o=new q(this,n.isStatic);this.layersMap.set(n,o)}const h=this.layersMap.get(n);h.needsUpdate&&h.upload(n.getSpritesOrdered()),s.push(h)}this.cfg.device.queue.writeBuffer(this.cameraBuffer,0,t.projectionMatrix),this.cfg.device.queue.writeBuffer(this.cameraBuffer,64,t.viewMatrix);const r=this.cfg.device.createCommandEncoder(),i=r.beginRenderPass({colorAttachments:[{clearValue:this.clearColor,view:this.ctx.getCurrentTexture().createView(),loadOp:"clear",storeOp:"store"}]});i.setPipeline(this.pipeline),i.setBindGroup(0,this.cameraBindGroup),i.setVertexBuffer(0,this.vbo);for(const n of s)n.render(i);i.end();const a=r.finish();this.cfg.device.queue.submit([a]);for(const[n,h]of this.layersMap)h.lifetime<=0&&(h.destroy(),this.layersMap.delete(n))}createTexture(e,t,s){const r=this.cfg.device.createTexture({size:{width:e.imageWidth,height:e.imageHeight,depthOrArrayLayers:1},format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT});this.cfg.device.queue.copyExternalImageToTexture,this.cfg.device.queue.copyExternalImageToTexture({source:s},{texture:r},[e.imageWidth,e.imageHeight,1]),this.texturesMap.set(t,{texture:r,tileset:e})}createTextureArray(e,t,s){const r=e.tileWidth,i=e.tileHeight,a=this.cfg.device.createTexture({size:{width:r,height:i,depthOrArrayLayers:e.tileCount},format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT});for(let n=0;n<e.tileCount;++n){const h=Math.floor(n/e.columns),o=n%e.columns,d=new Uint8Array(r*i*4);for(let m=0;m<i;++m){const E=((h*i+m)*e.columns+o)*r*4,v=E+r*4;d.set(s.slice(E,v),m*r*4)}this.cfg.device.queue.writeTexture({texture:a,origin:{x:0,y:0,z:n}},d,{bytesPerRow:r*4,rowsPerImage:i},{width:r,height:i,depthOrArrayLayers:1})}this.texturesMap.set(t,{texture:a,tileset:e})}getConfig(){return this.cfg}getTextureInfo(e){const t=this.texturesMap.get(e);if(!t)throw new Error("Texture not found: "+e);return t}getPipeline(){return this.pipeline}getSampler(){return this.sampler}}class q{constructor(e,t){this.renderer=e,this.isStatic=t,this.needsUpdate=!0,this.drawCalls=[],this.bindGroups=new Map,this.lifetime=x,this.lastTexIdx=0,this.instanceBuffer=e.getConfig().device.createBuffer({label:"Instance Buffer",size:24*(t?f:b),usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST}),this.tilesetDimBuffer=e.getConfig().device.createBuffer({label:"Tileset Dimensions Buffer",size:j*256,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST})}upload(e){const t=this.renderer.getConfig().device,s=this.renderer.getPipeline(),r=this.renderer.getSampler();t.queue.writeBuffer(this.instanceBuffer,0,g.createSpritesData(e,!0)),this.isStatic&&(this.needsUpdate=!1),this.drawCalls.length=0;let i=null;for(let a=0;a<e.length;++a){const n=e[a].tileset.name;if(!i||n!==i.texName){const h=this.renderer.getTextureInfo(n);t.queue.writeBuffer(this.tilesetDimBuffer,this.lastTexIdx*256,new Float32Array([h.tileset.imageWidth,h.tileset.imageHeight]));const o=t.createBindGroup({layout:s.getBindGroupLayout(1),entries:[{binding:0,resource:r},{binding:1,resource:h.texture.createView()},{binding:2,resource:{buffer:this.tilesetDimBuffer,offset:this.lastTexIdx*256,size:8}}]});i={texName:n,instanceOffset:a,instanceCount:1},this.bindGroups.has(i.texName)||(this.bindGroups.set(i.texName,o),++this.lastTexIdx),this.drawCalls.push(i)}else i.instanceCount++}}render(e){e.setVertexBuffer(1,this.instanceBuffer);for(const t of this.drawCalls)e.setBindGroup(1,this.bindGroups.get(t.texName)),e.draw(4,t.instanceCount,0,t.instanceOffset);this.lifetime=x}destroy(){this.instanceBuffer.destroy(),this.tilesetDimBuffer.destroy()}}const f=1e5,b=1e5,x=30,j=16,k=l=>{const e=document.createElement("canvas");switch(l){case"webgl":return new O(e);case"webgl2":return new W(e);case"webgpu":return new z(e);default:throw new Error("Unknwn renderer type")}};class P{constructor(e){this.zIndex=e.zIndex||0,this.tileset=e.tileset,this.tilesetRegion=e.tilesetRegion,this.isStatic=e.isStatic||!1,this.position=new u,this.offset=this.getOffsetFromOrigin(e.origin),this.scale=new u(1,1)}getOffsetFromOrigin(e){switch(e){case"bottom":return new u(0,.5);case"top":return new u(0,-.5);default:return new u}}}class K{constructor(){this.layers=[]}addSprite(e){let t=this.layers.find(s=>s.isStatic===e.isStatic&&s.zIndex===e.zIndex);t||(t=new C({zIndex:e.zIndex,isStatic:e.isStatic}),this.layers.push(t)),t.add(e)}addTilemap(e,t={}){const s=e.getLayers();let r=0;for(const i of s){const a=t.layers?.find(n=>n.name===i.name);switch(a?.zIndex&&(r=a.zIndex),i.renderOrder!=="manual"&&this.createLayer({zIndex:r,renderOrder:i.renderOrder,isStatic:!1}),i.type){case"tilelayer":{for(let n=0;n<i.height;++n)for(let h=0;h<i.width;++h){const o=i.getTile(h,n);if(!o)continue;const d=new P({isStatic:o.animation===void 0,zIndex:r,tileset:o.tileset,tilesetRegion:{x:o.x,y:o.y}});d.position.set((h+i.x+.5)*e.tileWidth,-(n+i.y+.5)*e.tileHeight),d.scale.set(e.tileWidth,e.tileHeight),this.addSprite(d)}break}case"objectgroup":{if(t.onObject){const n=i.getObjects();for(const h of n)t.onObject(this,h,i,r)}break}}++r}}createLayer(e){const t=new C(e);return this.layers.push(t),t}getLayersOrdered(){return this.layers.sort((e,t)=>e.zIndex-t.zIndex)}}class C{constructor(e){this.zIndex=e.zIndex,this.isStatic=e.isStatic,this.renderOrder=e.renderOrder||"manual",this.sprites=[]}add(e){if(this.renderOrder==="manual"){let t=-1;for(let s=this.sprites.length-1;s>=0;--s)if(this.sprites[s].tileset.name<=e.tileset.name){t=s;break}t===-1?this.sprites.unshift(e):this.sprites.splice(t+1,0,e)}else this.sprites.push(e)}getSpritesOrdered(){switch(this.renderOrder){case"topdown":return this.sprites.sort((e,t)=>t.position.y-e.position.y);default:return this.sprites}}}class ${constructor(e,t,s,r){this.tileset=e,this.x=t,this.y=s,this.properties=r?.properties,this.animation=r?.animation}getProperty(e){return this.properties?.find(t=>t.name===e)??null}}const R=class R{constructor(e){if(this.name=e.name,this.imageWidth=e.imagewidth,this.imageHeight=e.imageheight,this.tileWidth=e.tilewidth,this.tileHeight=e.tileheight,this.columns=e.columns,this.tileCount=e.tilecount,this.margin=e.margin||0,this.spacing=e.spacing||0,this.tiledata=new Map,e.tiles)for(let t of e.tiles)this.tiledata.set(t.id,t)}static async load(e){if(!this.cache.has(e)){const t=await A.loadJson(e);this.cache.set(e,new R(t))}return this.cache.get(e)}static getByName(e){return this.cache.values().find(t=>t.name===e)||null}getTile(e,t){const s=this.tiledata.get(t*this.columns+e);return new $(this,e,t,s)}getTileById(e){if(e>=this.tileCount||e<0)return null;const t=e%this.columns,s=Math.floor(e/this.columns);return this.getTile(t,s)}};R.cache=new Map;let T=R;class U{constructor(e){this.name=e.name,this.x=e.x,this.y=e.y,this.width=e.width,this.height=e.height,this.type=e.type,this.renderOrder=e.draworder||"manual"}}class J extends U{constructor(e){super(e),this.data=e.data}getTile(e,t){const s=this.data[t*this.width+e];return s-1==-1?null:this.tilemap.getTileById(s)}}class Q extends U{constructor(e){super(e),this.objects=e.objects}getObjects(){return this.objects}}class S{constructor(e,t,s,r){this.width=e,this.height=t,this.tileWidth=s,this.tileHeight=r,this.tilesets=[],this.layers=[]}static async load(e,t){const s=await A.loadJson(e),r=new S(s.width,s.height,s.tilewidth,s.tileheight);for(const i of s.layers)switch(i.type){case"tilelayer":r.addLayer(new J(i));break;case"objectgroup":r.addLayer(new Q(i));break}for(let i of s.tilesets){let a;if(i.source){const n=i.source.split(/(\/|\\\/)/),h=n[n.length-1].split(".tsj")[0];if(!t[h])throw new Error("Source is missing for tileset: "+h);a=await T.load(t[h])}else a=new T(i);r.tilesets.push({tileset:a,firstGlobalId:i.firstgid})}return r}addLayer(e){e.tilemap=this,this.layers.push(e)}getTilesets(){return this.tilesets.map(e=>e.tileset)}getTilesetByName(e){return this.tilesets.find(t=>t.tileset.name===e)?.tileset||null}getLayers(){return this.layers}getLayerByName(e){return this.layers.find(t=>t.name===e)||null}getTileById(e){const t=this.tilesets;for(let s of t){let r=s.tileset.getTileById(e-s.firstGlobalId);if(r)return r}return null}}return c.Camera=L,c.Color=y,c.LinearSpline=M,c.LinearSplineVector=I,c.Scene=K,c.Sprite=P,c.Tilemap=S,c.Tileset=T,c.Vector=u,c.assets=A,c.createRenderer=k,c.math=w,c.matrix=p,Object.defineProperty(c,Symbol.toStringTag,{value:"Module"}),c})({});
