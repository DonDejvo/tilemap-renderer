(function(v,B){typeof exports=="object"&&typeof module<"u"?B(exports):typeof define=="function"&&define.amd?define(["exports"],B):(v=typeof globalThis<"u"?globalThis:v||self,B(v.TilemapRenderer={}))})(this,(function(v){"use strict";class B{constructor(e){this.repeat=!0,this.currentFrameIndex=0,this.frameTimer=0,this.sprite=e,this.animation=null}play(e,t={}){const i=this.sprite.tileset.getTile(e.x,e.y);if(!i)return;const s=i.animation||[{tileid:i.id,duration:100}];if(!t.restart&&this.animation===s)return;this.animation=s,this.repeat=t.repeat??!0,this.currentFrameIndex=0,this.frameTimer=0;const r=this.animation[0],o=this.sprite.tileset.getTileXY(r.tileid);this.sprite.setTilesetRegion(o.x,o.y)}update(e){if(!this.animation)return;const t=this.animation[this.currentFrameIndex];if(this.frameTimer+=e*1e3,this.frameTimer<t.duration)return;if(this.frameTimer-=t.duration,this.currentFrameIndex++,this.currentFrameIndex>=this.animation.length)if(this.repeat)this.currentFrameIndex=0;else{this.currentFrameIndex=this.animation.length-1,this.onEnded?.(this.animation),this.animation=null;return}const i=this.animation[this.currentFrameIndex],s=this.sprite.tileset.getTileXY(i.tileid);this.sprite.setTilesetRegion(s.x,s.y)}}const k={loadImage:t=>new Promise((i,s)=>{const r=new Image;r.crossOrigin="anonymous",r.src=t,r.onload=()=>{i(r)},r.onerror=()=>{s()}}),loadJson:async t=>{try{return await(await fetch(t)).json()}catch{throw new Error(`Failed to load: ${t}`)}}},w=(()=>{const c=(o,a,n)=>Math.min(Math.max(o,a),n);return{clamp:c,lerp:(o,a,n)=>o+(a-o)*n,unlerp:(o,a,n)=>c((n-o)/(a-o),0,1),sat:o=>c(o,0,1),degToRad:o=>o/180*Math.PI,radToDeg:o=>o/Math.PI*180}})();class pe{constructor(e=[]){this.points=e}addPoint(e){this.points.push(e)}getValue(e){const t=this.points.length;if(t===0)return 0;if(e<=0)return this.points[0];if(e>=t-1)return this.points[t-1];const i=Math.floor(e),s=e-i;return w.lerp(this.points[i],this.points[i+1],s)}}class x{constructor(e=0,t=0){this.x=e,this.y=t}set(e,t){return this.x=e,this.y=t,this}copy(e){return this.x=e.x,this.y=e.y,this}clone(){return new x(this.x,this.y)}add(e){return this.x+=e.x,this.y+=e.y,this}sub(e){return this.x-=e.x,this.y-=e.y,this}scale(e){return this.x*=e,this.y*=e,this}mul(e){return this.x*=e.x,this.y*=e.y,this}div(e){return e!==0?(this.x/=e,this.y/=e):(this.x=0,this.y=0),this}static dot(e,t){return e.x*t.x+e.y*t.y}static cross(e,t){return e.x*t.y-e.y*t.x}len(){return Math.sqrt(this.x*this.x+this.y*this.y)}lenSq(){return this.x*this.x+this.y*this.y}normalize(){const e=this.len();return e>0&&this.div(e),this}project(e){const t=e.lenSq();if(t===0)return this.scale(0);const i=x.dot(this,e);return this.copy(e).scale(i/t)}static distance(e,t){const i=e.x-t.x,s=e.y-t.y;return Math.sqrt(i*i+s*s)}angle(){return Math.atan2(this.y,this.x)}rot(e){const t=Math.cos(e),i=Math.sin(e),s=this.x*t-this.y*i,r=this.x*i+this.y*t;return this.x=s,this.y=r,this}static fromAngle(e,t=1){return new x(-Math.sin(e)*t,Math.cos(e)*t)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this}toString(){return`Vector(${this.x}, ${this.y})`}toArray(){return new Float32Array([this.x,this.y])}}class xe{constructor(e=[]){this.points=e.slice().sort((t,i)=>t.x-i.x)}addPoint(e){this.points.push(e),this.points.sort((t,i)=>t.x-i.x)}getValue(e){const t=this.points.length;if(t===0)return new x;if(e<=this.points[0].x)return this.points[0].clone();if(e>=this.points[t-1].x)return this.points[t-1].clone();for(let i=0;i<t-1;i++){const s=this.points[i],r=this.points[i+1];if(e>=s.x&&e<=r.x){const o=w.unlerp(s.x,r.x,e);return s.clone().lerp(r,o)}}return new x}}class ve{constructor(e,t){this.position=new x,this.vw=0,this.vh=0,this.updateProjection(e,t)}updateProjection(e,t){this.vw=e,this.vh=t}getBounds(){return{min:this.position.clone(),max:this.position.clone().add(new x(this.vw,this.vh))}}}class ne{constructor(){this.position=new x}}class be extends ne{constructor(e){super(),this.radius=e}getType(){return"circle"}getBounds(){const e=new x(this.radius,this.radius);return{min:this.position.clone().sub(e),max:this.position.clone().add(e)}}}class ae extends ne{constructor(e){super(),this.points=e}getType(){return"polygon"}getBounds(){let e=1/0,t=1/0,i=-1/0,s=-1/0;for(const r of this.points){const o=r.x+this.position.x,a=r.y+this.position.y;o<e&&(e=o),a<t&&(t=a),o>i&&(i=o),a>s&&(s=a)}return{min:new x(e,t),max:new x(i,s)}}}class ye extends ae{constructor(e,t){const i=e*.5,s=t*.5,r=[new x(-i,-s),new x(i,-s),new x(i,s),new x(-i,s)];super(r),this.width=e,this.height=t}}const we={CircleCollider:be,PolygonCollider:ae,BoxCollider:ye};class C{constructor(e,t,i,s=1){this.r=e,this.g=t,this.b=i,this.a=s}set(e,t,i,s){this.r=e,this.g=t,this.b=i,this.a=s}copy(e){this.r=e.r,this.g=e.g,this.b=e.b,this.a=e.a}toArray(){return new Float32Array([this.r,this.g,this.b,this.a])}}class Te{constructor(e){this.position=e.position||new x,this.color=e.color||new C(1,1,1),this.intensity=e.intensity||1,this.radius=e.radius,this.direction=e.direction||new x(0,1),this.cutoff=e.cutoff||0,this.isStatic=e.isStatic||!1}getBounds(){const e=new x(this.radius,this.radius);return{min:this.position.clone().sub(e),max:this.position.clone().add(e)}}}const Ce={create:()=>new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]),identity:r=>(r[0]=1,r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[5]=1,r[6]=0,r[7]=0,r[8]=0,r[9]=0,r[10]=1,r[11]=0,r[12]=0,r[13]=0,r[14]=0,r[15]=1,r),createOrtho:(r,o,a,n,l)=>(r[0]=2/(a-o),r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[5]=2/(l-n),r[6]=0,r[7]=0,r[8]=0,r[9]=0,r[10]=1,r[11]=0,r[12]=-(a+o)/(a-o),r[13]=-(l+n)/(l-n),r[14]=0,r[15]=1,r),translate:(r,o)=>(r[12]+=o.x,r[13]+=o.y,r),scale:(r,o)=>(r[0]*=o.x,r[1]*=o.x,r[4]*=o.y,r[5]*=o.y,r)},F=(c,e)=>(e.min.x-c.max.x)*(e.max.x-c.min.x)<0&&(e.min.y-c.max.y)*(e.max.y-c.min.y)<0,b=(()=>{const c=new Float32Array([0,1,0,0,0,0,0,1,1,1,1,0,1,0,1,1]),e=new Float32Array([-1,1,0,0,-1,-1,0,1,1,1,1,0,1,-1,1,1]),t=68,i=(l,h=!1)=>{const u=h?1:4,d=t,m=new ArrayBuffer(l.length*u*d),f=new DataView(m);let p=0;for(const g of l){const O=g.position.x,R=g.position.y,E=g.scale.x,re=g.scale.y,se=g.angle,oe=g.tilesetRegion.x*(g.tileset.tileWidth+g.tileset.spacing)+g.tileset.margin,V=g.tilesetRegion.y*(g.tileset.tileHeight+g.tileset.spacing)+g.tileset.margin,z=g.tileset.tileWidth+((g.tilesetRegion.width||1)-1)*(g.tileset.tileWidth+g.tileset.spacing),mt=g.tileset.tileHeight+((g.tilesetRegion.height||1)-1)*(g.tileset.tileHeight+g.tileset.spacing);for(let me=0;me<u;++me)f.setFloat32(p,O,!0),f.setFloat32(p+4,R,!0),f.setFloat32(p+8,E,!0),f.setFloat32(p+12,re,!0),f.setFloat32(p+16,se,!0),f.setUint16(p+20,oe,!0),f.setUint16(p+22,V,!0),f.setUint16(p+24,z,!0),f.setUint16(p+26,mt,!0),f.setFloat32(p+28,g.tintColor.r,!0),f.setFloat32(p+32,g.tintColor.g,!0),f.setFloat32(p+36,g.tintColor.b,!0),f.setFloat32(p+40,g.tintColor.a,!0),f.setFloat32(p+44,g.maskColor.r,!0),f.setFloat32(p+48,g.maskColor.g,!0),f.setFloat32(p+52,g.maskColor.b,!0),f.setFloat32(p+56,g.maskColor.a,!0),f.setFloat32(p+60,g.offset.x,!0),f.setFloat32(p+64,g.offset.y,!0),p+=d}return m},s=48,r=(l,h=!1)=>{const u=h?1:4,d=new Float32Array(l.length*64);let m=0;for(let f of l)for(let p=0;p<u;++p)d.set(f.position.toArray(),m),d[m+2]=f.radius,d.set(f.color.toArray(),m+4),d[m+7]=f.intensity,d.set(f.direction.toArray(),m+8),d[m+10]=f.cutoff,m+=64;return d},o=(l,h)=>{const u=h.position.clone().sub(l.position).normalize(),d=new x(-u.y,u.x).scale(h.radius),m=h.position.clone().sub(d),f=h.position.clone().add(d),p=m.clone().sub(l.position).normalize(),g=f.clone().sub(l.position).normalize(),O=l.radius,R=m.clone().add(p.scale(O)),E=f.clone().add(g.scale(O));return[m.x,m.y,f.x,f.y,R.x,R.y,R.x,R.y,f.x,f.y,E.x,E.y]},a=(l,h)=>{const u=[],d=l.radius,m=h.points.map(f=>f.clone().add(h.position));for(let f=0;f<m.length;f++){const p=m[f],g=m[(f+1)%m.length],R=p.clone().add(g).scale(.5).clone().sub(l.position).normalize(),E=g.clone().sub(p).normalize(),re=new x(-E.y,E.x);if(x.dot(re,R)<=0)continue;const se=p.clone().sub(l.position).normalize(),oe=g.clone().sub(l.position).normalize(),V=p.clone().add(se.scale(d*100)),z=g.clone().add(oe.scale(d*100));u.push(p.x,p.y,g.x,g.y,V.x,V.y,V.x,V.y,g.x,g.y,z.x,z.y)}return u};return{quad:c,fullscreenQuad:e,spriteStride:t,createSpritesData:i,lightStride:s,createLightsGeometry:r,createShadowsGeometry:(l,h,u,d=0)=>{for(let m of u){let f=[];switch(m.getType()){case"circle":f=o(h,m);break;case"polygon":f=a(h,m);break}l.set(f,d),d+=f.length}return d}}})(),Ae=c=>{switch(c){case"float":return 1;case"vec2":return 2;case"vec3":return 3;case"vec4":return 4}};class M{constructor(){this.ops=[],this.uniforms=[],this.uniformOffset=0,this.uniform("resolution","vec2"),this.uniform("time","float")}declare(e,t){return this.ops.push([0,e,t]),this}set(e,t){return this.ops.push([1,e,t]),this}add(e,t){return this.ops.push([2,e,t]),this}sub(e,t){return this.ops.push([3,e,t]),this}mul(e,t){return this.ops.push([4,e,t]),this}div(e,t){return this.ops.push([5,e,t]),this}if(e){return this.ops.push([7,e]),this}elseif(e){return this.ops.push([8,e]),this}else(){return this.ops.push([9]),this}endif(){return this.ops.push([10]),this}uniform(e,t){return this.uniforms.push({name:e,type:t,offset:this.uniformOffset}),this.uniformOffset+=Ae(t),this}getUniforms(){return this.uniforms}build(e){const t=[];for(const i of this.ops){const[s,...r]=i;switch(s){case 0:{const[o,a,n]=i,l=e.getBuilderOptions().declareVar(a,n);t.push(l);break}case 1:case 2:case 3:case 4:case 5:{const o=r[0],a=r[1],n=`${o} ${this.getOpAssignmentSymbol(s)} ${a};`;t.push(this.replaceExpression(e,n));break}case 7:case 8:{const o=r[0];t.push(`${s===7?"":"} else "}if (${this.replaceExpression(e,o)}) {`);break}case 9:case 10:{t.push("}"+(s===10?"":" else {"));break}}}return{mainImage:t,uniforms:this.uniforms.map(i=>e.getBuilderOptions().declareVar(i.name,i.type,!0))}}getOpAssignmentSymbol(e){switch(e){case 1:return"=";case 2:return"+=";case 3:return"-=";case 4:return"*=";case 5:return"/=";default:return""}}replaceExpression(e,t){if(e.getType()!=="webgpu")for(let i=0;i<L;++i)t=t.replace(new RegExp("texture\\s*\\(\\s*"+i+"\\s*,","g"),"texture(uChannel"+i+", ");return this.replaceComponents(e,t)}replaceComponents(e,t){const i=e.getBuilderOptions().componentMap;return t.replace(/\.[rgba]{1,4}\b/g,s=>{const r=s.substring(1);let o=".";for(let a=0;a<r.length;++a){const n=r[a];o+=i[n]??n}return o})}}const U=new M().declare("uv","vec2").set("uv","fragCoord / uniforms.resolution").add("fragColor","texture(0, uv)"),Y=new M().declare("uv","vec2").declare("baseColor","vec4").set("uv","fragCoord / uniforms.resolution").set("baseColor","texture(0, uv)").add("fragColor","vec4(baseColor.rgb * texture(1, uv).rgb, baseColor.a)"),H=new M().declare("uv","vec2").declare("w","float").declare("sum","vec4").set("uv","fragCoord / uniforms.resolution").set("w","1.0 / uniforms.resolution.x").set("sum",`(
    texture(0, uv + vec2(-3.0 * w, 0.0)) * 0.05 +
    texture(0, uv + vec2(-2.0 * w, 0.0)) * 0.1 +
    texture(0, uv + vec2(-1.0 * w, 0.0)) * 0.2 +
    texture(0, uv) * 0.3 +
    texture(0, uv + vec2(1.0 * w, 0.0)) * 0.2 +
    texture(0, uv + vec2(2.0 * w, 0.0)) * 0.1 +
    texture(0, uv + vec2(3.0 * w, 0.0)) * 0.05
)`).set("fragColor","sum"),W=new M().declare("uv","vec2").declare("h","float").declare("sum","vec4").set("uv","fragCoord / uniforms.resolution").set("h","1.0 / uniforms.resolution.y").set("sum",`(
    texture(0, uv + vec2(0.0, -3.0 * h)) * 0.05 +
    texture(0, uv + vec2(0.0, -2.0 * h)) * 0.1 +
    texture(0, uv + vec2(0.0, -1.0 * h)) * 0.2 +
    texture(0, uv) * 0.3 +
    texture(0, uv + vec2(0.0, 1.0 * h)) * 0.2 +
    texture(0, uv + vec2(0.0, 2.0 * h)) * 0.1 +
    texture(0, uv + vec2(0.0, 3.0 * h)) * 0.05
)`).set("fragColor","sum");class le{constructor(e,t,i,s,r){this.tileset=e,this.id=t,this.x=i,this.y=s,this.properties=r?.properties,this.animation=r?.animation}getProperty(e){return this.properties?.find(t=>t.name===e)?.value}}const N=class N{constructor(e){if(this.name=e.name,this.imageWidth=e.imagewidth,this.imageHeight=e.imageheight,this.tileWidth=e.tilewidth,this.tileHeight=e.tileheight,this.columns=e.columns,this.tileCount=e.tilecount,this.margin=e.margin||0,this.spacing=e.spacing||0,this.tiledata=new Map,e.tiles)for(let t of e.tiles)this.tiledata.set(t.id,t)}static async load(e){if(!this.cache.has(e)){const t=await k.loadJson(e);this.cache.set(e,new N(t))}return this.cache.get(e)}static getByName(e){return this.cache.values().find(t=>t.name===e)||null}getTile(e,t){if(e<0||e>=this.columns||t<0||t>=Math.ceil(this.tileCount/this.columns))return null;const i=t*this.columns+e,s=this.tiledata.get(i);return new le(this,i,e,t,s)}getTileById(e){if(e>=this.tileCount||e<0)return null;const t=e%this.columns,i=Math.floor(e/this.columns),s=this.tiledata.get(e);return new le(this,e,t,i,s)}getTileXY(e){const t=e%this.columns,i=Math.floor(e/this.columns);return{x:t,y:i}}};N.cache=new Map;let P=N;class he{constructor(e,t,i){this.gl=e,this.width=t,this.height=i,this.texture=e.createTexture(),e.bindTexture(e.TEXTURE_2D,this.texture),e.texImage2D(e.TEXTURE_2D,0,e.RGBA,t,i,0,e.RGBA,e.UNSIGNED_BYTE,null),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.LINEAR),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.LINEAR),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),this.fbo=e.createFramebuffer(),e.bindFramebuffer(e.FRAMEBUFFER,this.fbo),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,this.texture,0),e.checkFramebufferStatus(e.FRAMEBUFFER)!==e.FRAMEBUFFER_COMPLETE&&console.error("Framebuffer incomplete!"),e.bindFramebuffer(e.FRAMEBUFFER,null),e.bindTexture(e.TEXTURE_2D,null)}bind(){this.gl.bindFramebuffer(this.gl.FRAMEBUFFER,this.fbo),this.gl.viewport(0,0,this.width,this.height)}unbind(){this.gl.bindFramebuffer(this.gl.FRAMEBUFFER,null)}destroy(){this.gl.deleteFramebuffer(this.fbo),this.gl.deleteTexture(this.texture)}}class A{constructor(e,t,i){this.gl=e,this.uniforms=new Map,this.attribs=new Map;const s=this.compileShader(e.VERTEX_SHADER,t),r=this.compileShader(e.FRAGMENT_SHADER,i);if(this.program=e.createProgram(),e.attachShader(this.program,s),e.attachShader(this.program,r),e.linkProgram(this.program),!e.getProgramParameter(this.program,e.LINK_STATUS))throw new Error(e.getProgramInfoLog(this.program)??"Could not link program");e.deleteShader(s),e.deleteShader(r)}compileShader(e,t){const i=this.gl.createShader(e);if(!i)throw new Error("Could not create shader");if(this.gl.shaderSource(i,t),this.gl.compileShader(i),!this.gl.getShaderParameter(i,this.gl.COMPILE_STATUS))throw new Error(this.gl.getShaderInfoLog(i)??"Could not compile shader");return i}use(){this.gl.useProgram(this.program)}getUniform(e){if(!this.uniforms.has(e)){const t=this.gl.getUniformLocation(this.program,e);this.uniforms.set(e,t)}return this.uniforms.get(e)}getAttrib(e){return this.attribs.has(e)||this.attribs.set(e,this.gl.getAttribLocation(this.program,e)),this.attribs.get(e)}}const $=`
vec4 worldToClip(vec2 worldPos, vec2 cameraPos, vec2 viewport) {
    vec2 pixelPos = worldPos - cameraPos;
    vec2 clipPos = vec2(pixelPos.x / viewport.x, 1.0 - pixelPos.y / viewport.y) * 2.0 - 1.0;
    return vec4(clipPos, 0.0, 1.0);
}
`,ue=`

attribute vec2 aVertexPos;
attribute vec2 aTexCoord;
attribute vec2 aTilePos;
attribute float aTileAngle;
attribute vec2 aTileScale;
attribute vec4 aTileRegion;
attribute vec4 aTintColor;
attribute vec4 aMaskColor;
attribute vec2 aTileOffset;

uniform vec2 uViewportDimensions;
uniform vec2 uCameraPos;

uniform vec2 uTilesetDimensions;

varying vec2 uv;
varying vec4 tintColor;
varying vec4 maskColor;

${$}

void main() {
    tintColor = aTintColor;
    maskColor = aMaskColor;

    vec2 flippedTexCoord = vec2(aTexCoord.x, 1.0 - aTexCoord.y);
    uv = (vec2(aTileRegion.xy) + flippedTexCoord * vec2(aTileRegion.zw)) / uTilesetDimensions;

    float c = cos(aTileAngle);
    float s = sin(aTileAngle);
    vec2 offsetPos = aVertexPos * aTileScale + aTileOffset;
    vec2 rotatedPos = vec2(
        offsetPos.x * c - offsetPos.y * s,
        offsetPos.x * s + offsetPos.y * c
    );
    vec2 worldPos = rotatedPos + aTilePos;

    gl_Position = worldToClip(worldPos, uCameraPos, uViewportDimensions);
}
`,Pe=`

precision mediump float;

varying vec2 uv;
varying vec4 tintColor;

uniform sampler2D uSampler;  

void main() {
    gl_FragColor = texture2D(uSampler, uv) * tintColor;
}
`,Re=`

precision mediump float;

varying vec2 uv;
varying vec4 maskColor;

uniform mediump sampler2D uSampler;  

void main() {
    vec4 texColor = texture2D(uSampler, uv);
    gl_FragColor = vec4(maskColor.rgb, texColor.a * maskColor.a);
}
`,Se=`
precision mediump float;

attribute vec2 aVertexPos;

uniform vec2 uLightCenter;
uniform float uLightRadius;

uniform vec2 uCameraPos;
uniform vec2 uViewportDimensions;

varying vec2 worldPos;

${$}

void main() {
    worldPos = uLightCenter + (aVertexPos - 0.5) * 2.0 * uLightRadius;

    gl_Position = worldToClip(worldPos, uCameraPos, uViewportDimensions);
}
`,Ee=`

precision mediump float;

varying vec2 worldPos;

uniform vec2 uLightCenter;
uniform float uLightRadius;
uniform vec3 uLightColor;
uniform float uLightIntensity;
uniform vec2 uLightDir;
uniform float uLightCutoff;

void main() {
    vec2 toPixel = worldPos - uLightCenter;
    float dist = length(toPixel);

    float attenuation = clamp(1.0 - pow(dist / uLightRadius, 2.0), 0.0, 1.0);

    float spotFactor = 1.0;
    if (uLightCutoff > 0.0) {
        float cosAngle = dot(normalize(uLightDir), normalize(toPixel));
        spotFactor = clamp((cosAngle - uLightCutoff) / (1.0 - uLightCutoff), 0.0, 1.0);
    }

    gl_FragColor = vec4(uLightColor * uLightIntensity * attenuation * spotFactor, 1.0);
}
`,Be=`
attribute vec2 aPos;

uniform vec2 uCameraPos;
uniform vec2 uViewportDimensions;

${$}

void main() {
    gl_Position = worldToClip(aPos, uCameraPos, uViewportDimensions);
}
`,Fe=`
precision mediump float;

uniform vec2 uLightPos;

void main() {
    gl_FragColor = vec4(vec3(0.0), 1.0);
}
`,Ue=`

attribute vec2 aPos;

void main() {
    gl_Position = vec4(aPos, 0.0, 1.0);
}
`,_e=c=>`
#define texture texture2D

precision mediump float;

struct Uniforms {
${c.uniforms.map(e=>"    "+e).join(`
`)}
};

uniform sampler2D uChannel0;
uniform sampler2D uChannel1;
uniform sampler2D uChannel2;
uniform sampler2D uChannel3;
uniform sampler2D uChannel4;
uniform sampler2D uChannel5;
uniform sampler2D uChannel6;
uniform sampler2D uChannel7;

uniform Uniforms uniforms;

void mainImage(out vec4 fragColor, in vec2 fragCoord) {
${c.mainImage.map(e=>"    "+e).join(`
`)}
}

void main() {
    vec2 fragCoord = vec2(gl_FragCoord.x, gl_FragCoord.y);
    mainImage(gl_FragColor, fragCoord);
}
`,Le={componentMap:{r:"r",g:"g",b:"b",a:"a"},declareVar:(c,e)=>`${e} ${c};`};class Ie{constructor(e){this.canvas=e,this.layersMap=new Map,this.texturesMap=new Map,this.clearColor=new C(0,0,0,0),this.shaderMap=new Map,this.initialized=!1,this.pass=[J],this.framebuffers=[],this.shaderCache=new Map,this.time=0}getType(){return"webgl"}getBuilderOptions(){return Le}addTextures(e,t){for(const i of e)t[i.name]&&this.texturesMap.set(i.name,{tileset:i,image:t[i.name]})}addImageTextures(e){for(let t of e){const i=new P({name:t.name,tilecount:1,columns:1,tilewidth:t.width,tileheight:t.height,imagewidth:t.width,imageheight:t.height});this.texturesMap.set(t.name,{tileset:i,image:t.image})}}registerShader(e,t,i="none"){this.shaderMap.set(e,{builder:t,blendMode:i})}setClearColor(e){this.clearColor.copy(e)}setSize(e,t){this.canvas.width=e,this.canvas.height=t,this.initialized&&this.initFramebuffers()}getCanvas(){return this.canvas}initFramebuffers(){for(let e=0;e<T;++e){const t=Q(e);this.framebuffers[e]?.destroy(),this.framebuffers[e]=new he(this.gl,this.canvas.width*t,this.canvas.height*t)}}blend(e){switch(e){case"alpha":this.gl.enable(this.gl.BLEND),this.gl.blendFunc(this.gl.SRC_ALPHA,this.gl.ONE_MINUS_SRC_ALPHA);break;case"additive":this.gl.enable(this.gl.BLEND),this.gl.blendFunc(this.gl.ONE,this.gl.ONE);break;default:this.gl.disable(this.gl.BLEND)}}async init(){const e=this.canvas.getContext("webgl");if(!e)throw new Error("WebGL not supported");this.gl=e;for(const r of this.texturesMap.values())r.tileset&&(r.texture=this.createTexture(r.image));this.registerShader("default",U),this.registerShader("default_additive",U,"additive"),this.registerShader("light",Y),this.registerShader("blurHorizontal",H),this.registerShader("blurVertical",W);for(const r of this.shaderMap.values()){if(!this.shaderCache.has(r.builder)){const o=r.builder.build(this),a=new A(e,Ue,_e(o));this.shaderCache.set(r.builder,a)}r.shader=this.shaderCache.get(r.builder)}this.shaderProgram=new A(e,ue,Pe),this.maskShaderProgram=new A(e,ue,Re),this.lightShaderProgram=new A(e,Se,Ee),this.shadowShaderProgram=new A(e,Be,Fe),this.vbo=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.vbo);const t=new Float32Array(S*4*4);for(let r=0;r<S;++r)t.set(b.quad,r*4*4);e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW);const i=[0,1,2,1,2,3];this.ebo=e.createBuffer(),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,this.ebo);const s=new Uint16Array(S*6);for(let r=0;r<S;++r)for(let o=0;o<6;++o)s[r*6+o]=i[o]+4*r;e.bufferData(e.ELEMENT_ARRAY_BUFFER,s,e.STATIC_DRAW),this.initFramebuffers(),this.fullscreenVbo=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.fullscreenVbo),e.bufferData(e.ARRAY_BUFFER,b.fullscreenQuad,e.STATIC_DRAW),this.shadowsVbo=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.shadowsVbo),e.bufferData(e.ARRAY_BUFFER,G*I*8,e.DYNAMIC_DRAW),this.initialized=!0}renderScene(e,t,i,s,r){e.bind(),this.blend("alpha"),s&&(this.gl.clearColor(s.r,s.g,s.b,s.a),this.gl.clear(this.gl.COLOR_BUFFER_BIT)),this.gl.activeTexture(this.gl.TEXTURE0),t.use(),this.gl.uniform2f(t.getUniform("uViewportDimensions"),i.vw,i.vh),this.gl.uniform2f(t.getUniform("uCameraPos"),i.position.x,i.position.y);for(let o of r)o.render(t);e.unbind()}renderLights(e,t){const i=t.getBounds(),s=e.getLights().filter(h=>F(i,h.getBounds())),r=new Float32Array(s.length*I*2),o=[];let a=0;for(let h of s){const u=e.getColliders(h.getBounds()),d=b.createShadowsGeometry(r,h,u,a);o.push({count:(d-a)/2,offset:a/2}),a=d}this.gl.bindBuffer(this.gl.ARRAY_BUFFER,this.shadowsVbo),this.gl.bufferSubData(this.gl.ARRAY_BUFFER,0,r),this.framebuffers[y].bind(),this.gl.clearColor(e.ambientColor.r*e.ambientIntensity,e.ambientColor.g*e.ambientIntensity,e.ambientColor.b*e.ambientIntensity,1),this.gl.clear(this.gl.COLOR_BUFFER_BIT),this.framebuffers[y].unbind();const n=this.lightShaderProgram.getAttrib("aVertexPos"),l=this.shadowShaderProgram.getAttrib("aPos");for(let h=0;h<s.length;++h){const u=s[h];this.framebuffers[y+1].bind(),this.blend("none"),this.gl.clearColor(0,0,0,1),this.gl.clear(this.gl.COLOR_BUFFER_BIT),this.lightShaderProgram.use(),this.gl.uniform2f(this.lightShaderProgram.getUniform("uViewportDimensions"),t.vw,t.vh),this.gl.uniform2f(this.lightShaderProgram.getUniform("uCameraPos"),t.position.x,t.position.y),this.gl.uniform2f(this.lightShaderProgram.getUniform("uLightCenter"),u.position.x,u.position.y),this.gl.uniform1f(this.lightShaderProgram.getUniform("uLightRadius"),u.radius),this.gl.uniform3f(this.lightShaderProgram.getUniform("uLightColor"),u.color.r,u.color.g,u.color.b),this.gl.uniform1f(this.lightShaderProgram.getUniform("uLightIntensity"),u.intensity),this.gl.uniform2f(this.lightShaderProgram.getUniform("uLightDir"),u.direction.x,u.direction.y),this.gl.uniform1f(this.lightShaderProgram.getUniform("uLightCutoff"),u.cutoff),this.gl.bindBuffer(this.gl.ARRAY_BUFFER,this.vbo),this.gl.enableVertexAttribArray(n),this.gl.vertexAttribPointer(n,2,this.gl.FLOAT,!1,16,0),this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),this.gl.disableVertexAttribArray(n);const d=o[h];d.count!==0&&(this.shadowShaderProgram.use(),this.gl.uniform2f(this.shadowShaderProgram.getUniform("uViewportDimensions"),t.vw,t.vh),this.gl.uniform2fv(this.shadowShaderProgram.getUniform("uCameraPos"),t.position.toArray()),this.gl.uniform2fv(this.shadowShaderProgram.getUniform("uLightPos"),u.position.toArray()),this.gl.bindBuffer(this.gl.ARRAY_BUFFER,this.shadowsVbo),this.gl.enableVertexAttribArray(l),this.gl.vertexAttribPointer(l,2,this.gl.FLOAT,!1,8,0),this.gl.drawArrays(this.gl.TRIANGLES,d.offset,d.count),this.gl.disableVertexAttribArray(l)),this.framebuffers[y+1].unbind(),this.renderFullscreenPass({shader:"blurHorizontal",inputs:[y+1],output:4}),this.renderFullscreenPass({shader:"blurVertical",inputs:[4],output:5}),this.renderFullscreenPass({shader:"default_additive",inputs:[5],output:y})}}renderFullscreenPass(e){const t=this.shaderMap.get(e.shader);if(!t)throw new Error("Unknown shader "+e.shader);e.clearColor&&(this.gl.clearColor(this.clearColor.r,this.clearColor.g,this.clearColor.b,this.clearColor.a),this.gl.clear(this.gl.COLOR_BUFFER_BIT));const i=t.shader;let s=this.canvas.width,r=this.canvas.height;if(e.output!==-1){const l=this.framebuffers[w.clamp(e.output,0,T-1)];s=l.width,r=l.height,l.bind()}else this.gl.viewport(0,0,s,r);this.blend(t.blendMode),i.use();const o=[{name:"time",value:this.time},{name:"resolution",value:[s,r]}].concat(e.uniforms??[]),a=t.builder.getUniforms();for(let l of a){const h=o.find(u=>u.name===l.name);if(h){const u=typeof h.value=="number"?[h.value]:h.value,d=i.getUniform("uniforms."+l.name);switch(l.type){case"float":this.gl.uniform1f(d,u[0]);break;case"vec2":this.gl.uniform2fv(d,u);break;case"vec3":this.gl.uniform3fv(d,u);break;case"vec4":this.gl.uniform4fv(d,u);break}}}for(let l=0;l<L;l++){const h=e.inputs[l]??e.inputs[0],u=this.framebuffers[w.clamp(h,0,T-1)].texture;this.gl.activeTexture(this.gl.TEXTURE0+l),this.gl.bindTexture(this.gl.TEXTURE_2D,u);const d=i.getUniform(`uChannel${l}`);this.gl.uniform1i(d,l)}const n=i.getAttrib("aPos");this.gl.bindBuffer(this.gl.ARRAY_BUFFER,this.fullscreenVbo),this.gl.enableVertexAttribArray(n),this.gl.vertexAttribPointer(n,2,this.gl.FLOAT,!1,16,0),this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),this.gl.disableVertexAttribArray(n);for(let l=0;l<L;l++)this.gl.activeTexture(this.gl.TEXTURE0+l),this.gl.bindTexture(this.gl.TEXTURE_2D,null);e.output!==-1&&this.framebuffers[w.clamp(e.output,0,T-1)].unbind()}render(e,t){if(!this.initialized)throw new Error("Renderer is not initialized");const i=t.getBounds();this.time=performance.now()*.001;const s=[],r=[],o=[];for(const a of e.getLayersOrdered()){let n;if(this.layersMap.has(a)||this.layersMap.set(a,new De(this.gl,this,a.isStatic)),n=this.layersMap.get(a),n.needsUpdate){let l=a.getSpritesOrdered();n.isStatic||(l=l.filter(h=>F(i,h.getBounds()))),n.uploadSprites(a.getSpritesOrdered())}s.push(n),a.zIndex<=e.shadowsZIndex?r.push(n):o.push(n)}this.renderScene(this.framebuffers[0],this.shaderProgram,t,this.clearColor,s),this.renderFullscreenPass({shader:"default",inputs:[0],output:-1}),this.renderLights(e,t),this.renderScene(this.framebuffers[D],this.shaderProgram,t,this.clearColor,r),this.renderFullscreenPass({shader:"light",inputs:[D,y],output:0}),this.renderScene(this.framebuffers[0],this.shaderProgram,t,null,o),this.renderScene(this.framebuffers[Z],this.maskShaderProgram,t,ee,s);for(let a=0;a<this.pass.length;++a){const n=this.pass[a];this.renderFullscreenPass(n)}for(const[a,n]of this.layersMap)n.lifetime<=0&&(this.layersMap.delete(a),n.destroy())}getTextureInfo(e){const t=this.texturesMap.get(e);if(!t)throw new Error("Texture not found: "+e);return t}getVBO(){return this.vbo}getEBO(){return this.ebo}createTexture(e){const t=this.gl,i=t.createTexture();return t.bindTexture(t.TEXTURE_2D,i),t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,e),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.NEAREST),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,t.NEAREST),i}}let De=class{constructor(e,t,i){this.gl=e,this.renderer=t,this.isStatic=i,this.needsUpdate=!0,this.drawCalls=[],this.lifetime=_,this.spriteBuffer=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.spriteBuffer),e.bufferData(e.ARRAY_BUFFER,(this.isStatic?S:K)*b.spriteStride*4,this.isStatic?e.STATIC_DRAW:e.DYNAMIC_DRAW)}uploadSprites(e){const t=this.gl;t.bindBuffer(t.ARRAY_BUFFER,this.spriteBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,b.createSpritesData(e,!1)),this.isStatic&&(this.needsUpdate=!1),this.drawCalls.length=0;let i=null;for(let s=0;s<e.length;++s){const r=e[s].tileset.name;!i||r!==i.texName?(i={texName:r,spriteOffset:s,spriteCount:1},this.drawCalls.push(i)):i.spriteCount++}}render(e){const t=this.gl;t.bindBuffer(t.ARRAY_BUFFER,this.renderer.getVBO());const i={vertexPos:e.getAttrib("aVertexPos"),texCoord:e.getAttrib("aTexCoord"),tilePos:e.getAttrib("aTilePos"),tileScale:e.getAttrib("aTileScale"),tileAngle:e.getAttrib("aTileAngle"),tileRegion:e.getAttrib("aTileRegion"),tintColor:e.getAttrib("aTintColor"),maskColor:e.getAttrib("aMaskColor"),tileOffset:e.getAttrib("aTileOffset")};t.enableVertexAttribArray(i.vertexPos),t.vertexAttribPointer(i.vertexPos,2,t.FLOAT,!1,16,0),t.enableVertexAttribArray(i.texCoord),t.vertexAttribPointer(i.texCoord,2,t.FLOAT,!1,16,8),t.bindBuffer(t.ARRAY_BUFFER,this.spriteBuffer);const s=b.spriteStride;t.enableVertexAttribArray(i.tilePos),t.vertexAttribPointer(i.tilePos,2,t.FLOAT,!1,s,0),t.enableVertexAttribArray(i.tileScale),t.vertexAttribPointer(i.tileScale,2,t.FLOAT,!1,s,8),t.enableVertexAttribArray(i.tileAngle),t.vertexAttribPointer(i.tileAngle,1,t.FLOAT,!1,s,16),t.enableVertexAttribArray(i.tileRegion),t.vertexAttribPointer(i.tileRegion,4,t.UNSIGNED_SHORT,!1,s,20),t.enableVertexAttribArray(i.tintColor),t.vertexAttribPointer(i.tintColor,4,t.FLOAT,!1,s,28),t.enableVertexAttribArray(i.maskColor),t.vertexAttribPointer(i.maskColor,4,t.FLOAT,!1,s,44),t.enableVertexAttribArray(i.tileOffset),t.vertexAttribPointer(i.tileOffset,2,t.FLOAT,!1,s,60),t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.renderer.getEBO());for(const r of this.drawCalls){const o=this.renderer.getTextureInfo(r.texName);t.bindTexture(t.TEXTURE_2D,o.texture),this.gl.uniform2f(e.getUniform("uTilesetDimensions"),o.tileset.imageWidth,o.tileset.imageHeight),t.drawElements(t.TRIANGLES,6*r.spriteCount,t.UNSIGNED_SHORT,r.spriteOffset*6*2)}t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null),t.disableVertexAttribArray(i.vertexPos),t.disableVertexAttribArray(i.texCoord),t.disableVertexAttribArray(i.tilePos),t.disableVertexAttribArray(i.tileScale),t.disableVertexAttribArray(i.tileAngle),t.disableVertexAttribArray(i.tileRegion),t.disableVertexAttribArray(i.tintColor),t.disableVertexAttribArray(i.maskColor),this.lifetime=_}destroy(){this.gl.deleteBuffer(this.spriteBuffer)}};const q=`
vec4 worldToClip(vec2 worldPos, vec2 cameraPos, vec2 viewport) {
    vec2 pixelPos = worldPos - cameraPos;
    vec2 clipPos = vec2(pixelPos.x / viewport.x, 1.0 - pixelPos.y / viewport.y) * 2.0 - 1.0;
    return vec4(clipPos, 0.0, 1.0);
}
`,ce=`#version 300 es

layout(location = 0) in vec2 aVertexPos;
layout(location = 1) in vec2 aTexCoord;

layout(location = 2) in vec2 aTilePos;
layout(location = 3) in vec2 aTileScale;
layout(location = 4) in float aTileAngle;
layout(location = 5) in uvec4 aTileRegion;

layout(location = 6) in vec4 aTintColor;
layout(location = 7) in vec4 aMaskColor;

layout(location = 8) in vec2 aTileOffset;

uniform vec2 uViewportDimensions;
uniform vec2 uCameraPos;

uniform vec2 uTilesetDimensions;

out vec2 uv;
out vec4 tintColor;
out vec4 maskColor;

${q}

void main() {
    tintColor = aTintColor;
    maskColor = aMaskColor;

    vec2 flippedTexCoord = vec2(aTexCoord.x, 1.0 - aTexCoord.y);
    uv = (vec2(aTileRegion.xy) + flippedTexCoord * vec2(aTileRegion.zw)) / uTilesetDimensions;

    float c = cos(aTileAngle);
    float s = sin(aTileAngle);
    vec2 offsetPos = aVertexPos * aTileScale + aTileOffset;
    vec2 rotatedPos = vec2(
        offsetPos.x * c - offsetPos.y * s,
        offsetPos.x * s + offsetPos.y * c
    );
    vec2 worldPos = rotatedPos + aTilePos;

    gl_Position = worldToClip(worldPos, uCameraPos, uViewportDimensions);
}
`,Ve=`#version 300 es

precision mediump float;

in vec2 uv;
in vec4 tintColor;

uniform mediump sampler2D uSampler;

out vec4 fragColor;

void main() {
    fragColor = texture(uSampler, uv) * tintColor;
}
`,Me=`#version 300 es

precision mediump float;

in vec2 uv;
in vec4 maskColor;

uniform mediump sampler2D uSampler;  

out vec4 fragColor;

void main() {
    vec4 texColor = texture(uSampler, uv);
    fragColor = vec4(maskColor.rgb, texColor.a * maskColor.a);
}
`,Oe=`#version 300 es
precision mediump float;

layout(location = 0) in vec2 aVertexPos;

uniform vec2 uLightCenter;
uniform float uLightRadius;

uniform vec2 uCameraPos;
uniform vec2 uViewportDimensions;

out vec2 worldPos;

${q}

void main() {
    worldPos = uLightCenter + (aVertexPos - 0.5) * 2.0 * uLightRadius;

    gl_Position = worldToClip(worldPos, uCameraPos, uViewportDimensions);
}
`,Ge=`#version 300 es

precision mediump float;

in vec2 worldPos;

uniform vec2 uLightCenter;
uniform float uLightRadius;
uniform vec3 uLightColor;
uniform float uLightIntensity;
uniform vec2 uLightDir;
uniform float uLightCutoff;

out vec4 fragColor;

void main() {
    vec2 toPixel = worldPos - uLightCenter;
    float dist = length(toPixel);

    float attenuation = clamp(1.0 - pow(dist / uLightRadius, 2.0), 0.0, 1.0);

    float spotFactor = 1.0;
    if (uLightCutoff > 0.0) {
        float cosAngle = dot(normalize(uLightDir), normalize(toPixel));
        spotFactor = clamp((cosAngle - uLightCutoff) / (1.0 - uLightCutoff), 0.0, 1.0);
    }

    fragColor = vec4(uLightColor * uLightIntensity * attenuation * spotFactor, 1.0);
}
`,Ne=`#version 300 es

layout(location = 0) in vec2 aPos;

uniform vec2 uCameraPos;
uniform vec2 uViewportDimensions;

${q}

void main() {
    gl_Position = worldToClip(aPos, uCameraPos, uViewportDimensions);
}
`,Xe=`#version 300 es

precision mediump float;

uniform vec2 uLightPos;

out vec4 fragColor;

void main() {
    fragColor = vec4(vec3(0.0), 1.0);
}
`,ze=`#version 300 es

out vec2 uv;

void main() {
    float x = float((gl_VertexID & 1) << 2);
    float y = float((gl_VertexID & 2) << 1);

    gl_Position = vec4(x - 1.0, y - 1.0, 0.0, 1.0);
}
`,ke=c=>`#version 300 es
precision mediump float;

struct Uniforms {
${c.uniforms.map(e=>"    "+e).join(`
`)}
};

uniform sampler2D uChannel0;
uniform sampler2D uChannel1;
uniform sampler2D uChannel2;
uniform sampler2D uChannel3;
uniform sampler2D uChannel4;
uniform sampler2D uChannel5;
uniform sampler2D uChannel6;
uniform sampler2D uChannel7;

uniform Uniforms uniforms;

out vec4 fragColor;

void mainImage(out vec4 fragColor, in vec2 fragCoord) {
${c.mainImage.map(e=>"    "+e).join(`
`)}
}

void main() {
    vec2 fragCoord = gl_FragCoord.xy;
    mainImage(fragColor, fragCoord);
}
`,Ye={componentMap:{r:"r",g:"g",b:"b",a:"a"},declareVar:(c,e)=>`${e} ${c};`};class He{constructor(e){this.canvas=e,this.layersMap=new Map,this.texturesMap=new Map,this.clearColor=new C(0,0,0,0),this.shaderMap=new Map,this.initialized=!1,this.pass=[J],this.framebuffers=[],this.time=0,this.shaderCache=new Map}getType(){return"webgl2"}getBuilderOptions(){return Ye}addTextures(e,t){for(const i of e)t[i.name]&&this.texturesMap.set(i.name,{tileset:i,image:t[i.name]})}addImageTextures(e){for(let t of e){const i=new P({name:t.name,tilecount:1,columns:1,tilewidth:t.width,tileheight:t.height,imagewidth:t.width,imageheight:t.height});this.texturesMap.set(t.name,{tileset:i,image:t.image})}}registerShader(e,t,i="none"){this.shaderMap.set(e,{builder:t,blendMode:i})}setClearColor(e){this.clearColor.copy(e)}setSize(e,t){this.canvas.width=e,this.canvas.height=t,this.initialized&&this.initFramebuffers()}getCanvas(){return this.canvas}initFramebuffers(){for(let e=0;e<T;++e){const t=Q(e);this.framebuffers[e]?.destroy(),this.framebuffers[e]=new he(this.gl,this.canvas.width*t,this.canvas.height*t)}}blend(e){switch(e){case"alpha":this.gl.enable(this.gl.BLEND),this.gl.blendFunc(this.gl.SRC_ALPHA,this.gl.ONE_MINUS_SRC_ALPHA);break;case"additive":this.gl.enable(this.gl.BLEND),this.gl.blendFunc(this.gl.ONE,this.gl.ONE);break;default:this.gl.disable(this.gl.BLEND)}}async init(){const e=this.canvas.getContext("webgl2");if(!e)throw new Error("WebGL2 not supported");this.gl=e;for(const t of this.texturesMap.values())t.tileset&&(t.texture=this.createTexture(t.image));this.initFramebuffers(),this.registerShader("default",U),this.registerShader("default_additive",U,"additive"),this.registerShader("light",Y),this.registerShader("blurHorizontal",H),this.registerShader("blurVertical",W);for(const t of this.shaderMap.values()){if(!this.shaderCache.has(t.builder)){const i=t.builder.build(this),s=new A(e,ze,ke(i));this.shaderCache.set(t.builder,s)}t.shader=this.shaderCache.get(t.builder)}this.shaderProgram=new A(e,ce,Ve),this.maskShaderProgram=new A(e,ce,Me),this.lightShaderProgram=new A(e,Oe,Ge),this.shadowShaderProgram=new A(e,Ne,Xe),this.vbo=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.vbo),e.bufferData(e.ARRAY_BUFFER,b.quad,e.STATIC_DRAW),this.lightVao=e.createVertexArray(),e.bindVertexArray(this.lightVao),e.bindBuffer(e.ARRAY_BUFFER,this.vbo),e.enableVertexAttribArray(0),e.vertexAttribPointer(0,2,e.FLOAT,!1,16,0),e.bindVertexArray(null),this.shadowsVbo=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.shadowsVbo),e.bufferData(e.ARRAY_BUFFER,G*I*8,e.DYNAMIC_DRAW),this.shadowsVao=e.createVertexArray(),e.bindVertexArray(this.shadowsVao),e.bindBuffer(e.ARRAY_BUFFER,this.shadowsVbo),e.enableVertexAttribArray(0),e.vertexAttribPointer(0,2,e.FLOAT,!1,8,0),e.bindVertexArray(null),this.initialized=!0}renderScene(e,t,i,s,r){e.bind(),this.blend("alpha"),s&&(this.gl.clearColor(s.r,s.g,s.b,s.a),this.gl.clear(this.gl.COLOR_BUFFER_BIT)),this.gl.activeTexture(this.gl.TEXTURE0),t.use(),this.gl.uniform2f(t.getUniform("uViewportDimensions"),i.vw,i.vh),this.gl.uniform2f(t.getUniform("uCameraPos"),i.position.x,i.position.y);for(let o of r)o.render(t);e.unbind()}renderLights(e,t){const i=t.getBounds(),s=e.getLights().filter(n=>F(i,n.getBounds())),r=new Float32Array(s.length*I*2),o=[];let a=0;for(let n of s){const l=e.getColliders(n.getBounds()),h=b.createShadowsGeometry(r,n,l,a);o.push({count:(h-a)/2,offset:a/2}),a=h}this.gl.bindBuffer(this.gl.ARRAY_BUFFER,this.shadowsVbo),this.gl.bufferSubData(this.gl.ARRAY_BUFFER,0,r,0,a),this.framebuffers[y].bind(),this.gl.clearColor(e.ambientColor.r*e.ambientIntensity,e.ambientColor.g*e.ambientIntensity,e.ambientColor.b*e.ambientIntensity,1),this.gl.clear(this.gl.COLOR_BUFFER_BIT),this.framebuffers[y].unbind();for(let n=0;n<s.length;++n){const l=s[n];this.framebuffers[y+1].bind(),this.blend("none"),this.gl.clearColor(0,0,0,1),this.gl.clear(this.gl.COLOR_BUFFER_BIT),this.lightShaderProgram.use(),this.gl.uniform2f(this.lightShaderProgram.getUniform("uViewportDimensions"),t.vw,t.vh),this.gl.uniform2f(this.lightShaderProgram.getUniform("uCameraPos"),t.position.x,t.position.y),this.gl.uniform2f(this.lightShaderProgram.getUniform("uLightCenter"),l.position.x,l.position.y),this.gl.uniform1f(this.lightShaderProgram.getUniform("uLightRadius"),l.radius),this.gl.uniform3f(this.lightShaderProgram.getUniform("uLightColor"),l.color.r,l.color.g,l.color.b),this.gl.uniform1f(this.lightShaderProgram.getUniform("uLightIntensity"),l.intensity),this.gl.uniform2f(this.lightShaderProgram.getUniform("uLightDir"),l.direction.x,l.direction.y),this.gl.uniform1f(this.lightShaderProgram.getUniform("uLightCutoff"),l.cutoff),this.gl.bindVertexArray(this.lightVao),this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),this.gl.bindVertexArray(null);const h=o[n];h.count!==0&&(this.shadowShaderProgram.use(),this.gl.uniform2f(this.shadowShaderProgram.getUniform("uViewportDimensions"),t.vw,t.vh),this.gl.uniform2fv(this.shadowShaderProgram.getUniform("uCameraPos"),t.position.toArray()),this.gl.uniform2fv(this.shadowShaderProgram.getUniform("uLightPos"),l.position.toArray()),this.gl.bindVertexArray(this.shadowsVao),this.gl.drawArrays(this.gl.TRIANGLES,h.offset,h.count),this.gl.bindVertexArray(null)),this.framebuffers[y+1].unbind(),this.renderFullscreenPass({shader:"blurHorizontal",inputs:[y+1],output:4}),this.renderFullscreenPass({shader:"blurVertical",inputs:[4],output:5}),this.renderFullscreenPass({shader:"default_additive",inputs:[5],output:y})}}renderFullscreenPass(e){const t=this.shaderMap.get(e.shader);if(!t)throw new Error("Unknown shader "+e.shader);e.clearColor&&(this.gl.clearColor(this.clearColor.r,this.clearColor.g,this.clearColor.b,this.clearColor.a),this.gl.clear(this.gl.COLOR_BUFFER_BIT));const i=t.shader;let s=this.canvas.width,r=this.canvas.height;if(e.output!==-1){const n=this.framebuffers[w.clamp(e.output,0,T-1)];s=n.width,r=n.height,n.bind()}else this.gl.viewport(0,0,s,r);this.blend(t.blendMode),i.use();const o=[{name:"time",value:this.time},{name:"resolution",value:[s,r]}].concat(e.uniforms??[]),a=t.builder.getUniforms();for(let n of a){const l=o.find(h=>h.name===n.name);if(l){const h=typeof l.value=="number"?[l.value]:l.value,u=i.getUniform("uniforms."+n.name);switch(n.type){case"float":this.gl.uniform1f(u,h[0]);break;case"vec2":this.gl.uniform2fv(u,h);break;case"vec3":this.gl.uniform3fv(u,h);break;case"vec4":this.gl.uniform4fv(u,h);break}}}for(let n=0;n<L;n++){const l=e.inputs[n]??e.inputs[0],h=this.framebuffers[w.clamp(l,0,T-1)].texture;this.gl.activeTexture(this.gl.TEXTURE0+n),this.gl.bindTexture(this.gl.TEXTURE_2D,h);const u=i.getUniform(`uChannel${n}`);this.gl.uniform1i(u,n)}this.gl.drawArrays(this.gl.TRIANGLES,0,3);for(let n=0;n<L;n++)this.gl.activeTexture(this.gl.TEXTURE0+n),this.gl.bindTexture(this.gl.TEXTURE_2D,null);e.output!==-1&&this.framebuffers[w.clamp(e.output,0,T-1)].unbind()}render(e,t){if(!this.initialized)throw new Error("Renderer is not initialized");const i=t.getBounds();this.time=performance.now()*.001;const s=[],r=[],o=[];for(const a of e.getLayersOrdered()){let n;if(this.layersMap.has(a)||this.layersMap.set(a,new We(this.gl,this,a.isStatic)),n=this.layersMap.get(a),n.needsUpdate){let l=a.getSpritesOrdered();n.isStatic||(l=l.filter(h=>F(i,h.getBounds()))),n.uploadSprites(a.getSpritesOrdered())}s.push(n),a.zIndex<=e.shadowsZIndex?r.push(n):o.push(n)}this.renderLights(e,t),this.renderScene(this.framebuffers[D],this.shaderProgram,t,this.clearColor,r),this.renderFullscreenPass({shader:"light",inputs:[D,y],output:0}),this.renderScene(this.framebuffers[0],this.shaderProgram,t,null,o),this.renderScene(this.framebuffers[Z],this.maskShaderProgram,t,ee,s);for(let a=0;a<this.pass.length;++a){const n=this.pass[a];this.renderFullscreenPass(n)}for(const[a,n]of this.layersMap)n.lifetime<=0&&(this.layersMap.delete(a),n.destroy())}getTextureInfo(e){const t=this.texturesMap.get(e);if(!t)throw new Error("Texture not found: "+e);return t}getVBO(){return this.vbo}createTexture(e){const t=this.gl,i=t.createTexture();return t.bindTexture(t.TEXTURE_2D,i),t.texImage2D(t.TEXTURE_2D,0,t.RGBA8,t.RGBA,t.UNSIGNED_BYTE,e),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.NEAREST),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,t.NEAREST),i}createTextureArray(e,t){const i=this.gl,s=i.createBuffer();i.bindBuffer(i.PIXEL_UNPACK_BUFFER,s),i.bufferData(i.PIXEL_UNPACK_BUFFER,t,i.STATIC_DRAW),i.pixelStorei(i.UNPACK_ROW_LENGTH,e.imageWidth),i.pixelStorei(i.UNPACK_IMAGE_HEIGHT,e.imageHeight);const r=i.createTexture();i.bindTexture(i.TEXTURE_2D_ARRAY,r),i.texStorage3D(i.TEXTURE_2D_ARRAY,4,i.RGBA8,e.tileWidth,e.tileHeight,e.tileCount);for(let o=0;o<e.tileCount;++o){const a=o%e.columns,n=Math.floor(o/e.columns);i.pixelStorei(i.UNPACK_SKIP_PIXELS,a*e.tileWidth),i.pixelStorei(i.UNPACK_SKIP_ROWS,n*e.tileHeight),i.texSubImage3D(i.TEXTURE_2D_ARRAY,0,0,0,o,e.tileWidth,e.tileHeight,1,i.RGBA,i.UNSIGNED_BYTE,0)}return i.deleteBuffer(s),i.generateMipmap(i.TEXTURE_2D_ARRAY),i.texParameteri(i.TEXTURE_2D_ARRAY,i.TEXTURE_MAG_FILTER,i.NEAREST),i.texParameteri(i.TEXTURE_2D_ARRAY,i.TEXTURE_MIN_FILTER,i.NEAREST),r}}class We{constructor(e,t,i){this.gl=e,this.renderer=t,this.isStatic=i,this.needsUpdate=!0,this.drawCalls=[],this.lifetime=_,this.vao=e.createVertexArray(),e.bindVertexArray(this.vao),e.bindBuffer(e.ARRAY_BUFFER,t.getVBO()),e.enableVertexAttribArray(0),e.vertexAttribPointer(0,2,e.FLOAT,!1,16,0),e.enableVertexAttribArray(1),e.vertexAttribPointer(1,2,e.FLOAT,!1,16,8),this.instanceBuffer=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.instanceBuffer);const s=b.spriteStride;e.bufferData(e.ARRAY_BUFFER,(this.isStatic?S:K)*s,this.isStatic?e.STATIC_DRAW:e.DYNAMIC_DRAW);for(let r=2;r<=8;++r)e.enableVertexAttribArray(r),e.vertexAttribDivisor(r,1);e.bindVertexArray(null)}uploadSprites(e){const t=this.gl;t.bindBuffer(t.ARRAY_BUFFER,this.instanceBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,b.createSpritesData(e,!0)),this.isStatic&&(this.needsUpdate=!1),this.drawCalls.length=0;let i=null;for(let s=0;s<e.length;++s){const r=e[s].tileset.name;!i||r!==i.texName?(i={texName:r,offset:s,count:1},this.drawCalls.push(i)):i.count++}}render(e){const t=this.gl;t.bindVertexArray(this.vao);for(const i of this.drawCalls){const s=this.renderer.getTextureInfo(i.texName);t.bindTexture(t.TEXTURE_2D,s.texture),this.gl.uniform2f(e.getUniform("uTilesetDimensions"),s.tileset.imageWidth,s.tileset.imageHeight),t.bindBuffer(t.ARRAY_BUFFER,this.instanceBuffer);const r=b.spriteStride,o=i.offset*r;t.vertexAttribPointer(2,2,t.FLOAT,!1,r,0+o),t.vertexAttribPointer(3,2,t.FLOAT,!1,r,8+o),t.vertexAttribPointer(4,1,t.FLOAT,!1,r,16+o),t.vertexAttribIPointer(5,4,t.UNSIGNED_SHORT,r,20+o),t.vertexAttribPointer(6,4,t.FLOAT,!1,r,28+o),t.vertexAttribPointer(7,4,t.FLOAT,!1,r,44+o),t.vertexAttribPointer(8,2,t.FLOAT,!1,r,60+o),t.drawArraysInstanced(t.TRIANGLE_STRIP,0,4,i.count)}t.bindVertexArray(null),this.lifetime=_}destroy(){this.gl.deleteBuffer(this.instanceBuffer),this.gl.deleteVertexArray(this.vao)}}const $e=async()=>{const e=await(await navigator.gpu?.requestAdapter())?.requestDevice();if(!e)return null;const t=navigator.gpu.getPreferredCanvasFormat();return{device:e,format:t}},j=`
fn worldToClip(worldPos: vec2f, cameraPos: vec2f, viewport: vec2f) -> vec4f {
    let pixelPos = worldPos - cameraPos;
    let clipPos = vec2f(pixelPos.x / viewport.x, 1.0 - pixelPos.y / viewport.y) * 2.0 - 1.0;
    return vec4f(clipPos, 0.0, 1.0);
}
`,fe=`
struct VSInput {
    @location(0) vertexPos: vec2f,
    @location(1) texCoord: vec2f,
    
    @location(2) tilePos: vec2f,
    @location(3) tileScale: vec2f,
    @location(4) tileAngle: f32,
    @location(5) tileRegion: vec2u,

    @location(6) tintColor: vec4f,
    @location(7) maskColor: vec4f,

    @location(8) tileOffset: vec2f
}

struct Camera {
    pos: vec2f,
    viewportDimensions: vec2f
}

@group(0) @binding(0)
var<uniform> camera: Camera;

@group(1) @binding(2)
var<uniform> tilesetDimensions: vec2f;

struct VSOutput {
    @builtin(position) pos: vec4f,
    @location(0) uv: vec2f,
    @location(1) tintColor: vec4f,
    @location(2) maskColor: vec4f
}

${j}

@vertex
fn vs_main(input: VSInput) -> VSOutput {
    var out: VSOutput;

    out.tintColor = input.tintColor;
    out.maskColor = input.maskColor;

    let x = f32(input.tileRegion.x & 0xFFFFu);
    let y = f32(input.tileRegion.x >> 16);
    let w = f32(input.tileRegion.y & 0xFFFFu);
    let h = f32(input.tileRegion.y >> 16);

    let tileRegion = vec4f(x, y, w, h);

    let flippedTexCoord = vec2f(input.texCoord.x, 1.0 - input.texCoord.y);
    out.uv = (tileRegion.xy + flippedTexCoord * tileRegion.zw) / tilesetDimensions;

    let c = cos(input.tileAngle);
    let s = sin(input.tileAngle);
    let offsetPos = input.vertexPos * input.tileScale + input.tileOffset;
    let rotatedPos = vec2f(
        offsetPos.x * c - offsetPos.y * s,
        offsetPos.x * s + offsetPos.y * c
    );
    let worldPos = rotatedPos + input.tilePos;

    out.pos = worldToClip(worldPos, camera.pos, camera.viewportDimensions);
    return out;
}`,qe=`

@group(1) @binding(0)
var spriteSampler: sampler;

@group(1) @binding(1)
var spriteTexture: texture_2d<f32>;

@fragment
fn fs_main(input: VSOutput) -> @location(0) vec4f {
    return textureSample(spriteTexture, spriteSampler, input.uv) * input.tintColor;
}
`,je=`
@group(1) @binding(0)
var spriteSampler: sampler;

@group(1) @binding(1)
var spriteTexture: texture_2d<f32>;

@fragment
fn fs_main(input: VSOutput) -> @location(0) vec4f {
    let texColor: vec4f = textureSample(spriteTexture, spriteSampler, input.uv);
    return vec4f(input.maskColor.xyz, texColor.w * input.maskColor.a);
}
`,Ke=fe+qe,Ze=fe+je,Je=`
struct VSInput {
    @location(0) pos: vec2f
}

struct VSOutput {
    @builtin(position) pos: vec4f,
    @location(0) worldPos: vec2f
}

struct Camera {
    pos: vec2f,
    viewportDimensions: vec2f
}

struct Light {
    center: vec2f,
    radius: f32,
    color: vec3f,
    intensity: f32,
    direction: vec2f,
    cutoff: f32
}

@group(0) @binding(0)
var<uniform> camera: Camera;

@group(1) @binding(0)
var<uniform> light: Light;

${j}

@vertex
fn vs_main(input: VSInput) -> VSOutput {
    var out: VSOutput;

    out.worldPos = light.center + (input.pos - 0.5) * 2.0 * light.radius;

    out.pos = worldToClip(out.worldPos, camera.pos, camera.viewportDimensions);
    return out;
}

@fragment
fn fs_main(input: VSOutput) -> @location(0) vec4f {
    let toPixel = input.worldPos - light.center;
    let dist = length(toPixel);

    let attenuation = clamp(1.0 - pow(dist / light.radius, 2.0), 0.0, 1.0);

    var spotFactor = 1.0;
    if (light.cutoff > 0.0) {
        let cosAngle = dot(normalize(toPixel), normalize(light.direction));
        spotFactor = clamp((cosAngle - light.cutoff) / (1.0 - light.cutoff), 0.0, 1.0);
    }

    return vec4f(light.color * light.intensity * attenuation * spotFactor, 1.0);
}
`,Qe=`
struct VSInput {
    @location(0) pos: vec2f
}

struct VSOutput {
    @builtin(position) pos: vec4f
}

struct Camera {
    pos: vec2f,
    viewportDimensions: vec2f
}

@group(0) @binding(0)
var<uniform> camera: Camera;

${j}

@vertex
fn vs_main(input: VSInput) -> VSOutput {
    var out: VSOutput;

    out.pos = worldToClip(input.pos, camera.pos, camera.viewportDimensions);
    return out;
}

@fragment
fn fs_main(input: VSOutput) -> @location(0) vec4f {
    return vec4f(0.0, 0.0, 0.0, 1.0);
}
`,et=c=>`

struct VSOutput {
    @builtin(position) pos: vec4f,
    @location(0) uv: vec2f
}

@vertex
fn vs_main(@builtin(vertex_index) vertexIndex: u32) -> VSOutput {
    var out: VSOutput;

    let x = f32((vertexIndex & 1) << 2);
    let y = f32((vertexIndex & 2) << 1);

    out.uv = vec2f(x, 2.0 - y) / 2.0;
    out.pos = vec4f(x - 1.0, y - 1.0, 0.0, 1.0);
    return out;
}

struct Uniforms {
${c.uniforms.map(e=>"    "+e).join(`,
`)}
}

@group(0) @binding(0)
var<uniform> uniforms: Uniforms;

@group(1) @binding(0)
var defaultSampler: sampler;

@group(1) @binding(1)
var channel0: texture_2d<f32>;

@group(1) @binding(2)
var channel1: texture_2d<f32>;

@group(1) @binding(3)
var channel2: texture_2d<f32>;

@group(1) @binding(4)
var channel3: texture_2d<f32>;

@group(1) @binding(5)
var channel4: texture_2d<f32>;

@group(1) @binding(6)
var channel5: texture_2d<f32>;

@group(1) @binding(7)
var channel6: texture_2d<f32>;

@group(1) @binding(8)
var channel7: texture_2d<f32>;

fn texture(ch: i32, uv: vec2f) -> vec4f {
    let scaledUV = uv;

    switch (ch) {
        case 1:  { return textureSample(channel1, defaultSampler, scaledUV); }
        case 2:  { return textureSample(channel2, defaultSampler, scaledUV); }
        case 3:  { return textureSample(channel3, defaultSampler, scaledUV); }
        case 4:  { return textureSample(channel4, defaultSampler, scaledUV); }
        case 5:  { return textureSample(channel5, defaultSampler, scaledUV); }
        case 6:  { return textureSample(channel6, defaultSampler, scaledUV); }
        case 7:  { return textureSample(channel7, defaultSampler, scaledUV); }
        default: { return textureSample(channel0, defaultSampler, scaledUV); }
    }
}

fn mainImage(fragCoord: vec2f) -> vec4f {
    var fragColor: vec4f;
${c.mainImage.map(e=>"    "+e).join(`
`)}
    return fragColor;
}

@fragment
fn fs_main(input: VSOutput) -> @location(0) vec4f {
    let fragCoord = input.uv * uniforms.resolution;
    return mainImage(fragCoord);
}
`,tt={componentMap:{r:"x",g:"y",b:"z",a:"w"},declareVar:(c,e,t=!1)=>{const i=`${c}: ${e==="float"?"f32":e+"f"}`;return t?i:`var ${i};`}};class it{constructor(e){this.shaderMap=new Map,this.layersMap=new Map,this.texturesMap=new Map,this.canvas=e,this.clearColor=new C(0,0,0,0),this.shaderMap=new Map,this.initialized=!1,this.pass=[J],this.offscreenTextures=[],this.time=0,this.shaderCache=new Map,this.renderPassUniformMap=new Map,this.fullscreenPassStages={mainLight:{shader:"light",inputs:[D,y],output:0},lightBlurHorizontal:{shader:"blurHorizontal",inputs:[y+1],output:4},lightBlurVertical:{shader:"blurVertical",inputs:[4],output:5},lightAdditive:{shader:"default_additive",inputs:[5],output:y}}}getType(){return"webgpu"}getBuilderOptions(){return tt}addTextures(e,t){for(const i of e)t[i.name]&&this.texturesMap.set(i.name,{tileset:i,image:t[i.name]})}addImageTextures(e){for(let t of e){const i=new P({name:t.name,tilecount:1,columns:1,tilewidth:t.width,tileheight:t.height,imagewidth:t.width,imageheight:t.height});this.texturesMap.set(t.name,{tileset:i,image:t.image})}}registerShader(e,t,i="none"){this.shaderMap.set(e,{builder:t,blendMode:i})}setClearColor(e){this.clearColor.copy(e)}setSize(e,t){this.canvas.width=e,this.canvas.height=t,this.initialized&&this.initOffscreenTextures(T)}getCanvas(){return this.canvas}initOffscreenTextures(e){for(let t=0;t<e;++t){this.offscreenTextures[t]?.destroy();const i=Q(t);this.offscreenTextures[t]=this.cfg.device.createTexture({size:{width:this.canvas.width*i,height:this.canvas.height*i,depthOrArrayLayers:1},format:this.cfg.format,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING,label:"offscreen texture "+t})}}getBlendOptions(e){switch(e){case"alpha":return{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha",operation:"add"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"}};case"additive":return{color:{srcFactor:"one",dstFactor:"one",operation:"add"},alpha:{srcFactor:"zero",dstFactor:"one",operation:"add"}};default:return}}async init(){const e=await $e();if(!e)throw new Error("WebGPU not supported");this.cfg=e;const t=this.cfg.device,i=this.canvas.getContext("webgpu");this.ctx=i,this.ctx.configure(this.cfg);for(const n of this.texturesMap.values())n.tileset&&(n.texture=this.createTexture(n.tileset,n.image));this.initOffscreenTextures(T),this.sampler=t.createSampler({magFilter:"nearest",minFilter:"nearest",addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge"}),this.fullscreenSampler=t.createSampler({magFilter:"linear",minFilter:"linear",addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge"}),this.registerShader("default",U),this.registerShader("default_additive",U,"additive"),this.registerShader("light",Y),this.registerShader("blurHorizontal",H),this.registerShader("blurVertical",W);for(const[n,l]of this.shaderMap.entries()){if(!this.shaderCache.has(l.builder)){const d=et(l.builder.build(this)),m=t.createShaderModule({label:n+" shader module",code:d});this.shaderCache.set(l.builder,m)}const h=this.shaderCache.get(l.builder),u=t.createRenderPipeline({layout:"auto",vertex:{module:h,entryPoint:"vs_main"},fragment:{module:h,entryPoint:"fs_main",targets:[{format:this.cfg.format,blend:this.getBlendOptions(l.blendMode)}]},primitive:{topology:"triangle-strip"}});l.pipeline=u}this.commonBGL=this.cfg.device.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.FRAGMENT,sampler:{}},{binding:1,visibility:GPUShaderStage.FRAGMENT,texture:{}},{binding:2,visibility:GPUShaderStage.VERTEX,buffer:{type:"uniform"}}]}),this.cameraBGL=this.cfg.device.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.VERTEX,buffer:{type:"uniform"}}]}),this.lightBGL=this.cfg.device.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,buffer:{type:"uniform",hasDynamicOffset:!0}}]}),this.pipeline=this.createMainPipeline(Ke),this.maskPipeline=this.createMainPipeline(Ze),this.lightUniformBuffer=this.cfg.device.createBuffer({label:"Light uniform buffer",size:G*256,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});const s=this.cfg.device.createPipelineLayout({bindGroupLayouts:[this.cameraBGL,this.lightBGL]}),r=this.cfg.device.createShaderModule({code:Je});this.lightPipeline=this.cfg.device.createRenderPipeline({label:"Light pipeline",layout:s,vertex:{module:r,entryPoint:"vs_main",buffers:[{arrayStride:16,attributes:[{shaderLocation:0,offset:0,format:"float32x2"}]}]},fragment:{module:r,entryPoint:"fs_main",targets:[{format:this.cfg.format}]},primitive:{topology:"triangle-strip"}}),this.lightUniformBindGroup=this.cfg.device.createBindGroup({label:"Light uniform bind group",layout:this.lightPipeline.getBindGroupLayout(1),entries:[{binding:0,resource:{buffer:this.lightUniformBuffer,size:b.lightStride}}]});const o=this.cfg.device.createPipelineLayout({bindGroupLayouts:[this.cameraBGL]}),a=this.cfg.device.createShaderModule({code:Qe});this.shadowPipeline=this.cfg.device.createRenderPipeline({label:"Shadow pipeline",layout:o,vertex:{module:a,entryPoint:"vs_main",buffers:[{arrayStride:8,attributes:[{shaderLocation:0,offset:0,format:"float32x2"}]}]},fragment:{module:a,entryPoint:"fs_main",targets:[{format:this.cfg.format}]}}),this.cameraBuffer=t.createBuffer({size:16,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),this.cameraBindGroup=t.createBindGroup({label:"Camera bind group",layout:this.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:this.cameraBuffer}}]}),this.vbo=t.createBuffer({size:b.quad.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST}),t.queue.writeBuffer(this.vbo,0,b.quad),this.shadowsVbo=this.cfg.device.createBuffer({size:G*I*8,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST}),this.initialized=!0}createMainPipeline(e){const t=this.cfg.device.createShaderModule({code:e}),i=this.cfg.device.createPipelineLayout({bindGroupLayouts:[this.cameraBGL,this.commonBGL]});return this.cfg.device.createRenderPipeline({layout:i,vertex:{module:t,entryPoint:"vs_main",buffers:[{arrayStride:16,stepMode:"vertex",attributes:[{shaderLocation:0,offset:0,format:"float32x2"},{shaderLocation:1,offset:8,format:"float32x2"}]},{arrayStride:b.spriteStride,stepMode:"instance",attributes:[{shaderLocation:2,offset:0,format:"float32x2"},{shaderLocation:3,offset:8,format:"float32x2"},{shaderLocation:4,offset:16,format:"float32"},{shaderLocation:5,offset:20,format:"uint32x2"},{shaderLocation:6,offset:28,format:"float32x4"},{shaderLocation:7,offset:44,format:"float32x4"},{shaderLocation:8,offset:60,format:"float32x2"}]}]},fragment:{module:t,entryPoint:"fs_main",targets:[{format:this.cfg.format,blend:this.getBlendOptions("alpha")}]},primitive:{topology:"triangle-strip"}})}renderScene(e,t,i,s,r){const o=e.beginRenderPass({colorAttachments:[{clearValue:s||void 0,view:i.createView(),loadOp:s?"clear":"load",storeOp:"store"}]});o.setPipeline(t),o.setBindGroup(0,this.cameraBindGroup),o.setVertexBuffer(0,this.vbo);for(const a of r)a.render(o);o.end()}renderLights(e,t,i){const s=i.getBounds(),r=t.getLights().filter(m=>F(s,m.getBounds())),o=new Float32Array(r.length*I*2),a=[];let n=0;for(let m of r){const f=t.getColliders(m.getBounds()),p=b.createShadowsGeometry(o,m,f,n);a.push({count:(p-n)/2,offset:n/2}),n=p}this.cfg.device.queue.writeBuffer(this.shadowsVbo,0,o,0,n);const l=new C(t.ambientColor.r*t.ambientIntensity,t.ambientColor.g*t.ambientIntensity,t.ambientColor.b*t.ambientIntensity,1);e.beginRenderPass({colorAttachments:[{view:this.offscreenTextures[y].createView(),clearValue:l,loadOp:"clear",storeOp:"store"}]}).end();const u=b.createLightsGeometry(r,!0);this.cfg.device.queue.writeBuffer(this.lightUniformBuffer,0,u);const d=this.offscreenTextures[y+1].createView();for(let m=0;m<r.length;++m){const f=e.beginRenderPass({colorAttachments:[{view:d,clearValue:new C(0,0,0,1),loadOp:"clear",storeOp:"store"}]});f.setPipeline(this.lightPipeline),f.setVertexBuffer(0,this.vbo),f.setBindGroup(0,this.cameraBindGroup),f.setBindGroup(1,this.lightUniformBindGroup,[m*256]),f.draw(4);const p=a[m];p.count!==0&&(f.setPipeline(this.shadowPipeline),f.setVertexBuffer(0,this.shadowsVbo),f.setBindGroup(0,this.cameraBindGroup),f.draw(p.count,1,p.offset)),f.end(),this.renderFullscreenPass(e,this.fullscreenPassStages.lightBlurHorizontal),this.renderFullscreenPass(e,this.fullscreenPassStages.lightBlurVertical),this.renderFullscreenPass(e,this.fullscreenPassStages.lightAdditive)}}renderFullscreenPass(e,t){const i=this.shaderMap.get(t.shader);if(!i)throw new Error("Unknown shader "+t.shader);const s=t.output===-1?this.ctx.getCurrentTexture():this.offscreenTextures[w.clamp(t.output,0,T-1)],r=i.builder.getUniforms(),o=[{name:"time",value:this.time},{name:"resolution",value:[s.width,s.height]}].concat(t.uniforms??[]),a=new Float32Array(ot);for(let h of r){const u=o.find(d=>d.name===h.name);if(u){const d=typeof u.value=="number"?[u.value]:u.value;a.set(d,h.offset)}}if(!this.renderPassUniformMap.has(t)){const h=this.cfg.device.createBuffer({size:256,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),u=this.cfg.device.createBindGroup({layout:i.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:h}}]}),d=[{binding:0,resource:this.fullscreenSampler}];for(let f=0;f<L;f++){const p=t.inputs[f]??t.inputs[0],g=this.offscreenTextures[w.clamp(p,0,T-1)];d.push({binding:f+1,resource:g.createView()})}const m=this.cfg.device.createBindGroup({label:t.shader+" texture bind group",layout:i.pipeline.getBindGroupLayout(1),entries:d});this.renderPassUniformMap.set(t,{ubo:h,uniformBindGroup:u,textureBindGroup:m})}const n=this.renderPassUniformMap.get(t);this.cfg.device.queue.writeBuffer(n.ubo,0,a);const l=e.beginRenderPass({colorAttachments:[{view:s.createView(),loadOp:t.clearColor?"clear":"load",clearValue:t.clearColor,storeOp:"store"}]});l.setPipeline(i.pipeline),l.setBindGroup(0,n.uniformBindGroup),l.setBindGroup(1,n.textureBindGroup),l.draw(3),l.end()}render(e,t){if(!this.initialized)throw new Error("Renderer is not initialized");const i=t.getBounds();this.time=performance.now()*.001;const s=[],r=[],o=[];for(const l of e.getLayersOrdered()){if(!this.layersMap.has(l)){const u=new rt(this,l.isStatic);this.layersMap.set(l,u)}const h=this.layersMap.get(l);if(h.needsUpdate){let u=l.getSpritesOrdered();h.isStatic||(u=u.filter(d=>F(i,d.getBounds()))),h.uploadSprites(u)}s.push(h),l.zIndex<=e.shadowsZIndex?r.push(h):o.push(h)}this.cfg.device.queue.writeBuffer(this.cameraBuffer,0,new Float32Array([t.position.x,t.position.y,t.vw,t.vh]));const a=this.cfg.device.createCommandEncoder();this.renderLights(a,e,t),this.renderScene(a,this.pipeline,this.offscreenTextures[D],this.clearColor,r),this.renderFullscreenPass(a,this.fullscreenPassStages.mainLight),this.renderScene(a,this.pipeline,this.offscreenTextures[0],null,o),this.renderScene(a,this.maskPipeline,this.offscreenTextures[Z],ee,s);for(let l=0;l<this.pass.length;++l){const h=this.pass[l];this.renderFullscreenPass(a,h)}const n=a.finish();this.cfg.device.queue.submit([n]);for(const[l,h]of this.layersMap)h.lifetime<=0&&(h.destroy(),this.layersMap.delete(l))}createTexture(e,t){const i=this.cfg.device.createTexture({size:{width:e.imageWidth,height:e.imageHeight,depthOrArrayLayers:1},format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT});return this.cfg.device.queue.copyExternalImageToTexture,this.cfg.device.queue.copyExternalImageToTexture({source:t},{texture:i},[e.imageWidth,e.imageHeight,1]),i}createTextureArray(e,t){const i=e.tileWidth,s=e.tileHeight,r=this.cfg.device.createTexture({size:{width:i,height:s,depthOrArrayLayers:e.tileCount},format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT});for(let o=0;o<e.tileCount;++o){const a=Math.floor(o/e.columns),n=o%e.columns,l=new Uint8Array(i*s*4);for(let h=0;h<s;++h){const u=((a*s+h)*e.columns+n)*i*4,d=u+i*4;l.set(t.slice(u,d),h*i*4)}this.cfg.device.queue.writeTexture({texture:r,origin:{x:0,y:0,z:o}},l,{bytesPerRow:i*4,rowsPerImage:s},{width:i,height:s,depthOrArrayLayers:1})}return r}getConfig(){return this.cfg}getTextureInfo(e){const t=this.texturesMap.get(e);if(!t)throw new Error("Texture not found: "+e);return t}getPipeline(){return this.pipeline}getSampler(){return this.sampler}}class rt{constructor(e,t){this.renderer=e,this.isStatic=t,this.needsUpdate=!0,this.drawCalls=[],this.bindGroups=new Map,this.lifetime=_,this.lastTexIdx=0,this.instanceBuffer=e.getConfig().device.createBuffer({label:"Instance Buffer",size:b.spriteStride*(t?S:K),usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST}),this.tilesetDimBuffer=e.getConfig().device.createBuffer({label:"Tileset Dimensions Buffer",size:st*256,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST})}uploadSprites(e){const t=this.renderer.getConfig().device,i=this.renderer.getPipeline(),s=this.renderer.getSampler();t.queue.writeBuffer(this.instanceBuffer,0,b.createSpritesData(e,!0)),this.isStatic&&(this.needsUpdate=!1),this.drawCalls.length=0;let r=null;for(let o=0;o<e.length;++o){const a=e[o].tileset.name;if(!r||a!==r.texName){const n=this.renderer.getTextureInfo(a);t.queue.writeBuffer(this.tilesetDimBuffer,this.lastTexIdx*256,new Float32Array([n.tileset.imageWidth,n.tileset.imageHeight]));const l=t.createBindGroup({layout:i.getBindGroupLayout(1),entries:[{binding:0,resource:s},{binding:1,resource:n.texture.createView()},{binding:2,resource:{buffer:this.tilesetDimBuffer,offset:this.lastTexIdx*256,size:8}}]});r={texName:a,instanceOffset:o,instanceCount:1},this.bindGroups.has(r.texName)||(this.bindGroups.set(r.texName,l),++this.lastTexIdx),this.drawCalls.push(r)}else r.instanceCount++}}render(e){e.setVertexBuffer(1,this.instanceBuffer);for(const t of this.drawCalls)e.setBindGroup(1,this.bindGroups.get(t.texName)),e.draw(4,t.instanceCount,0,t.instanceOffset);this.lifetime=_}destroy(){this.instanceBuffer.destroy(),this.tilesetDimBuffer.destroy()}}const S=1e5,K=5e4,_=30,st=16,T=12,L=8,ot=64,G=1e3,I=768,D=3,Z=1,y=1,J={shader:"default",inputs:[0],output:-1},Q=c=>1/(1<<Math.max(0,Math.floor((c-2)*.5))),ee=new C(0,0,0,1),nt=c=>{const e=document.createElement("canvas");switch(c){case"webgl":return new Ie(e);case"webgl2":return new He(e);case"webgpu":return new it(e);default:throw new Error("Unknown renderer type")}};class at{constructor(e){this.prev=null,this.next=null,this.value=e}}class lt{constructor(){this.head=null}insert(e){const t=new at(e);return t.next=this.head,this.head=t,t}remove(e){e.next&&(e.next.prev=e.prev),e.prev&&(e.prev.next=e.next),this.head===e&&(this.head=e.next),e.prev=null,e.next=null}[Symbol.iterator](){let e=this.head;return{next(){if(e){const t=e.value;return e=e.next,{value:t,done:!1}}return{value:void 0,done:!0}}}}}class ht{constructor(e,t){this.bounds=t,this.parent=e,this.queryId=0}}const X=class X{constructor(e){this.bounds=e.bounds,this.dimensions=e.dimensions,this.cells=this.cells=Array.from({length:e.dimensions[1]},()=>Array.from({length:e.dimensions[0]},()=>new lt))}findNearby(e){const t=++X.queryIds,i=this.getCellIndices(e.min),s=this.getCellIndices(e.max),r=[];for(let o=i[1];o<=s[1];++o)for(let a=i[0];a<=s[0];++a)for(let n of this.cells[o][a])n.queryId!==t&&(n.queryId=t,r.push(n));return r}createClient(e,t){const i=new ht(e,t);return this.insert(i),i}updateClient(e){const t=this.getCellIndices(e.bounds.min),i=this.getCellIndices(e.bounds.max);t[0]===e.cells.min[0]&&t[1]===e.cells.min[1]&&i[0]===e.cells.max[0]&&i[1]===e.cells.max[1]||(this.removeClient(e),this.insert(e))}removeClient(e){for(let t=e.cells.min[1];t<=e.cells.max[1];++t)for(let i=e.cells.min[0];i<=e.cells.max[0];++i)this.cells[t][i].remove(e.cells.nodes[t-e.cells.min[1]][i-e.cells.min[0]])}insert(e){const t=this.getCellIndices(e.bounds.min),i=this.getCellIndices(e.bounds.max),s=[];for(let r=t[1];r<=i[1];++r){s.push([]);for(let o=t[0];o<=i[0];++o){const a=this.cells[r][o].insert(e);s[r-t[1]].push(a)}}e.cells={min:t,max:i,nodes:s}}getCellIndices(e){const t=w.clamp(Math.floor((e.x-this.bounds.min.x)/(this.bounds.max.x-this.bounds.min.x)*this.dimensions[0]),0,this.dimensions[0]-1),i=w.clamp(Math.floor((e.y-this.bounds.min.y)/(this.bounds.max.y-this.bounds.min.y)*this.dimensions[1]),0,this.dimensions[1]-1);return[t,i]}};X.queryIds=0;let te=X;class de{constructor(e){this.zIndex=e.zIndex||0,this.tileset=e.tileset,this.tilesetRegion=e.tilesetRegion,this.isStatic=e.isStatic||!1,this.position=new x,this.offset=new x,this.scale=new x(1,1),this.angle=e.angle||0,this.tintColor=new C(1,1,1,1),this.maskColor=new C(0,0,0,1)}setTilesetRegion(e,t,i=1,s=1){this.tilesetRegion.x=e,this.tilesetRegion.y=t,this.tilesetRegion.width=i,this.tilesetRegion.height=s}getTile(){return this.tileset.getTile(this.tilesetRegion.x,this.tilesetRegion.y)}getBounds(){const e=Math.max(Math.abs(this.scale.x),Math.abs(this.scale.y)),t=new x(e,e),i=this.position.clone().add(this.offset).sub(t),s=i.clone().add(t).add(t);return{min:i,max:s}}}class ut{constructor(e){this.layers=[],this.ambientIntensity=e.ambientIntensity||1,this.ambientColor=e.ambientColor||new C(1,1,1),this.lights=[],this.colliders=[],this.shadowsZIndex=e.shadowsZIndex||0,this.collidersHashGrid=new te(e.spatialHashGridParams||{bounds:{min:new x(-1e3,-1e3),max:new x(1e3,1e3)},dimensions:[20,20]})}findLayerBySprite(e){return this.layers.find(t=>t.isStatic===e.isStatic&&t.zIndex===e.zIndex)}addLight(e){this.lights.push(e)}removeLight(e){const t=this.lights.indexOf(e);t!==-1&&this.lights.splice(t,1)}addSprite(e){let t;return t=this.findLayerBySprite(e),t||(t=this.createLayer({zIndex:e.zIndex,isStatic:e.isStatic})),t.add(e),e}removeSprite(e){const t=this.findLayerBySprite(e);t&&t.remove(e)}addTilemap(e,t={}){const i=e.getLayers();let s=0;const r=[],o=[];for(const a of i){const n=t.layers?.find(l=>l.name===a.name);switch(n?.zIndex&&(s=n.zIndex),a.renderOrder!=="manual"&&this.createLayer({zIndex:s,renderOrder:a.renderOrder,isStatic:!1}),a.type){case"tilelayer":{for(let l=0;l<a.height;++l)for(let h=0;h<a.width;++h){const u=a.getTile(h,l);if(!u)continue;const d=new de({isStatic:u.animation===void 0,zIndex:s,tileset:u.tileset,tilesetRegion:{x:u.x,y:u.y}});if(d.position.set((h+a.x)*e.tileWidth,(l+a.y)*e.tileHeight),d.scale.set(e.tileWidth,e.tileHeight),r.push(this.addSprite(d)),u.animation){const m=new B(d);m.play({x:u.x,y:u.y},{repeat:!0}),o.push(m)}}break}case"objectgroup":{if(t.onObject){const l=a.getObjects();for(const h of l)t.onObject(this,h,a,s)}break}}++s}return{sprites:r,animators:o}}createLayer(e){const t=new ct(e);return this.layers.push(t),t}getLayersOrdered(){return this.layers.sort((e,t)=>e.zIndex-t.zIndex)}getLights(){return this.lights}addCollider(e){return this.colliders.push({collider:e,hashGridClient:this.collidersHashGrid.createClient(e,e.getBounds())}),e}removeCollider(e){const t=this.colliders.findIndex(i=>i.collider===e);t!==-1&&(this.collidersHashGrid.removeClient(this.colliders[t].hashGridClient),this.colliders.splice(t,1))}getColliders(e){return this.collidersHashGrid.findNearby(e).map(t=>t.parent)}update(){for(let e of this.colliders)e.hashGridClient.bounds=e.collider.getBounds(),this.collidersHashGrid.updateClient(e.hashGridClient)}getInfo(){return{lights:this.lights.length,colliders:this.colliders.length,sprites:this.layers.reduce((e,t)=>e+t.sprites.length,0),staticSprites:this.layers.reduce((e,t)=>e+t.sprites.filter(i=>i.isStatic).length,0),layers:this.layers.length}}}class ct{constructor(e){this.zIndex=e.zIndex,this.isStatic=e.isStatic,this.renderOrder=e.renderOrder||"manual",this.sprites=[]}add(e){if(this.renderOrder==="manual"){let t=-1;for(let i=this.sprites.length-1;i>=0;--i)if(this.sprites[i].tileset.name<=e.tileset.name){t=i;break}t===-1?this.sprites.unshift(e):this.sprites.splice(t+1,0,e)}else this.sprites.push(e)}remove(e){const t=this.sprites.indexOf(e);t!==-1&&this.sprites.splice(t,1)}getSpritesOrdered(){switch(this.renderOrder){case"topdown":return this.sprites.sort((e,t)=>e.position.y-t.position.y);default:return this.sprites}}}class ge{constructor(e){this.name=e.name,this.x=e.x,this.y=e.y,this.width=e.width,this.height=e.height,this.type=e.type,this.renderOrder=e.draworder||"manual"}}class ft extends ge{constructor(e){super(e),this.data=e.data}getTile(e,t){const i=this.data[t*this.width+e];return i-1==-1?null:this.tilemap.getTileById(i)}}class dt{constructor(e,t,i,s,r,o){this.name=e,this.type=t,this.x=i,this.y=s,this.rotation=r||0,this.properties=o}getProperty(e){return this.properties?.find(t=>t.name===e)?.value}}class gt extends ge{constructor(e){super(e),this.objects=e.objects}getObjects(){return this.objects.map(e=>new dt(e.name,e.type,e.x,e.y,e.rotation,e.properties))}}class ie{constructor(e,t,i,s){this.width=e,this.height=t,this.tileWidth=i,this.tileHeight=s,this.tilesets=[],this.layers=[]}static async load(e,t){const i=await k.loadJson(e),s=new ie(i.width,i.height,i.tilewidth,i.tileheight);for(const r of i.layers)switch(r.type){case"tilelayer":s.addLayer(new ft(r));break;case"objectgroup":s.addLayer(new gt(r));break}for(let r of i.tilesets){let o;if(r.source){const a=r.source.split(/(\/|\\\/)/),n=a[a.length-1].split(".tsj")[0];if(!t[n])throw new Error("Source is missing for tileset: "+n);o=await P.load(t[n])}else o=new P(r);s.tilesets.push({tileset:o,firstGlobalId:r.firstgid})}return s}addLayer(e){e.tilemap=this,this.layers.push(e)}getTilesets(){return this.tilesets.map(e=>e.tileset)}getTilesetByName(e){return this.tilesets.find(t=>t.tileset.name===e)?.tileset||null}getLayers(){return this.layers}getLayerByName(e){return this.layers.find(t=>t.name===e)||null}getTileById(e){const t=this.tilesets;for(let i of t){let s=i.tileset.getTileById(e-i.firstGlobalId);if(s)return s}return null}}v.Animator=B,v.Camera=ve,v.Color=C,v.Light=Te,v.LinearSpline=pe,v.LinearSplineVector=xe,v.Scene=ut,v.ShaderBuilder=M,v.Sprite=de,v.Tilemap=ie,v.Tileset=P,v.Vector=x,v.assets=k,v.colliders=we,v.createRenderer=nt,v.math=w,v.matrix=Ce,Object.defineProperty(v,Symbol.toStringTag,{value:"Module"})}));
