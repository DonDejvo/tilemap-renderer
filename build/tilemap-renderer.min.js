var TilemapRenderer=(function(v){"use strict";class N{constructor(e,t,i,s){this.x=e,this.y=t,this.w=i,this.h=s}intersects(e){return this.x<e.x+e.w&&this.x+this.w>e.x&&this.y<e.y+e.h&&this.y+this.h>e.y}}class ee{constructor(e){this.repeat=!0,this.currentFrameIndex=0,this.frameTimer=0,this.sprite=e,this.animation=null}play(e,t={}){const i=this.sprite.tileset.getTile(e.x,e.y);if(!i)return;const s=i.animation||[{tileid:i.id,duration:100}];if(!t.restart&&this.animation===s)return;this.animation=s,this.repeat=t.repeat??!0,this.currentFrameIndex=0,this.frameTimer=0;const r=this.animation[0],o=this.sprite.tileset.getTileXY(r.tileid);this.sprite.setTilesetRegion(o.x,o.y)}update(e){if(!this.animation)return;const t=this.animation[this.currentFrameIndex];if(this.frameTimer+=e*1e3,this.frameTimer<t.duration)return;if(this.frameTimer-=t.duration,this.currentFrameIndex++,this.currentFrameIndex>=this.animation.length)if(this.repeat)this.currentFrameIndex=0;else{this.currentFrameIndex=this.animation.length-1,this.onEnded?.(this.animation),this.animation=null;return}const i=this.animation[this.currentFrameIndex],s=this.sprite.tileset.getTileXY(i.tileid);this.sprite.setTilesetRegion(s.x,s.y)}}const X={loadImage:t=>new Promise((i,s)=>{const r=new Image;r.crossOrigin="anonymous",r.src=t,r.onload=()=>{i(r)},r.onerror=()=>{s()}}),loadJson:async t=>{try{return await(await fetch(t)).json()}catch{throw new Error(`Failed to load: ${t}`)}}},U={create:()=>new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]),identity:r=>(r[0]=1,r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[5]=1,r[6]=0,r[7]=0,r[8]=0,r[9]=0,r[10]=1,r[11]=0,r[12]=0,r[13]=0,r[14]=0,r[15]=1,r),createOrtho:(r,o,n,a,h)=>(r[0]=2/(n-o),r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[5]=2/(h-a),r[6]=0,r[7]=0,r[8]=0,r[9]=0,r[10]=1,r[11]=0,r[12]=-(n+o)/(n-o),r[13]=-(h+a)/(h-a),r[14]=0,r[15]=1,r),translate:(r,o)=>(r[12]+=o.x,r[13]+=o.y,r),scale:(r,o)=>(r[0]*=o.x,r[1]*=o.x,r[4]*=o.y,r[5]*=o.y,r)},A=(()=>{const u=(o,n,a)=>Math.min(Math.max(o,n),a);return{clamp:u,lerp:(o,n,a)=>o+(n-o)*a,unlerp:(o,n,a)=>u((a-o)/(n-o),0,1),sat:o=>u(o,0,1),degToRad:o=>o/180*Math.PI,radToDeg:o=>o/Math.PI*180}})();class fe{constructor(e=[]){this.points=e}addPoint(e){this.points.push(e)}getValue(e){const t=this.points.length;if(t===0)return 0;if(e<=0)return this.points[0];if(e>=t-1)return this.points[t-1];const i=Math.floor(e),s=e-i;return A.lerp(this.points[i],this.points[i+1],s)}}class x{constructor(e=0,t=0){this.x=e,this.y=t}set(e,t){return this.x=e,this.y=t,this}copy(e){return this.x=e.x,this.y=e.y,this}clone(){return new x(this.x,this.y)}add(e){return this.x+=e.x,this.y+=e.y,this}sub(e){return this.x-=e.x,this.y-=e.y,this}scale(e){return this.x*=e,this.y*=e,this}mul(e){return this.x*=e.x,this.y*=e.y,this}div(e){return e!==0?(this.x/=e,this.y/=e):(this.x=0,this.y=0),this}static dot(e,t){return e.x*t.x+e.y*t.y}static cross(e,t){return e.x*t.y-e.y*t.x}len(){return Math.sqrt(this.x*this.x+this.y*this.y)}lenSq(){return this.x*this.x+this.y*this.y}normalize(){const e=this.len();return e>0&&this.div(e),this}project(e){const t=e.lenSq();if(t===0)return this.scale(0);const i=x.dot(this,e);return this.copy(e).scale(i/t)}static distance(e,t){const i=e.x-t.x,s=e.y-t.y;return Math.sqrt(i*i+s*s)}angle(){return Math.atan2(this.y,this.x)}rot(e){const t=Math.cos(e),i=Math.sin(e),s=this.x*t-this.y*i,r=this.x*i+this.y*t;return this.x=s,this.y=r,this}static fromAngle(e,t=1){return new x(-Math.sin(e)*t,Math.cos(e)*t)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this}toString(){return`Vector(${this.x}, ${this.y})`}toArray(){return new Float32Array([this.x,this.y])}}class de{constructor(e=[]){this.points=e.slice().sort((t,i)=>t.x-i.x)}addPoint(e){this.points.push(e),this.points.sort((t,i)=>t.x-i.x)}getValue(e){const t=this.points.length;if(t===0)return new x;if(e<=this.points[0].x)return this.points[0].clone();if(e>=this.points[t-1].x)return this.points[t-1].clone();for(let i=0;i<t-1;i++){const s=this.points[i],r=this.points[i+1];if(e>=s.x&&e<=r.x){const o=A.unlerp(s.x,r.x,e);return s.clone().lerp(r,o)}}return new x}}class ge{constructor(e,t){this.projectionMatrix=U.create(),this.viewMatrix=U.create(),this.position=new x,this.zoom=1,this.vw=0,this.vh=0,this.updateProjection(e,t)}updateProjection(e,t){this.vw=e,this.vh=t}update(){U.identity(this.viewMatrix),U.translate(this.viewMatrix,new x(-this.position.x,-this.position.y));const e=this.vw*.5/this.zoom,t=this.vh*.5/this.zoom;U.createOrtho(this.projectionMatrix,-e,e,-t,t)}}class te{constructor(){this.position=new x}}class me extends te{getType(){return"circle"}constructor(e){super(),this.radius=e}getBounds(){return new N(this.position.x-this.radius,this.position.y-this.radius,this.radius*2,this.radius*2)}}class ie extends te{getType(){return"polygon"}constructor(e){super(),this.points=e}getBounds(){let e=1/0,t=1/0,i=-1/0,s=-1/0;for(const r of this.points){const o=r.x+this.position.x,n=r.y+this.position.y;o<e&&(e=o),n<t&&(t=n),o>i&&(i=o),n>s&&(s=n)}return new N(e,t,i-e,s-t)}}class pe extends ie{constructor(e,t){const i=e*.5,s=t*.5,r=[new x(-i,-s),new x(i,-s),new x(i,s),new x(-i,s)];super(r),this.width=e,this.height=t}}const xe={CircleCollider:me,PolygonCollider:ie,BoxCollider:pe};class C{constructor(e,t,i,s=1){this.r=e,this.g=t,this.b=i,this.a=s}set(e,t,i,s){this.r=e,this.g=t,this.b=i,this.a=s}copy(e){this.r=e.r,this.g=e.g,this.b=e.b,this.a=e.a}toArray(){return new Float32Array([this.r,this.g,this.b,this.a])}}class ve{constructor(e){this.position=e.position||new x,this.color=e.color||new C(1,1,1),this.intensity=e.intensity||1,this.radius=e.radius,this.direction=e.direction||new x(0,1),this.cutoff=e.cutoff||0}}const b=(()=>{const u=new Float32Array([0,1,0,0,0,0,0,1,1,1,1,0,1,0,1,1]),e=new Float32Array([-1,1,0,0,-1,-1,0,1,1,1,1,0,1,-1,1,1]),t=68,i=(h,f=!1)=>{const c=f?1:4,m=t,g=new ArrayBuffer(h.length*c*m),l=new DataView(g);let p=0;for(const d of h){const w=d.position.x,R=d.position.y,S=d.scale.x,D=d.scale.y,Z=d.angle,Q=d.tilesetRegion.x*(d.tileset.tileWidth+d.tileset.spacing)+d.tileset.margin,L=d.tilesetRegion.y*(d.tileset.tileHeight+d.tileset.spacing)+d.tileset.margin,G=d.tileset.tileWidth+((d.tilesetRegion.width||1)-1)*(d.tileset.tileWidth+d.tileset.spacing),st=d.tileset.tileHeight+((d.tilesetRegion.height||1)-1)*(d.tileset.tileHeight+d.tileset.spacing);for(let ce=0;ce<c;++ce)l.setFloat32(p,w,!0),l.setFloat32(p+4,R,!0),l.setFloat32(p+8,S,!0),l.setFloat32(p+12,D,!0),l.setFloat32(p+16,Z,!0),l.setUint16(p+20,Q,!0),l.setUint16(p+22,L,!0),l.setUint16(p+24,G,!0),l.setUint16(p+26,st,!0),l.setFloat32(p+28,d.tintColor.r,!0),l.setFloat32(p+32,d.tintColor.g,!0),l.setFloat32(p+36,d.tintColor.b,!0),l.setFloat32(p+40,d.tintColor.a,!0),l.setFloat32(p+44,d.maskColor.r,!0),l.setFloat32(p+48,d.maskColor.g,!0),l.setFloat32(p+52,d.maskColor.b,!0),l.setFloat32(p+56,d.maskColor.a,!0),l.setFloat32(p+60,d.offset.x,!0),l.setFloat32(p+64,d.offset.y,!0),p+=m}return g},s=48,r=(h,f=!1)=>{const c=f?1:4,m=new Float32Array(h.length*64);let g=0;for(let l of h)for(let p=0;p<c;++p)m.set(l.position.toArray(),g),m[g+2]=l.radius,m.set(l.color.toArray(),g+4),m[g+7]=l.intensity,m.set(l.direction.toArray(),g+8),m[g+10]=l.cutoff,g+=64;return m},o=(h,f)=>{const c=f.position.clone().sub(h.position).normalize(),m=new x(-c.y,c.x).scale(f.radius),g=f.position.clone().sub(m),l=f.position.clone().add(m),p=g.clone().sub(h.position).normalize(),d=l.clone().sub(h.position).normalize(),w=h.radius,R=g.clone().add(p.scale(w)),S=l.clone().add(d.scale(w));return[g.x,g.y,l.x,l.y,R.x,R.y,R.x,R.y,l.x,l.y,S.x,S.y]},n=(h,f)=>{const c=[],m=h.radius,g=f.points.map(l=>l.clone().add(f.position));for(let l=0;l<g.length;l++){const p=g[l],d=g[(l+1)%g.length],R=p.clone().add(d).scale(.5).clone().sub(h.position).normalize(),S=d.clone().sub(p).normalize(),D=new x(-S.y,S.x);if(x.dot(D,R)<0&&D.scale(-1),x.dot(D,R)<=0)continue;const Z=p.clone().sub(h.position).normalize(),Q=d.clone().sub(h.position).normalize(),L=p.clone().add(Z.scale(m)),G=d.clone().add(Q.scale(m));c.push(p.x,p.y,d.x,d.y,L.x,L.y,L.x,L.y,d.x,d.y,G.x,G.y)}return c};return{quad:u,fullscreenQuad:e,spriteStride:t,createSpritesData:i,lightStride:s,createLightsGeometry:r,createShadowsGeometry:(h,f)=>{const c=[],m=[];for(let g of h){let l=c.length/2;for(let p of f)switch(p.getType()){case"circle":c.push(...o(g,p));break;case"polygon":c.push(...n(g,p));break}m.push({count:c.length/2-l,offset:l})}return{drawCalls:m,vertices:new Float32Array(c)}}}})(),be=u=>{switch(u){case"float":return 1;case"vec2":return 2;case"vec3":return 3;case"vec4":return 4}};class I{constructor(){this.ops=[],this.uniforms=[],this.uniformOffset=0,this.uniform("resolution","vec2"),this.uniform("time","float")}declare(e,t){return this.ops.push([0,e,t]),this}set(e,t){return this.ops.push([1,e,t]),this}add(e,t){return this.ops.push([2,e,t]),this}sub(e,t){return this.ops.push([3,e,t]),this}mul(e,t){return this.ops.push([4,e,t]),this}div(e,t){return this.ops.push([5,e,t]),this}if(e){return this.ops.push([7,e]),this}elseif(e){return this.ops.push([8,e]),this}else(){return this.ops.push([9]),this}endif(){return this.ops.push([10]),this}uniform(e,t){return this.uniforms.push({name:e,type:t,offset:this.uniformOffset}),this.uniformOffset+=be(t),this}getUniforms(){return this.uniforms}build(e){const t=[];for(const i of this.ops){const[s,...r]=i;switch(s){case 0:{const[o,n,a]=i,h=e.getBuilderOptions().declareVar(n,a);t.push(h);break}case 1:case 2:case 3:case 4:case 5:{const o=r[0],n=r[1],a=`${o} ${this.getOpAssignmentSymbol(s)} ${n};`;t.push(this.replaceExpression(e,a));break}case 7:case 8:{const o=r[0];t.push(`${s===7?"":"} else "}if (${this.replaceExpression(e,o)}) {`);break}case 9:case 10:{t.push("}"+(s===10?"":" else {"));break}}}return{mainImage:t,uniforms:this.uniforms.map(i=>e.getBuilderOptions().declareVar(i.name,i.type,!0))}}getOpAssignmentSymbol(e){switch(e){case 1:return"=";case 2:return"+=";case 3:return"-=";case 4:return"*=";case 5:return"/=";default:return""}}replaceExpression(e,t){if(e.getType()!=="webgpu")for(let i=0;i<B;++i)t=t.replace(new RegExp("texture\\s*\\(\\s*"+i+"\\s*,","g"),"texture(uChannel"+i+", ");return this.replaceComponents(e,t)}replaceComponents(e,t){const i=e.getBuilderOptions().componentMap;return t.replace(/\.[rgba]{1,4}\b/g,s=>{const r=s.substring(1);let o=".";for(let n=0;n<r.length;++n){const a=r[n];o+=i[a]??a}return o})}}const F=new I().declare("uv","vec2").set("uv","fragCoord / uniforms.resolution").add("fragColor","texture(0, uv)"),k=new I().declare("uv","vec2").declare("baseColor","vec4").set("uv","fragCoord / uniforms.resolution").set("baseColor","texture(0, uv)").add("fragColor","vec4(baseColor.rgb * texture(1, uv).rgb, baseColor.a)"),z=new I().declare("uv","vec2").declare("w","float").declare("sum","vec4").set("uv","fragCoord / uniforms.resolution").set("w","1.0 / uniforms.resolution.x").set("sum",`(
    texture(0, uv + vec2(-3.0 * w, 0.0)) * 0.05 +
    texture(0, uv + vec2(-2.0 * w, 0.0)) * 0.1 +
    texture(0, uv + vec2(-1.0 * w, 0.0)) * 0.2 +
    texture(0, uv) * 0.3 +
    texture(0, uv + vec2(1.0 * w, 0.0)) * 0.2 +
    texture(0, uv + vec2(2.0 * w, 0.0)) * 0.1 +
    texture(0, uv + vec2(3.0 * w, 0.0)) * 0.05
)`).set("fragColor","sum"),Y=new I().declare("uv","vec2").declare("h","float").declare("sum","vec4").set("uv","fragCoord / uniforms.resolution").set("h","1.0 / uniforms.resolution.y").set("sum",`(
    texture(0, uv + vec2(0.0, -3.0 * h)) * 0.05 +
    texture(0, uv + vec2(0.0, -2.0 * h)) * 0.1 +
    texture(0, uv + vec2(0.0, -1.0 * h)) * 0.2 +
    texture(0, uv) * 0.3 +
    texture(0, uv + vec2(0.0, 1.0 * h)) * 0.2 +
    texture(0, uv + vec2(0.0, 2.0 * h)) * 0.1 +
    texture(0, uv + vec2(0.0, 3.0 * h)) * 0.05
)`).set("fragColor","sum");class re{constructor(e,t,i){this.gl=e,this.width=t,this.height=i,this.texture=e.createTexture(),e.bindTexture(e.TEXTURE_2D,this.texture),e.texImage2D(e.TEXTURE_2D,0,e.RGBA,t,i,0,e.RGBA,e.UNSIGNED_BYTE,null),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.LINEAR),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.LINEAR),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),this.fbo=e.createFramebuffer(),e.bindFramebuffer(e.FRAMEBUFFER,this.fbo),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,this.texture,0),e.checkFramebufferStatus(e.FRAMEBUFFER)!==e.FRAMEBUFFER_COMPLETE&&console.error("Framebuffer incomplete!"),e.bindFramebuffer(e.FRAMEBUFFER,null),e.bindTexture(e.TEXTURE_2D,null)}bind(){this.gl.bindFramebuffer(this.gl.FRAMEBUFFER,this.fbo),this.gl.viewport(0,0,this.width,this.height)}unbind(){this.gl.bindFramebuffer(this.gl.FRAMEBUFFER,null)}destroy(){this.gl.deleteFramebuffer(this.fbo),this.gl.deleteTexture(this.texture)}}class P{constructor(e,t,i){this.gl=e,this.uniforms=new Map,this.attribs=new Map;const s=this.compileShader(e.VERTEX_SHADER,t),r=this.compileShader(e.FRAGMENT_SHADER,i);if(this.program=e.createProgram(),e.attachShader(this.program,s),e.attachShader(this.program,r),e.linkProgram(this.program),!e.getProgramParameter(this.program,e.LINK_STATUS))throw new Error(e.getProgramInfoLog(this.program)??"Could not link program");e.deleteShader(s),e.deleteShader(r)}compileShader(e,t){const i=this.gl.createShader(e);if(!i)throw new Error("Could not create shader");if(this.gl.shaderSource(i,t),this.gl.compileShader(i),!this.gl.getShaderParameter(i,this.gl.COMPILE_STATUS))throw new Error(this.gl.getShaderInfoLog(i)??"Could not compile shader");return i}use(){this.gl.useProgram(this.program)}getUniform(e){if(!this.uniforms.has(e)){const t=this.gl.getUniformLocation(this.program,e);this.uniforms.set(e,t)}return this.uniforms.get(e)}getAttrib(e){return this.attribs.has(e)||this.attribs.set(e,this.gl.getAttribLocation(this.program,e)),this.attribs.get(e)}}const se=`

attribute vec2 aVertexPos;
attribute vec2 aTexCoord;
attribute vec2 aTilePos;
attribute float aTileAngle;
attribute vec2 aTileScale;
attribute vec4 aTileRegion;
attribute vec4 aTintColor;
attribute vec4 aMaskColor;
attribute vec2 aTileOffset;

uniform vec2 uViewportDimensions;
uniform vec2 uCameraPos;

uniform vec2 uTilesetDimensions;

varying vec2 uv;
varying vec4 tintColor;
varying vec4 maskColor;

void main() {
    tintColor = aTintColor;
    maskColor = aMaskColor;

    vec2 flippedTexCoord = vec2(aTexCoord.x, 1.0 - aTexCoord.y);
    uv = (vec2(aTileRegion.xy) + flippedTexCoord * vec2(aTileRegion.zw)) / uTilesetDimensions;

    float c = cos(aTileAngle);
    float s = sin(aTileAngle);
    vec2 offsetPos = aVertexPos * aTileScale + aTileOffset;
    vec2 rotatedPos = vec2(
        offsetPos.x * c - offsetPos.y * s,
        offsetPos.x * s + offsetPos.y * c
    );
    vec2 worldPos = rotatedPos + aTilePos;
    vec2 pixelPos = worldPos - uCameraPos;
    vec2 clipPos = vec2(pixelPos.x / uViewportDimensions.x, 1.0 - pixelPos.y / uViewportDimensions.y) * 2.0 - 1.0;
    gl_Position = vec4(clipPos, 0.0, 1.0);
}
`,ye=`

precision mediump float;

varying vec2 uv;
varying vec4 tintColor;

uniform sampler2D uSampler;  

void main() {
    gl_FragColor = texture2D(uSampler, uv) * tintColor;
}
`,Te=`

precision mediump float;

varying vec2 uv;
varying vec4 maskColor;

uniform mediump sampler2D uSampler;  

void main() {
    vec4 texColor = texture2D(uSampler, uv);
    gl_FragColor = vec4(maskColor.rgb, texColor.a * maskColor.a);
}
`,we=`

attribute vec2 aPos;

void main() {
    gl_Position = vec4(aPos, 0.0, 1.0);
}
`,Ae=u=>`
#define texture texture2D

precision mediump float;

struct Uniforms {
${u.uniforms.map(e=>"    "+e).join(`
`)}
};

uniform sampler2D uChannel0;
uniform sampler2D uChannel1;
uniform sampler2D uChannel2;
uniform sampler2D uChannel3;
uniform sampler2D uChannel4;
uniform sampler2D uChannel5;
uniform sampler2D uChannel6;
uniform sampler2D uChannel7;

uniform Uniforms uniforms;

void mainImage(out vec4 fragColor, in vec2 fragCoord) {
${u.mainImage.map(e=>"    "+e).join(`
`)}
}

void main() {
    vec2 fragCoord = vec2(gl_FragCoord.x, gl_FragCoord.y);
    mainImage(gl_FragColor, fragCoord);
}
`,Ce={componentMap:{r:"r",g:"g",b:"b",a:"a"},declareVar:(u,e)=>`${e} ${u};`};class Re{constructor(e){this.canvas=e,this.layersMap=new Map,this.texturesMap=new Map,this.clearColor=new C(0,0,0,0),this.shaderMap=new Map,this.initialized=!1,this.pass=[q],this.framebuffers=[],this.shaderCache=new Map}getType(){return"webgl"}getBuilderOptions(){return Ce}addTextures(e,t){for(const i of e)t[i.name]&&this.texturesMap.set(i.name,{tileset:i,image:t[i.name]})}registerShader(e,t,i="none"){this.shaderMap.set(e,{builder:t,blendMode:i})}setClearColor(e){this.clearColor.copy(e)}setSize(e,t){this.canvas.width=e,this.canvas.height=t,this.initialized&&this.initFramebuffers()}getCanvas(){return this.canvas}initFramebuffers(){for(let e=0;e<T;++e){const t=K(e);this.framebuffers[e]?.destroy(),this.framebuffers[e]=new re(this.gl,this.canvas.width*t,this.canvas.height*t)}}async init(){const e=this.canvas.getContext("webgl");if(!e)throw new Error("WebGL not supported");this.gl=e;for(const r of this.texturesMap.values())r.tileset&&(r.texture=this.createTexture(r.image));this.registerShader("default",F),this.registerShader("default_additive",F,"additive"),this.registerShader("light",k),this.registerShader("blurHorizontal",z),this.registerShader("blurVertical",Y);for(const r of this.shaderMap.values()){if(!this.shaderCache.has(r.builder)){const o=r.builder.build(this),n=new P(e,we,Ae(o));this.shaderCache.set(r.builder,n)}r.shader=this.shaderCache.get(r.builder)}this.shaderProgram=new P(e,se,ye),this.maskShaderProgram=new P(e,se,Te),this.vbo=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.vbo);const t=new Float32Array(E*4*4);for(let r=0;r<E;++r)t.set(b.quad,r*4*4);e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW);const i=[0,1,2,1,2,3];this.ebo=e.createBuffer(),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,this.ebo);const s=new Uint16Array(E*6);for(let r=0;r<E;++r)for(let o=0;o<6;++o)s[r*6+o]=i[o]+4*r;e.bufferData(e.ELEMENT_ARRAY_BUFFER,s,e.STATIC_DRAW),e.enable(e.BLEND),e.blendFunc(e.SRC_ALPHA,e.ONE_MINUS_SRC_ALPHA),this.initFramebuffers(),this.fullscreenVbo=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.fullscreenVbo),e.bufferData(e.ARRAY_BUFFER,b.fullscreenQuad,e.STATIC_DRAW),this.initialized=!0}renderScene(e,t,i,s,r){e.bind(),this.gl.clearColor(s.r,s.g,s.b,s.a),this.gl.clear(this.gl.COLOR_BUFFER_BIT),t.use(),this.gl.uniform2f(t.getUniform("uViewportDimensions"),i.vw,i.vh),this.gl.uniform2f(t.getUniform("uCameraPos"),i.position.x,i.position.y),this.gl.activeTexture(this.gl.TEXTURE0);for(let o of r)o.render(t);e.unbind()}render(e,t){const i=[];for(const r of e.getLayersOrdered()){if(!this.layersMap.has(r)){const n=new Pe(this.gl,this,r.isStatic);this.layersMap.set(r,n)}const o=this.layersMap.get(r);o.needsUpdate&&o.upload(r.getSpritesOrdered()),i.push(o)}this.renderScene(this.framebuffers[0],this.shaderProgram,t,this.clearColor,i),this.renderScene(this.framebuffers[1],this.maskShaderProgram,t,j,i);const s=performance.now()*.001;for(let r=0;r<this.pass.length;++r){const o=this.pass[r],n=this.shaderMap.get(o.shader);if(!n)throw new Error("Unknown shader "+o.shader);const a=n.shader;let h=this.canvas.width,f=this.canvas.height;if(o.output!==-1){const l=this.framebuffers[A.clamp(o.output,0,T-1)];h=l.width,f=l.height,l.bind()}else this.gl.viewport(0,0,h,f);a.use();const c=[{name:"time",value:s},{name:"resolution",value:[h,f]}].concat(o.uniforms??[]),m=n.builder.getUniforms();for(let l of m){const p=c.find(d=>d.name===l.name);if(p){const d=typeof p.value=="number"?[p.value]:p.value,w=a.getUniform("uniforms."+l.name);switch(l.type){case"float":this.gl.uniform1f(w,d[0]);break;case"vec2":this.gl.uniform2fv(w,d);break;case"vec3":this.gl.uniform3fv(w,d);break;case"vec4":this.gl.uniform4fv(w,d);break}}}for(let l=0;l<B;l++){const p=o.inputs[l]??o.inputs[0],d=this.framebuffers[A.clamp(p,0,T-1)].texture;this.gl.activeTexture(this.gl.TEXTURE0+l),this.gl.bindTexture(this.gl.TEXTURE_2D,d);const w=a.getUniform(`uChannel${l}`);this.gl.uniform1i(w,l)}const g=a.getAttrib("aPos");this.gl.bindBuffer(this.gl.ARRAY_BUFFER,this.fullscreenVbo),this.gl.enableVertexAttribArray(g),this.gl.vertexAttribPointer(g,2,this.gl.FLOAT,!1,16,0),this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),this.gl.disableVertexAttribArray(g);for(let l=0;l<B;l++)this.gl.activeTexture(this.gl.TEXTURE0+l),this.gl.bindTexture(this.gl.TEXTURE_2D,null);o.output!==-1&&this.framebuffers[A.clamp(o.output,0,T-1)].unbind()}for(const[r,o]of this.layersMap)o.lifetime<=0&&(this.layersMap.delete(r),o.destroy())}getTextureInfo(e){const t=this.texturesMap.get(e);if(!t)throw new Error("Texture not found: "+e);return t}getVBO(){return this.vbo}getEBO(){return this.ebo}createTexture(e){const t=this.gl,i=t.createTexture();return t.bindTexture(t.TEXTURE_2D,i),t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,e),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.NEAREST),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,t.NEAREST),i}}let Pe=class{constructor(e,t,i){this.gl=e,this.renderer=t,this.isStatic=i,this.needsUpdate=!0,this.drawCalls=[],this.lifetime=_,this.spriteBuffer=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.spriteBuffer),e.bufferData(e.ARRAY_BUFFER,(this.isStatic?E:$)*b.spriteStride*4,this.isStatic?e.STATIC_DRAW:e.DYNAMIC_DRAW)}upload(e){const t=this.gl;t.bindBuffer(t.ARRAY_BUFFER,this.spriteBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,b.createSpritesData(e)),this.isStatic&&(this.needsUpdate=!1),this.drawCalls.length=0;let i=null;for(let s=0;s<e.length;++s){const r=e[s].tileset.name;!i||r!==i.texName?(i={texName:r,spriteOffset:s,spriteCount:1},this.drawCalls.push(i)):i.spriteCount++}}render(e){const t=this.gl;t.bindBuffer(t.ARRAY_BUFFER,this.renderer.getVBO());const i={vertexPos:e.getAttrib("aVertexPos"),texCoord:e.getAttrib("aTexCoord"),tilePos:e.getAttrib("aTilePos"),tileScale:e.getAttrib("aTileScale"),tileAngle:e.getAttrib("aTileAngle"),tileRegion:e.getAttrib("aTileRegion"),tintColor:e.getAttrib("aTintColor"),maskColor:e.getAttrib("aMaskColor"),tileOffset:e.getAttrib("aTileOffset")};t.enableVertexAttribArray(i.vertexPos),t.vertexAttribPointer(i.vertexPos,2,t.FLOAT,!1,16,0),t.enableVertexAttribArray(i.texCoord),t.vertexAttribPointer(i.texCoord,2,t.FLOAT,!1,16,8),t.bindBuffer(t.ARRAY_BUFFER,this.spriteBuffer);const s=b.spriteStride;t.enableVertexAttribArray(i.tilePos),t.vertexAttribPointer(i.tilePos,2,t.FLOAT,!1,s,0),t.enableVertexAttribArray(i.tileScale),t.vertexAttribPointer(i.tileScale,2,t.FLOAT,!1,s,8),t.enableVertexAttribArray(i.tileAngle),t.vertexAttribPointer(i.tileAngle,1,t.FLOAT,!1,s,16),t.enableVertexAttribArray(i.tileRegion),t.vertexAttribPointer(i.tileRegion,4,t.UNSIGNED_SHORT,!1,s,20),t.enableVertexAttribArray(i.tintColor),t.vertexAttribPointer(i.tintColor,4,t.FLOAT,!1,s,28),t.enableVertexAttribArray(i.maskColor),t.vertexAttribPointer(i.maskColor,4,t.FLOAT,!1,s,44),t.enableVertexAttribArray(i.tileOffset),t.vertexAttribPointer(i.tileOffset,2,t.FLOAT,!1,s,60),t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.renderer.getEBO());for(const r of this.drawCalls){const o=this.renderer.getTextureInfo(r.texName);t.bindTexture(t.TEXTURE_2D,o.texture),this.gl.uniform2f(e.getUniform("uTilesetDimensions"),o.tileset.imageWidth,o.tileset.imageHeight),t.drawElements(t.TRIANGLES,6*r.spriteCount,t.UNSIGNED_SHORT,r.spriteOffset*6*2)}t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null),t.disableVertexAttribArray(i.vertexPos),t.disableVertexAttribArray(i.texCoord),t.disableVertexAttribArray(i.tilePos),t.disableVertexAttribArray(i.tileScale),t.disableVertexAttribArray(i.tileAngle),t.disableVertexAttribArray(i.tileRegion),t.disableVertexAttribArray(i.tintColor),t.disableVertexAttribArray(i.maskColor),this.lifetime=_}destroy(){this.gl.deleteBuffer(this.spriteBuffer)}};const W=`
vec4 worldToClip(vec2 worldPos, vec2 cameraPos, vec2 viewport) {
    vec2 pixelPos = worldPos - cameraPos;
    vec2 clipPos = vec2(pixelPos.x / viewport.x, 1.0 - pixelPos.y / viewport.y) * 2.0 - 1.0;
    return vec4(clipPos, 0.0, 1.0);
}
`,oe=`#version 300 es

layout(location = 0) in vec2 aVertexPos;
layout(location = 1) in vec2 aTexCoord;

layout(location = 2) in vec2 aTilePos;
layout(location = 3) in vec2 aTileScale;
layout(location = 4) in float aTileAngle;
layout(location = 5) in uvec4 aTileRegion;

layout(location = 6) in vec4 aTintColor;
layout(location = 7) in vec4 aMaskColor;

layout(location = 8) in vec2 aTileOffset;

uniform vec2 uViewportDimensions;
uniform vec2 uCameraPos;

uniform vec2 uTilesetDimensions;

out vec2 uv;
out vec4 tintColor;
out vec4 maskColor;

${W}

void main() {
    tintColor = aTintColor;
    maskColor = aMaskColor;

    vec2 flippedTexCoord = vec2(aTexCoord.x, 1.0 - aTexCoord.y);
    uv = (vec2(aTileRegion.xy) + flippedTexCoord * vec2(aTileRegion.zw)) / uTilesetDimensions;

    float c = cos(aTileAngle);
    float s = sin(aTileAngle);
    vec2 offsetPos = aVertexPos * aTileScale + aTileOffset;
    vec2 rotatedPos = vec2(
        offsetPos.x * c - offsetPos.y * s,
        offsetPos.x * s + offsetPos.y * c
    );
    vec2 worldPos = rotatedPos + aTilePos;

    gl_Position = worldToClip(worldPos, uCameraPos, uViewportDimensions);
}
`,Ee=`#version 300 es

precision mediump float;

in vec2 uv;
in vec4 tintColor;

uniform mediump sampler2D uSampler;

out vec4 fragColor;

void main() {
    fragColor = texture(uSampler, uv) * tintColor;
}
`,Se=`#version 300 es

precision mediump float;

in vec2 uv;
in vec4 maskColor;

uniform mediump sampler2D uSampler;  

out vec4 fragColor;

void main() {
    vec4 texColor = texture(uSampler, uv);
    fragColor = vec4(maskColor.rgb, texColor.a * maskColor.a);
}
`,Ue=`#version 300 es
precision mediump float;

layout(location = 0) in vec2 aVertexPos;

uniform vec2 uLightCenter;
uniform float uLightRadius;

uniform vec2 uCameraPos;
uniform vec2 uViewportDimensions;

out vec2 worldPos;

${W}

void main() {
    worldPos = uLightCenter + (aVertexPos - 0.5) * 2.0 * uLightRadius;

    gl_Position = worldToClip(worldPos, uCameraPos, uViewportDimensions);
}
`,Fe=`#version 300 es

precision mediump float;

in vec2 worldPos;

uniform vec2 uLightCenter;
uniform float uLightRadius;
uniform vec3 uLightColor;
uniform float uLightIntensity;
uniform vec2 uLightDir;
uniform float uLightCutoff;

out vec4 fragColor;

void main() {
    vec2 toPixel = worldPos - uLightCenter;
    float dist = length(toPixel);

    float attenuation = clamp(1.0 - pow(dist / uLightRadius, 2.0), 0.0, 1.0);

    float spotFactor = 1.0;
    if (uLightCutoff > 0.0) {
        float cosAngle = dot(normalize(uLightDir), normalize(toPixel));
        spotFactor = clamp((cosAngle - uLightCutoff) / (1.0 - uLightCutoff), 0.0, 1.0);
    }

    fragColor = vec4(uLightColor * uLightIntensity * attenuation * spotFactor, 1.0);
}
`,_e=`#version 300 es

layout(location = 0) in vec2 aPos;

uniform vec2 uCameraPos;
uniform vec2 uViewportDimensions;

${W}

void main() {
    gl_Position = worldToClip(aPos, uCameraPos, uViewportDimensions);
}
`,Be=`#version 300 es

precision mediump float;

uniform vec2 uLightPos;

out vec4 fragColor;

void main() {
    fragColor = vec4(vec3(0.0), 1.0);
}
`,Le=`#version 300 es

out vec2 uv;

void main() {
    float x = float((gl_VertexID & 1) << 2);
    float y = float((gl_VertexID & 2) << 1);

    gl_Position = vec4(x - 1.0, y - 1.0, 0.0, 1.0);
}
`,Ie=u=>`#version 300 es
precision mediump float;

struct Uniforms {
${u.uniforms.map(e=>"    "+e).join(`
`)}
};

uniform sampler2D uChannel0;
uniform sampler2D uChannel1;
uniform sampler2D uChannel2;
uniform sampler2D uChannel3;
uniform sampler2D uChannel4;
uniform sampler2D uChannel5;
uniform sampler2D uChannel6;
uniform sampler2D uChannel7;

uniform Uniforms uniforms;

out vec4 fragColor;

void mainImage(out vec4 fragColor, in vec2 fragCoord) {
${u.mainImage.map(e=>"    "+e).join(`
`)}
}

void main() {
    vec2 fragCoord = gl_FragCoord.xy;
    mainImage(fragColor, fragCoord);
}
`,Me={componentMap:{r:"r",g:"g",b:"b",a:"a"},declareVar:(u,e)=>`${e} ${u};`};class De{constructor(e){this.canvas=e,this.layersMap=new Map,this.texturesMap=new Map,this.clearColor=new C(0,0,0,0),this.shaderMap=new Map,this.initialized=!1,this.pass=[q],this.framebuffers=[],this.time=0,this.shaderCache=new Map}getType(){return"webgl2"}getBuilderOptions(){return Me}addTextures(e,t){for(const i of e)t[i.name]&&this.texturesMap.set(i.name,{tileset:i,image:t[i.name]})}registerShader(e,t,i="none"){this.shaderMap.set(e,{builder:t,blendMode:i})}setClearColor(e){this.clearColor.copy(e)}setSize(e,t){this.canvas.width=e,this.canvas.height=t,this.initialized&&this.initFramebuffers()}getCanvas(){return this.canvas}initFramebuffers(){for(let e=0;e<T;++e){const t=K(e);this.framebuffers[e]?.destroy(),this.framebuffers[e]=new re(this.gl,this.canvas.width*t,this.canvas.height*t)}}blend(e){switch(e){case"alpha":this.gl.enable(this.gl.BLEND),this.gl.blendFunc(this.gl.SRC_ALPHA,this.gl.ONE_MINUS_SRC_ALPHA);break;case"additive":this.gl.enable(this.gl.BLEND),this.gl.blendFunc(this.gl.ONE,this.gl.ONE);break;default:this.gl.disable(this.gl.BLEND)}}async init(){const e=this.canvas.getContext("webgl2");if(!e)throw new Error("WebGL2 not supported");this.gl=e;for(const t of this.texturesMap.values())t.tileset&&(t.texture=this.createTexture(t.image));this.initFramebuffers(),this.registerShader("default",F),this.registerShader("default_additive",F,"additive"),this.registerShader("light",k),this.registerShader("blurHorizontal",z),this.registerShader("blurVertical",Y);for(const t of this.shaderMap.values()){if(!this.shaderCache.has(t.builder)){const i=t.builder.build(this),s=new P(e,Le,Ie(i));this.shaderCache.set(t.builder,s)}t.shader=this.shaderCache.get(t.builder)}this.shaderProgram=new P(e,oe,Ee),this.maskShaderProgram=new P(e,oe,Se),this.lightShaderProgram=new P(e,Ue,Fe),this.shadowShaderProgram=new P(e,_e,Be),this.vbo=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.vbo),e.bufferData(e.ARRAY_BUFFER,b.quad,e.STATIC_DRAW),this.lightVao=e.createVertexArray(),e.bindVertexArray(this.lightVao),e.bindBuffer(e.ARRAY_BUFFER,this.vbo),e.enableVertexAttribArray(0),e.vertexAttribPointer(0,2,e.FLOAT,!1,16,0),e.bindVertexArray(null),this.shadowsVbo=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.shadowsVbo),e.bufferData(e.ARRAY_BUFFER,12e4,e.DYNAMIC_DRAW),this.shadowsVao=e.createVertexArray(),e.bindVertexArray(this.shadowsVao),e.bindBuffer(e.ARRAY_BUFFER,this.shadowsVbo),e.enableVertexAttribArray(0),e.vertexAttribPointer(0,2,e.FLOAT,!1,8,0),e.bindVertexArray(null),this.initialized=!0}renderScene(e,t,i,s,r){e.bind(),this.blend("alpha"),s&&(this.gl.clearColor(s.r,s.g,s.b,s.a),this.gl.clear(this.gl.COLOR_BUFFER_BIT)),this.gl.activeTexture(this.gl.TEXTURE0),t.use(),this.gl.uniform2f(t.getUniform("uViewportDimensions"),i.vw,i.vh),this.gl.uniform2f(t.getUniform("uCameraPos"),i.position.x,i.position.y);for(let o of r)o.render(t);e.unbind()}renderLights(e,t){const i=e.getLights(),s=e.getColliders(),r=b.createShadowsGeometry(i,s);this.gl.bindBuffer(this.gl.ARRAY_BUFFER,this.shadowsVbo),this.gl.bufferSubData(this.gl.ARRAY_BUFFER,0,r.vertices),this.framebuffers[y].bind(),this.gl.clearColor(e.ambientColor.r*e.ambientIntensity,e.ambientColor.g*e.ambientIntensity,e.ambientColor.b*e.ambientIntensity,1),this.gl.clear(this.gl.COLOR_BUFFER_BIT),this.framebuffers[y].unbind();for(let o=0;o<i.length;++o){const n=i[o];this.framebuffers[y+1].bind(),this.blend("none"),this.gl.clearColor(0,0,0,1),this.gl.clear(this.gl.COLOR_BUFFER_BIT),this.lightShaderProgram.use(),this.gl.uniform2f(this.lightShaderProgram.getUniform("uViewportDimensions"),t.vw,t.vh),this.gl.uniform2f(this.lightShaderProgram.getUniform("uCameraPos"),t.position.x,t.position.y),this.gl.uniform2f(this.lightShaderProgram.getUniform("uLightCenter"),n.position.x,n.position.y),this.gl.uniform1f(this.lightShaderProgram.getUniform("uLightRadius"),n.radius),this.gl.uniform3f(this.lightShaderProgram.getUniform("uLightColor"),n.color.r,n.color.g,n.color.b),this.gl.uniform1f(this.lightShaderProgram.getUniform("uLightIntensity"),n.intensity),this.gl.uniform2f(this.lightShaderProgram.getUniform("uLightDir"),n.direction.x,n.direction.y),this.gl.uniform1f(this.lightShaderProgram.getUniform("uLightCutoff"),n.cutoff),this.gl.bindVertexArray(this.lightVao),this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),this.gl.bindVertexArray(null);const a=r.drawCalls[o];this.shadowShaderProgram.use(),this.gl.uniform2f(this.shadowShaderProgram.getUniform("uViewportDimensions"),t.vw,t.vh),this.gl.uniform2fv(this.shadowShaderProgram.getUniform("uCameraPos"),t.position.toArray()),this.gl.uniform2fv(this.shadowShaderProgram.getUniform("uLightPos"),n.position.toArray()),this.gl.bindVertexArray(this.shadowsVao),this.gl.drawArrays(this.gl.TRIANGLES,a.offset,a.count),this.gl.bindVertexArray(null),this.framebuffers[y+1].unbind(),this.renderFullscreenPass({shader:"blurHorizontal",inputs:[y+1],output:4}),this.renderFullscreenPass({shader:"blurVertical",inputs:[4],output:5}),this.renderFullscreenPass({shader:"default_additive",inputs:[5],output:y})}}renderFullscreenPass(e){const t=this.shaderMap.get(e.shader);if(!t)throw new Error("Unknown shader "+e.shader);e.clearColor&&(this.gl.clearColor(this.clearColor.r,this.clearColor.g,this.clearColor.b,this.clearColor.a),this.gl.clear(this.gl.COLOR_BUFFER_BIT));const i=t.shader;let s=this.canvas.width,r=this.canvas.height;if(e.output!==-1){const a=this.framebuffers[A.clamp(e.output,0,T-1)];s=a.width,r=a.height,a.bind()}else this.gl.viewport(0,0,s,r);this.blend(t.blendMode),i.use();const o=[{name:"time",value:this.time},{name:"resolution",value:[s,r]}].concat(e.uniforms??[]),n=t.builder.getUniforms();for(let a of n){const h=o.find(f=>f.name===a.name);if(h){const f=typeof h.value=="number"?[h.value]:h.value,c=i.getUniform("uniforms."+a.name);switch(a.type){case"float":this.gl.uniform1f(c,f[0]);break;case"vec2":this.gl.uniform2fv(c,f);break;case"vec3":this.gl.uniform3fv(c,f);break;case"vec4":this.gl.uniform4fv(c,f);break}}}for(let a=0;a<B;a++){const h=e.inputs[a]??e.inputs[0],f=this.framebuffers[A.clamp(h,0,T-1)].texture;this.gl.activeTexture(this.gl.TEXTURE0+a),this.gl.bindTexture(this.gl.TEXTURE_2D,f);const c=i.getUniform(`uChannel${a}`);this.gl.uniform1i(c,a)}this.gl.drawArrays(this.gl.TRIANGLES,0,3);for(let a=0;a<B;a++)this.gl.activeTexture(this.gl.TEXTURE0+a),this.gl.bindTexture(this.gl.TEXTURE_2D,null);e.output!==-1&&this.framebuffers[A.clamp(e.output,0,T-1)].unbind()}render(e,t){this.time=performance.now()*.001;const i=[],s=[],r=[];for(const o of e.getLayersOrdered()){let n;this.layersMap.has(o)||this.layersMap.set(o,new Oe(this.gl,this,o.isStatic)),n=this.layersMap.get(o),n.needsUpdate&&n.uploadSprites(o.getSpritesOrdered()),i.push(n),o.zIndex<=e.shadowsZIndex?s.push(n):r.push(n)}this.renderLights(e,t),this.renderScene(this.framebuffers[O],this.shaderProgram,t,this.clearColor,s),this.renderFullscreenPass({shader:"light",inputs:[O,y],output:0}),this.renderScene(this.framebuffers[0],this.shaderProgram,t,void 0,r),this.renderScene(this.framebuffers[ae],this.maskShaderProgram,t,j,i);for(let o=0;o<this.pass.length;++o){const n=this.pass[o];this.renderFullscreenPass(n)}for(const[o,n]of this.layersMap)n.lifetime<=0&&(this.layersMap.delete(o),n.destroy())}getTextureInfo(e){const t=this.texturesMap.get(e);if(!t)throw new Error("Texture not found: "+e);return t}getVBO(){return this.vbo}createTexture(e){const t=this.gl,i=t.createTexture();return t.bindTexture(t.TEXTURE_2D,i),t.texImage2D(t.TEXTURE_2D,0,t.RGBA8,t.RGBA,t.UNSIGNED_BYTE,e),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.NEAREST),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,t.NEAREST),i}createTextureArray(e,t){const i=this.gl,s=i.createBuffer();i.bindBuffer(i.PIXEL_UNPACK_BUFFER,s),i.bufferData(i.PIXEL_UNPACK_BUFFER,t,i.STATIC_DRAW),i.pixelStorei(i.UNPACK_ROW_LENGTH,e.imageWidth),i.pixelStorei(i.UNPACK_IMAGE_HEIGHT,e.imageHeight);const r=i.createTexture();i.bindTexture(i.TEXTURE_2D_ARRAY,r),i.texStorage3D(i.TEXTURE_2D_ARRAY,4,i.RGBA8,e.tileWidth,e.tileHeight,e.tileCount);for(let o=0;o<e.tileCount;++o){const n=o%e.columns,a=Math.floor(o/e.columns);i.pixelStorei(i.UNPACK_SKIP_PIXELS,n*e.tileWidth),i.pixelStorei(i.UNPACK_SKIP_ROWS,a*e.tileHeight),i.texSubImage3D(i.TEXTURE_2D_ARRAY,0,0,0,o,e.tileWidth,e.tileHeight,1,i.RGBA,i.UNSIGNED_BYTE,0)}return i.deleteBuffer(s),i.generateMipmap(i.TEXTURE_2D_ARRAY),i.texParameteri(i.TEXTURE_2D_ARRAY,i.TEXTURE_MAG_FILTER,i.NEAREST),i.texParameteri(i.TEXTURE_2D_ARRAY,i.TEXTURE_MIN_FILTER,i.NEAREST),r}}class Oe{constructor(e,t,i){this.gl=e,this.renderer=t,this.isStatic=i,this.needsUpdate=!0,this.drawCalls=[],this.lifetime=_,this.vao=e.createVertexArray(),e.bindVertexArray(this.vao),e.bindBuffer(e.ARRAY_BUFFER,t.getVBO()),e.enableVertexAttribArray(0),e.vertexAttribPointer(0,2,e.FLOAT,!1,16,0),e.enableVertexAttribArray(1),e.vertexAttribPointer(1,2,e.FLOAT,!1,16,8),this.instanceBuffer=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.instanceBuffer);const s=b.spriteStride;e.bufferData(e.ARRAY_BUFFER,(this.isStatic?E:$)*s,this.isStatic?e.STATIC_DRAW:e.DYNAMIC_DRAW);for(let r=2;r<=8;++r)e.enableVertexAttribArray(r),e.vertexAttribDivisor(r,1);e.bindVertexArray(null)}uploadSprites(e){const t=this.gl;t.bindBuffer(t.ARRAY_BUFFER,this.instanceBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,b.createSpritesData(e,!0)),this.isStatic&&(this.needsUpdate=!1),this.drawCalls.length=0;let i=null;for(let s=0;s<e.length;++s){const r=e[s].tileset.name;!i||r!==i.texName?(i={texName:r,offset:s,count:1},this.drawCalls.push(i)):i.count++}}render(e){const t=this.gl;t.bindVertexArray(this.vao);for(const i of this.drawCalls){const s=this.renderer.getTextureInfo(i.texName);t.bindTexture(t.TEXTURE_2D,s.texture),this.gl.uniform2f(e.getUniform("uTilesetDimensions"),s.tileset.imageWidth,s.tileset.imageHeight),t.bindBuffer(t.ARRAY_BUFFER,this.instanceBuffer);const r=b.spriteStride,o=i.offset*r;t.vertexAttribPointer(2,2,t.FLOAT,!1,r,0+o),t.vertexAttribPointer(3,2,t.FLOAT,!1,r,8+o),t.vertexAttribPointer(4,1,t.FLOAT,!1,r,16+o),t.vertexAttribIPointer(5,4,t.UNSIGNED_SHORT,r,20+o),t.vertexAttribPointer(6,4,t.FLOAT,!1,r,28+o),t.vertexAttribPointer(7,4,t.FLOAT,!1,r,44+o),t.vertexAttribPointer(8,2,t.FLOAT,!1,r,60+o),t.drawArraysInstanced(t.TRIANGLE_STRIP,0,4,i.count)}t.bindVertexArray(null),this.lifetime=_}destroy(){this.gl.deleteBuffer(this.instanceBuffer),this.gl.deleteVertexArray(this.vao)}}const Ve=async()=>{const e=await(await navigator.gpu?.requestAdapter())?.requestDevice();if(!e)return null;const t=navigator.gpu.getPreferredCanvasFormat();return{device:e,format:t}},H=`
fn worldToClip(worldPos: vec2f, cameraPos: vec2f, viewport: vec2f) -> vec4f {
    let pixelPos = worldPos - cameraPos;
    let clipPos = vec2f(pixelPos.x / viewport.x, 1.0 - pixelPos.y / viewport.y) * 2.0 - 1.0;
    return vec4f(clipPos, 0.0, 1.0);
}
`,ne=`
struct VSInput {
    @location(0) vertexPos: vec2f,
    @location(1) texCoord: vec2f,
    
    @location(2) tilePos: vec2f,
    @location(3) tileScale: vec2f,
    @location(4) tileAngle: f32,
    @location(5) tileRegion: vec2u,

    @location(6) tintColor: vec4f,
    @location(7) maskColor: vec4f,

    @location(8) tileOffset: vec2f
}

struct Camera {
    pos: vec2f,
    viewportDimensions: vec2f
}

@group(0) @binding(0)
var<uniform> camera: Camera;

@group(1) @binding(2)
var<uniform> tilesetDimensions: vec2f;

struct VSOutput {
    @builtin(position) pos: vec4f,
    @location(0) uv: vec2f,
    @location(1) tintColor: vec4f,
    @location(2) maskColor: vec4f
}

${H}

@vertex
fn vs_main(input: VSInput) -> VSOutput {
    var out: VSOutput;

    out.tintColor = input.tintColor;
    out.maskColor = input.maskColor;

    let x = f32(input.tileRegion.x & 0xFFFFu);
    let y = f32(input.tileRegion.x >> 16);
    let w = f32(input.tileRegion.y & 0xFFFFu);
    let h = f32(input.tileRegion.y >> 16);

    let tileRegion = vec4f(x, y, w, h);

    let flippedTexCoord = vec2f(input.texCoord.x, 1.0 - input.texCoord.y);
    out.uv = (tileRegion.xy + flippedTexCoord * tileRegion.zw) / tilesetDimensions;

    let c = cos(input.tileAngle);
    let s = sin(input.tileAngle);
    let offsetPos = input.vertexPos * input.tileScale + input.tileOffset;
    let rotatedPos = vec2f(
        offsetPos.x * c - offsetPos.y * s,
        offsetPos.x * s + offsetPos.y * c
    );
    let worldPos = rotatedPos + input.tilePos;

    out.pos = worldToClip(worldPos, camera.pos, camera.viewportDimensions);
    return out;
}`,Ge=`

@group(1) @binding(0)
var spriteSampler: sampler;

@group(1) @binding(1)
var spriteTexture: texture_2d<f32>;

@fragment
fn fs_main(input: VSOutput) -> @location(0) vec4f {
    return textureSample(spriteTexture, spriteSampler, input.uv) * input.tintColor;
}
`,Ne=`
@group(1) @binding(0)
var spriteSampler: sampler;

@group(1) @binding(1)
var spriteTexture: texture_2d<f32>;

@fragment
fn fs_main(input: VSOutput) -> @location(0) vec4f {
    let texColor: vec4f = textureSample(spriteTexture, spriteSampler, input.uv);
    return vec4f(input.maskColor.xyz, texColor.w * input.maskColor.a);
}
`,Xe=ne+Ge,ke=ne+Ne,ze=`
struct VSInput {
    @location(0) pos: vec2f
}

struct VSOutput {
    @builtin(position) pos: vec4f,
    @location(0) worldPos: vec2f
}

struct Camera {
    pos: vec2f,
    viewportDimensions: vec2f
}

struct Light {
    center: vec2f,
    radius: f32,
    color: vec3f,
    intensity: f32,
    direction: vec2f,
    cutoff: f32
}

@group(0) @binding(0)
var<uniform> camera: Camera;

@group(1) @binding(0)
var<uniform> light: Light;

${H}

@vertex
fn vs_main(input: VSInput) -> VSOutput {
    var out: VSOutput;

    out.worldPos = light.center + (input.pos - 0.5) * 2.0 * light.radius;

    out.pos = worldToClip(out.worldPos, camera.pos, camera.viewportDimensions);
    return out;
}

@fragment
fn fs_main(input: VSOutput) -> @location(0) vec4f {
    let toPixel = input.worldPos - light.center;
    let dist = length(toPixel);

    let attenuation = clamp(1.0 - pow(dist / light.radius, 2.0), 0.0, 1.0);

    var spotFactor = 1.0;
    if (light.cutoff > 0.0) {
        let cosAngle = dot(normalize(toPixel), normalize(light.direction));
        spotFactor = clamp((cosAngle - light.cutoff) / (1.0 - light.cutoff), 0.0, 1.0);
    }

    return vec4f(light.color * light.intensity * attenuation * spotFactor, 1.0);
}
`,Ye=`
struct VSInput {
    @location(0) pos: vec2f
}

struct VSOutput {
    @builtin(position) pos: vec4f
}

struct Camera {
    pos: vec2f,
    viewportDimensions: vec2f
}

@group(0) @binding(0)
var<uniform> camera: Camera;

${H}

@vertex
fn vs_main(input: VSInput) -> VSOutput {
    var out: VSOutput;

    out.pos = worldToClip(input.pos, camera.pos, camera.viewportDimensions);
    return out;
}

@fragment
fn fs_main(input: VSOutput) -> @location(0) vec4f {
    return vec4f(0.0, 0.0, 0.0, 1.0);
}
`,We=u=>`

struct VSOutput {
    @builtin(position) pos: vec4f,
    @location(0) uv: vec2f
}

@vertex
fn vs_main(@builtin(vertex_index) vertexIndex: u32) -> VSOutput {
    var out: VSOutput;

    let x = f32((vertexIndex & 1) << 2);
    let y = f32((vertexIndex & 2) << 1);

    out.uv = vec2f(x, 2.0 - y) / 2.0;
    out.pos = vec4f(x - 1.0, y - 1.0, 0.0, 1.0);
    return out;
}

struct Uniforms {
${u.uniforms.map(e=>"    "+e).join(`,
`)}
}

@group(0) @binding(0)
var<uniform> uniforms: Uniforms;

@group(1) @binding(0)
var defaultSampler: sampler;

@group(1) @binding(1)
var channel0: texture_2d<f32>;

@group(1) @binding(2)
var channel1: texture_2d<f32>;

@group(1) @binding(3)
var channel2: texture_2d<f32>;

@group(1) @binding(4)
var channel3: texture_2d<f32>;

@group(1) @binding(5)
var channel4: texture_2d<f32>;

@group(1) @binding(6)
var channel5: texture_2d<f32>;

@group(1) @binding(7)
var channel6: texture_2d<f32>;

@group(1) @binding(8)
var channel7: texture_2d<f32>;

fn texture(ch: i32, uv: vec2f) -> vec4f {
    let scaledUV = uv;

    switch (ch) {
        case 1:  { return textureSample(channel1, defaultSampler, scaledUV); }
        case 2:  { return textureSample(channel2, defaultSampler, scaledUV); }
        case 3:  { return textureSample(channel3, defaultSampler, scaledUV); }
        case 4:  { return textureSample(channel4, defaultSampler, scaledUV); }
        case 5:  { return textureSample(channel5, defaultSampler, scaledUV); }
        case 6:  { return textureSample(channel6, defaultSampler, scaledUV); }
        case 7:  { return textureSample(channel7, defaultSampler, scaledUV); }
        default: { return textureSample(channel0, defaultSampler, scaledUV); }
    }
}

fn mainImage(fragCoord: vec2f) -> vec4f {
    var fragColor: vec4f;
${u.mainImage.map(e=>"    "+e).join(`
`)}
    return fragColor;
}

@fragment
fn fs_main(input: VSOutput) -> @location(0) vec4f {
    let fragCoord = input.uv * uniforms.resolution;
    return mainImage(fragCoord);
}
`,He={componentMap:{r:"x",g:"y",b:"z",a:"w"},declareVar:(u,e,t=!1)=>{const i=`${u}: ${e==="float"?"f32":e+"f"}`;return t?i:`var ${i};`}};class $e{constructor(e){this.shaderMap=new Map,this.layersMap=new Map,this.texturesMap=new Map,this.canvas=e,this.clearColor=new C(0,0,0,0),this.shaderMap=new Map,this.initialized=!1,this.pass=[q],this.offscreenTextures=[],this.time=0,this.shaderCache=new Map,this.renderPassUniformMap=new Map,this.fullscreenPassStages={mainLight:{shader:"light",inputs:[O,y],output:0},lightBlurHorizontal:{shader:"blurHorizontal",inputs:[y+1],output:4},lightBlurVertical:{shader:"blurVertical",inputs:[4],output:5},lightAdditive:{shader:"default_additive",inputs:[5],output:y}}}getType(){return"webgpu"}getBuilderOptions(){return He}addTextures(e,t){for(const i of e)t[i.name]&&this.texturesMap.set(i.name,{tileset:i,image:t[i.name]})}registerShader(e,t,i="none"){this.shaderMap.set(e,{builder:t,blendMode:i})}setClearColor(e){this.clearColor.copy(e)}setSize(e,t){this.canvas.width=e,this.canvas.height=t,this.initialized&&this.initOffscreenTextures(T)}getCanvas(){return this.canvas}initOffscreenTextures(e){for(let t=0;t<e;++t){this.offscreenTextures[t]?.destroy();const i=K(t);this.offscreenTextures[t]=this.cfg.device.createTexture({size:{width:this.canvas.width*i,height:this.canvas.height*i,depthOrArrayLayers:1},format:this.cfg.format,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING,label:"offscreen texture "+t})}}getBlendOptions(e){switch(e){case"alpha":return{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha",operation:"add"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"}};case"additive":return{color:{srcFactor:"one",dstFactor:"one",operation:"add"},alpha:{srcFactor:"zero",dstFactor:"one",operation:"add"}};default:return}}async init(){const e=await Ve();if(!e)throw new Error("WebGPU not supported");this.cfg=e;const t=this.cfg.device,i=this.canvas.getContext("webgpu");this.ctx=i,this.ctx.configure(this.cfg);for(const a of this.texturesMap.values())a.tileset&&(a.texture=this.createTexture(a.tileset,a.image));this.initOffscreenTextures(T),this.sampler=t.createSampler({magFilter:"nearest",minFilter:"nearest",addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge"}),this.fullscreenSampler=t.createSampler({magFilter:"linear",minFilter:"linear",addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge"}),this.registerShader("default",F),this.registerShader("default_additive",F,"additive"),this.registerShader("light",k),this.registerShader("blurHorizontal",z),this.registerShader("blurVertical",Y);for(const[a,h]of this.shaderMap.entries()){if(!this.shaderCache.has(h.builder)){const m=We(h.builder.build(this)),g=t.createShaderModule({label:a+" shader module",code:m});this.shaderCache.set(h.builder,g)}const f=this.shaderCache.get(h.builder),c=t.createRenderPipeline({layout:"auto",vertex:{module:f,entryPoint:"vs_main"},fragment:{module:f,entryPoint:"fs_main",targets:[{format:this.cfg.format,blend:this.getBlendOptions(h.blendMode)}]},primitive:{topology:"triangle-strip"}});h.pipeline=c}this.commonBGL=this.cfg.device.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.FRAGMENT,sampler:{}},{binding:1,visibility:GPUShaderStage.FRAGMENT,texture:{}},{binding:2,visibility:GPUShaderStage.VERTEX,buffer:{type:"uniform"}}]}),this.cameraBGL=this.cfg.device.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.VERTEX,buffer:{type:"uniform"}}]}),this.lightBGL=this.cfg.device.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,buffer:{type:"uniform"}}]}),this.pipeline=this.createMainPipeline(Xe),this.maskPipeline=this.createMainPipeline(ke),this.lightUniformBuffer=this.cfg.device.createBuffer({label:"Light uniform buffer",size:Je*b.lightStride,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});const s=this.cfg.device.createPipelineLayout({bindGroupLayouts:[this.cameraBGL,this.lightBGL]}),r=this.cfg.device.createShaderModule({code:ze});this.lightPipeline=this.cfg.device.createRenderPipeline({label:"Light pipeline",layout:s,vertex:{module:r,entryPoint:"vs_main",buffers:[{arrayStride:16,attributes:[{shaderLocation:0,offset:0,format:"float32x2"}]}]},fragment:{module:r,entryPoint:"fs_main",targets:[{format:this.cfg.format}]},primitive:{topology:"triangle-strip"}});const o=this.cfg.device.createPipelineLayout({bindGroupLayouts:[this.cameraBGL]}),n=this.cfg.device.createShaderModule({code:Ye});this.shadowPipeline=this.cfg.device.createRenderPipeline({label:"Shadow pipeline",layout:o,vertex:{module:n,entryPoint:"vs_main",buffers:[{arrayStride:8,attributes:[{shaderLocation:0,offset:0,format:"float32x2"}]}]},fragment:{module:n,entryPoint:"fs_main",targets:[{format:this.cfg.format}]}}),this.cameraBuffer=t.createBuffer({size:16,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),this.cameraBindGroup=t.createBindGroup({label:"Camera bind group",layout:this.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:this.cameraBuffer}}]}),this.vbo=t.createBuffer({size:b.quad.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST}),t.queue.writeBuffer(this.vbo,0,b.quad),this.shadowsVbo=this.cfg.device.createBuffer({size:12e4,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST}),this.initialized=!0}createMainPipeline(e){const t=this.cfg.device.createShaderModule({code:e}),i=this.cfg.device.createPipelineLayout({bindGroupLayouts:[this.cameraBGL,this.commonBGL]});return this.cfg.device.createRenderPipeline({layout:i,vertex:{module:t,entryPoint:"vs_main",buffers:[{arrayStride:16,stepMode:"vertex",attributes:[{shaderLocation:0,offset:0,format:"float32x2"},{shaderLocation:1,offset:8,format:"float32x2"}]},{arrayStride:b.spriteStride,stepMode:"instance",attributes:[{shaderLocation:2,offset:0,format:"float32x2"},{shaderLocation:3,offset:8,format:"float32x2"},{shaderLocation:4,offset:16,format:"float32"},{shaderLocation:5,offset:20,format:"uint32x2"},{shaderLocation:6,offset:28,format:"float32x4"},{shaderLocation:7,offset:44,format:"float32x4"},{shaderLocation:8,offset:60,format:"float32x2"}]}]},fragment:{module:t,entryPoint:"fs_main",targets:[{format:this.cfg.format,blend:this.getBlendOptions("alpha")}]},primitive:{topology:"triangle-strip"}})}renderScene(e,t,i,s,r){const o=e.beginRenderPass({colorAttachments:[{clearValue:s,view:i.createView(),loadOp:s?"clear":"load",storeOp:"store"}]});o.setPipeline(t),o.setBindGroup(0,this.cameraBindGroup),o.setVertexBuffer(0,this.vbo);for(const n of r)n.render(o);o.end()}renderLights(e,t,i){const s=t.getLights(),r=t.getColliders(),o=new C(t.ambientColor.r*t.ambientIntensity,t.ambientColor.g*t.ambientIntensity,t.ambientColor.b*t.ambientIntensity,1);e.beginRenderPass({colorAttachments:[{view:this.offscreenTextures[y].createView(),clearValue:o,loadOp:"clear",storeOp:"store"}]}).end();const a=b.createLightsGeometry(s,!0);this.cfg.device.queue.writeBuffer(this.lightUniformBuffer,0,a);const h=b.createShadowsGeometry(s,r);this.cfg.device.queue.writeBuffer(this.shadowsVbo,0,h.vertices);for(let f=0;f<s.length;++f){const c=e.beginRenderPass({colorAttachments:[{view:this.offscreenTextures[y+1].createView(),clearValue:new C(0,0,0,1),loadOp:"clear",storeOp:"store"}]}),m=this.cfg.device.createBindGroup({label:"Light uniform bind group "+f,layout:this.lightPipeline.getBindGroupLayout(1),entries:[{binding:0,resource:{buffer:this.lightUniformBuffer,offset:256*f,size:b.lightStride}}]});c.setPipeline(this.lightPipeline),c.setVertexBuffer(0,this.vbo),c.setBindGroup(0,this.cameraBindGroup),c.setBindGroup(1,m),c.draw(4),c.end();const g=h.drawCalls[f],l=e.beginRenderPass({colorAttachments:[{view:this.offscreenTextures[y+1].createView(),loadOp:"load",storeOp:"store"}]});l.setPipeline(this.shadowPipeline),l.setVertexBuffer(0,this.shadowsVbo),l.setBindGroup(0,this.cameraBindGroup),l.draw(g.count,1,g.offset),l.end(),this.renderFullscreenPass(e,this.fullscreenPassStages.lightBlurHorizontal),this.renderFullscreenPass(e,this.fullscreenPassStages.lightBlurVertical),this.renderFullscreenPass(e,this.fullscreenPassStages.lightAdditive)}}renderFullscreenPass(e,t){const i=this.shaderMap.get(t.shader);if(!i)throw new Error("Unknown shader "+t.shader);const s=[{binding:0,resource:this.fullscreenSampler}];for(let m=0;m<B;m++){const g=t.inputs[m]??t.inputs[0],l=this.offscreenTextures[A.clamp(g,0,T-1)];s.push({binding:m+1,resource:l.createView()})}const r=t.output===-1?this.ctx.getCurrentTexture():this.offscreenTextures[A.clamp(t.output,0,T-1)],o=i.builder.getUniforms(),n=[{name:"time",value:this.time},{name:"resolution",value:[r.width,r.height]}].concat(t.uniforms??[]),a=new Float32Array(je);for(let m of o){const g=n.find(l=>l.name===m.name);if(g){const l=typeof g.value=="number"?[g.value]:g.value;a.set(l,m.offset)}}if(!this.renderPassUniformMap.has(t)){const m=this.cfg.device.createBuffer({size:256,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),g=this.cfg.device.createBindGroup({layout:i.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:m}}]});this.renderPassUniformMap.set(t,{ubo:m,bindGroup:g})}const h=this.renderPassUniformMap.get(t);this.cfg.device.queue.writeBuffer(h.ubo,0,a);const f=this.cfg.device.createBindGroup({label:t.shader+" texture bind group",layout:i.pipeline.getBindGroupLayout(1),entries:s}),c=e.beginRenderPass({colorAttachments:[{view:r.createView(),loadOp:t.clearColor?"clear":"load",clearValue:t.clearColor,storeOp:"store"}]});c.setPipeline(i.pipeline),c.setBindGroup(0,h.bindGroup),c.setBindGroup(1,f),c.draw(3),c.end()}render(e,t){this.time=performance.now()*.001;const i=[],s=[],r=[];for(const a of e.getLayersOrdered()){if(!this.layersMap.has(a)){const f=new qe(this,a.isStatic);this.layersMap.set(a,f)}const h=this.layersMap.get(a);h.needsUpdate&&h.upload(a.getSpritesOrdered()),i.push(h),a.zIndex<=e.shadowsZIndex?s.push(h):r.push(h)}this.cfg.device.queue.writeBuffer(this.cameraBuffer,0,new Float32Array([t.position.x,t.position.y,t.vw,t.vh]));const o=this.cfg.device.createCommandEncoder();this.renderLights(o,e,t),this.renderScene(o,this.pipeline,this.offscreenTextures[O],this.clearColor,s),this.renderFullscreenPass(o,this.fullscreenPassStages.mainLight),this.renderScene(o,this.pipeline,this.offscreenTextures[0],void 0,r),this.renderScene(o,this.maskPipeline,this.offscreenTextures[ae],j,i);for(let a=0;a<this.pass.length;++a){const h=this.pass[a];this.renderFullscreenPass(o,h)}const n=o.finish();this.cfg.device.queue.submit([n]);for(const[a,h]of this.layersMap)h.lifetime<=0&&(h.destroy(),this.layersMap.delete(a))}createTexture(e,t){const i=this.cfg.device.createTexture({size:{width:e.imageWidth,height:e.imageHeight,depthOrArrayLayers:1},format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT});return this.cfg.device.queue.copyExternalImageToTexture,this.cfg.device.queue.copyExternalImageToTexture({source:t},{texture:i},[e.imageWidth,e.imageHeight,1]),i}createTextureArray(e,t){const i=e.tileWidth,s=e.tileHeight,r=this.cfg.device.createTexture({size:{width:i,height:s,depthOrArrayLayers:e.tileCount},format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT});for(let o=0;o<e.tileCount;++o){const n=Math.floor(o/e.columns),a=o%e.columns,h=new Uint8Array(i*s*4);for(let f=0;f<s;++f){const c=((n*s+f)*e.columns+a)*i*4,m=c+i*4;h.set(t.slice(c,m),f*i*4)}this.cfg.device.queue.writeTexture({texture:r,origin:{x:0,y:0,z:o}},h,{bytesPerRow:i*4,rowsPerImage:s},{width:i,height:s,depthOrArrayLayers:1})}return r}getConfig(){return this.cfg}getTextureInfo(e){const t=this.texturesMap.get(e);if(!t)throw new Error("Texture not found: "+e);return t}getPipeline(){return this.pipeline}getSampler(){return this.sampler}}class qe{constructor(e,t){this.renderer=e,this.isStatic=t,this.needsUpdate=!0,this.drawCalls=[],this.bindGroups=new Map,this.lifetime=_,this.lastTexIdx=0,this.instanceBuffer=e.getConfig().device.createBuffer({label:"Instance Buffer",size:b.spriteStride*(t?E:$),usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST}),this.tilesetDimBuffer=e.getConfig().device.createBuffer({label:"Tileset Dimensions Buffer",size:Ke*256,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST})}upload(e){const t=this.renderer.getConfig().device,i=this.renderer.getPipeline(),s=this.renderer.getSampler();t.queue.writeBuffer(this.instanceBuffer,0,b.createSpritesData(e,!0)),this.isStatic&&(this.needsUpdate=!1),this.drawCalls.length=0;let r=null;for(let o=0;o<e.length;++o){const n=e[o].tileset.name;if(!r||n!==r.texName){const a=this.renderer.getTextureInfo(n);t.queue.writeBuffer(this.tilesetDimBuffer,this.lastTexIdx*256,new Float32Array([a.tileset.imageWidth,a.tileset.imageHeight]));const h=t.createBindGroup({layout:i.getBindGroupLayout(1),entries:[{binding:0,resource:s},{binding:1,resource:a.texture.createView()},{binding:2,resource:{buffer:this.tilesetDimBuffer,offset:this.lastTexIdx*256,size:8}}]});r={texName:n,instanceOffset:o,instanceCount:1},this.bindGroups.has(r.texName)||(this.bindGroups.set(r.texName,h),++this.lastTexIdx),this.drawCalls.push(r)}else r.instanceCount++}}render(e){e.setVertexBuffer(1,this.instanceBuffer);for(const t of this.drawCalls)e.setBindGroup(1,this.bindGroups.get(t.texName)),e.draw(4,t.instanceCount,0,t.instanceOffset);this.lifetime=_}destroy(){this.instanceBuffer.destroy(),this.tilesetDimBuffer.destroy()}}const E=1e4,$=1e4,_=30,Ke=16,T=12,B=8,je=32,Je=100,O=3,ae=1,y=1,q={shader:"default",inputs:[0],output:-1},K=u=>1/(1<<Math.max(0,Math.floor((u-2)*.5))),j=new C(0,0,0,1),Ze=u=>{const e=document.createElement("canvas");switch(u){case"webgl":return new Re(e);case"webgl2":return new De(e);case"webgpu":return new $e(e);default:throw new Error("Unknown renderer type")}};class le{constructor(e){this.zIndex=e.zIndex||0,this.tileset=e.tileset,this.tilesetRegion=e.tilesetRegion,this.isStatic=e.isStatic||!1,this.position=new x,this.offset=new x,this.scale=new x(1,1),this.angle=e.angle||0,this.tintColor=new C(1,1,1,1),this.maskColor=new C(0,0,0,1),this.blendMode=e.blendMode||"alpha"}setTilesetRegion(e,t,i=1,s=1){this.tilesetRegion.x=e,this.tilesetRegion.y=t,this.tilesetRegion.width=i,this.tilesetRegion.height=s}getTile(){return this.tileset.getTile(this.tilesetRegion.x,this.tilesetRegion.y)}}class Qe{constructor(){this.layers=[],this.ambientIntensity=1,this.ambientColor=new C(1,1,1),this.lights=[],this.colliders=[],this.shadowsZIndex=0}findLayerBySprite(e){return this.layers.find(t=>t.isStatic===e.isStatic&&t.zIndex===e.zIndex)}addLight(e){this.lights.push(e)}removeLight(e){const t=this.lights.indexOf(e);t!==-1&&this.lights.splice(t,1)}addSprite(e){let t;return t=this.findLayerBySprite(e),t||(t=this.createLayer({zIndex:e.zIndex,isStatic:e.isStatic,blendMode:e.blendMode})),t.add(e),e}removeSprite(e){const t=this.findLayerBySprite(e);t&&t.remove(e)}addTilemap(e,t={}){const i=e.getLayers();let s=0;const r=[],o=[];for(const n of i){const a=t.layers?.find(h=>h.name===n.name);switch(a?.zIndex&&(s=a.zIndex),n.renderOrder!=="manual"&&this.createLayer({zIndex:s,renderOrder:n.renderOrder,isStatic:!1}),n.type){case"tilelayer":{for(let h=0;h<n.height;++h)for(let f=0;f<n.width;++f){const c=n.getTile(f,h);if(!c)continue;const m=new le({isStatic:c.animation===void 0,zIndex:s,tileset:c.tileset,tilesetRegion:{x:c.x,y:c.y}});if(m.position.set((f+n.x)*e.tileWidth,(h+n.y)*e.tileHeight),m.scale.set(e.tileWidth,e.tileHeight),r.push(this.addSprite(m)),c.animation){const g=new ee(m);g.play({x:c.x,y:c.y},{repeat:!0}),o.push(g)}}break}case"objectgroup":{if(t.onObject){const h=n.getObjects();for(const f of h)t.onObject(this,f,n,s)}break}}++s}return{sprites:r,animators:o}}createLayer(e){const t=new et(e);return this.layers.push(t),t}getLayersOrdered(){return this.layers.sort((e,t)=>e.zIndex-t.zIndex)}getLights(){return this.lights}addCollider(e){return this.colliders.push(e),e}removeCollider(e){const t=this.colliders.indexOf(e);t!==-1&&this.colliders.splice(t,1)}getColliders(){return this.colliders}}class et{constructor(e){this.zIndex=e.zIndex,this.isStatic=e.isStatic,this.renderOrder=e.renderOrder||"manual",this.sprites=[],this.blendMode=e.blendMode||"alpha"}add(e){if(e.blendMode=this.blendMode,this.renderOrder==="manual"){let t=-1;for(let i=this.sprites.length-1;i>=0;--i)if(this.sprites[i].tileset.name<=e.tileset.name){t=i;break}t===-1?this.sprites.unshift(e):this.sprites.splice(t+1,0,e)}else this.sprites.push(e)}remove(e){const t=this.sprites.indexOf(e);t!==-1&&this.sprites.splice(t,1)}getSpritesOrdered(){switch(this.renderOrder){case"topdown":return this.sprites.sort((e,t)=>e.position.y-t.position.y);default:return this.sprites}}}class he{constructor(e,t,i,s,r){this.tileset=e,this.id=t,this.x=i,this.y=s,this.properties=r?.properties,this.animation=r?.animation}getProperty(e){return this.properties?.find(t=>t.name===e)?.value}}const V=class V{constructor(e){if(this.name=e.name,this.imageWidth=e.imagewidth,this.imageHeight=e.imageheight,this.tileWidth=e.tilewidth,this.tileHeight=e.tileheight,this.columns=e.columns,this.tileCount=e.tilecount,this.margin=e.margin||0,this.spacing=e.spacing||0,this.tiledata=new Map,e.tiles)for(let t of e.tiles)this.tiledata.set(t.id,t)}static async load(e){if(!this.cache.has(e)){const t=await X.loadJson(e);this.cache.set(e,new V(t))}return this.cache.get(e)}static getByName(e){return this.cache.values().find(t=>t.name===e)||null}getTile(e,t){if(e<0||e>=this.columns||t<0||t>=Math.ceil(this.tileCount/this.columns))return null;const i=t*this.columns+e,s=this.tiledata.get(i);return new he(this,i,e,t,s)}getTileById(e){if(e>=this.tileCount||e<0)return null;const t=e%this.columns,i=Math.floor(e/this.columns),s=this.tiledata.get(e);return new he(this,e,t,i,s)}getTileXY(e){const t=e%this.columns,i=Math.floor(e/this.columns);return{x:t,y:i}}};V.cache=new Map;let M=V;class ue{constructor(e){this.name=e.name,this.x=e.x,this.y=e.y,this.width=e.width,this.height=e.height,this.type=e.type,this.renderOrder=e.draworder||"manual"}}class tt extends ue{constructor(e){super(e),this.data=e.data}getTile(e,t){const i=this.data[t*this.width+e];return i-1==-1?null:this.tilemap.getTileById(i)}}class it{constructor(e,t,i,s,r,o){this.name=e,this.type=t,this.x=i,this.y=s,this.rotation=r||0,this.properties=o}getProperty(e){return this.properties?.find(t=>t.name===e)?.value}}class rt extends ue{constructor(e){super(e),this.objects=e.objects}getObjects(){return this.objects.map(e=>new it(e.name,e.type,e.x,e.y,e.rotation,e.properties))}}class J{constructor(e,t,i,s){this.width=e,this.height=t,this.tileWidth=i,this.tileHeight=s,this.tilesets=[],this.layers=[]}static async load(e,t){const i=await X.loadJson(e),s=new J(i.width,i.height,i.tilewidth,i.tileheight);for(const r of i.layers)switch(r.type){case"tilelayer":s.addLayer(new tt(r));break;case"objectgroup":s.addLayer(new rt(r));break}for(let r of i.tilesets){let o;if(r.source){const n=r.source.split(/(\/|\\\/)/),a=n[n.length-1].split(".tsj")[0];if(!t[a])throw new Error("Source is missing for tileset: "+a);o=await M.load(t[a])}else o=new M(r);s.tilesets.push({tileset:o,firstGlobalId:r.firstgid})}return s}addLayer(e){e.tilemap=this,this.layers.push(e)}getTilesets(){return this.tilesets.map(e=>e.tileset)}getTilesetByName(e){return this.tilesets.find(t=>t.tileset.name===e)?.tileset||null}getLayers(){return this.layers}getLayerByName(e){return this.layers.find(t=>t.name===e)||null}getTileById(e){const t=this.tilesets;for(let i of t){let s=i.tileset.getTileById(e-i.firstGlobalId);if(s)return s}return null}}return v.AABB=N,v.Animator=ee,v.Camera=ge,v.Color=C,v.Light=ve,v.LinearSpline=fe,v.LinearSplineVector=de,v.Scene=Qe,v.ShaderBuilder=I,v.Sprite=le,v.Tilemap=J,v.Tileset=M,v.Vector=x,v.assets=X,v.colliders=xe,v.createRenderer=Ze,v.math=A,v.matrix=U,Object.defineProperty(v,Symbol.toStringTag,{value:"Module"}),v})({});
