class ge {
  constructor(e) {
    this.repeat = !0, this.currentFrameIndex = 0, this.frameTimer = 0, this.sprite = e, this.animation = null;
  }
  play(e, t = {}) {
    const i = this.sprite.tileset.getTile(e.x, e.y);
    if (!i) return;
    const s = i.animation || [{ tileid: i.id, duration: 100 }];
    if (!t.restart && this.animation === s)
      return;
    this.animation = s, this.repeat = t.repeat ?? !0, this.currentFrameIndex = 0, this.frameTimer = 0;
    const r = this.animation[0], o = this.sprite.tileset.getTileXY(r.tileid);
    this.sprite.setTilesetRegion(o.x, o.y);
  }
  update(e) {
    if (!this.animation) return;
    const t = this.animation[this.currentFrameIndex];
    if (this.frameTimer += e * 1e3, this.frameTimer < t.duration) return;
    if (this.frameTimer -= t.duration, this.currentFrameIndex++, this.currentFrameIndex >= this.animation.length)
      if (this.repeat)
        this.currentFrameIndex = 0;
      else {
        this.currentFrameIndex = this.animation.length - 1, this.onEnded?.(this.animation), this.animation = null;
        return;
      }
    const i = this.animation[this.currentFrameIndex], s = this.sprite.tileset.getTileXY(i.tileid);
    this.sprite.setTilesetRegion(s.x, s.y);
  }
}
const ne = {
  loadImage: (t) => new Promise((i, s) => {
    const r = new Image();
    r.crossOrigin = "anonymous", r.src = t, r.onload = () => {
      i(r);
    }, r.onerror = () => {
      s();
    };
  }),
  loadJson: async (t) => {
    try {
      return await (await fetch(t)).json();
    } catch {
      throw new Error(`Failed to load: ${t}`);
    }
  }
}, w = /* @__PURE__ */ (() => {
  const c = (o, a, n) => Math.min(Math.max(o, a), n);
  return {
    clamp: c,
    lerp: (o, a, n) => o + (a - o) * n,
    unlerp: (o, a, n) => c((n - o) / (a - o), 0, 1),
    sat: (o) => c(o, 0, 1),
    degToRad: (o) => o / 180 * Math.PI,
    radToDeg: (o) => o / Math.PI * 180
  };
})();
class at {
  constructor(e = []) {
    this.points = e;
  }
  addPoint(e) {
    this.points.push(e);
  }
  getValue(e) {
    const t = this.points.length;
    if (t === 0) return 0;
    if (e <= 0) return this.points[0];
    if (e >= t - 1) return this.points[t - 1];
    const i = Math.floor(e), s = e - i;
    return w.lerp(this.points[i], this.points[i + 1], s);
  }
}
class x {
  constructor(e = 0, t = 0) {
    this.x = e, this.y = t;
  }
  set(e, t) {
    return this.x = e, this.y = t, this;
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this;
  }
  clone() {
    return new x(this.x, this.y);
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }
  scale(e) {
    return this.x *= e, this.y *= e, this;
  }
  mul(e) {
    return this.x *= e.x, this.y *= e.y, this;
  }
  div(e) {
    return e !== 0 ? (this.x /= e, this.y /= e) : (this.x = 0, this.y = 0), this;
  }
  static dot(e, t) {
    return e.x * t.x + e.y * t.y;
  }
  static cross(e, t) {
    return e.x * t.y - e.y * t.x;
  }
  len() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  lenSq() {
    return this.x * this.x + this.y * this.y;
  }
  normalize() {
    const e = this.len();
    return e > 0 && this.div(e), this;
  }
  project(e) {
    const t = e.lenSq();
    if (t === 0) return this.scale(0);
    const i = x.dot(this, e);
    return this.copy(e).scale(i / t);
  }
  static distance(e, t) {
    const i = e.x - t.x, s = e.y - t.y;
    return Math.sqrt(i * i + s * s);
  }
  angle() {
    return Math.atan2(this.y, this.x);
  }
  rot(e) {
    const t = Math.cos(e), i = Math.sin(e), s = this.x * t - this.y * i, r = this.x * i + this.y * t;
    return this.x = s, this.y = r, this;
  }
  static fromAngle(e, t = 1) {
    return new x(
      -Math.sin(e) * t,
      Math.cos(e) * t
    );
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this;
  }
  toString() {
    return `Vector(${this.x}, ${this.y})`;
  }
  toArray() {
    return new Float32Array([this.x, this.y]);
  }
}
class lt {
  constructor(e = []) {
    this.points = e.slice().sort((t, i) => t.x - i.x);
  }
  addPoint(e) {
    this.points.push(e), this.points.sort((t, i) => t.x - i.x);
  }
  getValue(e) {
    const t = this.points.length;
    if (t === 0) return new x();
    if (e <= this.points[0].x) return this.points[0].clone();
    if (e >= this.points[t - 1].x) return this.points[t - 1].clone();
    for (let i = 0; i < t - 1; i++) {
      const s = this.points[i], r = this.points[i + 1];
      if (e >= s.x && e <= r.x) {
        const o = w.unlerp(s.x, r.x, e);
        return s.clone().lerp(r, o);
      }
    }
    return new x();
  }
}
class ht {
  constructor(e, t) {
    this.position = new x(), this.vw = 0, this.vh = 0, this.updateProjection(e, t);
  }
  updateProjection(e, t) {
    this.vw = e, this.vh = t;
  }
  getBounds() {
    return {
      min: this.position.clone(),
      max: this.position.clone().add(new x(this.vw, this.vh))
    };
  }
}
class ae {
  constructor() {
    this.position = new x();
  }
}
class me extends ae {
  constructor(e) {
    super(), this.radius = e;
  }
  getType() {
    return "circle";
  }
  getBounds() {
    const e = new x(this.radius, this.radius);
    return {
      min: this.position.clone().sub(e),
      max: this.position.clone().add(e)
    };
  }
}
class le extends ae {
  constructor(e) {
    super(), this.points = e;
  }
  getType() {
    return "polygon";
  }
  getBounds() {
    let e = 1 / 0, t = 1 / 0, i = -1 / 0, s = -1 / 0;
    for (const r of this.points) {
      const o = r.x + this.position.x, a = r.y + this.position.y;
      o < e && (e = o), a < t && (t = a), o > i && (i = o), a > s && (s = a);
    }
    return {
      min: new x(e, t),
      max: new x(i, s)
    };
  }
}
class pe extends le {
  constructor(e, t) {
    const i = e * 0.5, s = t * 0.5, r = [
      new x(-i, -s),
      new x(i, -s),
      new x(i, s),
      new x(-i, s)
    ];
    super(r), this.width = e, this.height = t;
  }
}
const ut = {
  CircleCollider: me,
  PolygonCollider: le,
  BoxCollider: pe
};
class C {
  constructor(e, t, i, s = 1) {
    this.r = e, this.g = t, this.b = i, this.a = s;
  }
  set(e, t, i, s) {
    this.r = e, this.g = t, this.b = i, this.a = s;
  }
  copy(e) {
    this.r = e.r, this.g = e.g, this.b = e.b, this.a = e.a;
  }
  toArray() {
    return new Float32Array([this.r, this.g, this.b, this.a]);
  }
}
class ct {
  constructor(e) {
    this.position = e.position || new x(), this.color = e.color || new C(1, 1, 1), this.intensity = e.intensity || 1, this.radius = e.radius, this.direction = e.direction || new x(0, 1), this.cutoff = e.cutoff || 0, this.isStatic = e.isStatic || !1;
  }
  getBounds() {
    const e = new x(this.radius, this.radius);
    return {
      min: this.position.clone().sub(e),
      max: this.position.clone().add(e)
    };
  }
}
const ft = {
  create: () => new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
  identity: (r) => (r[0] = 1, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = 1, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[10] = 1, r[11] = 0, r[12] = 0, r[13] = 0, r[14] = 0, r[15] = 1, r),
  createOrtho: (r, o, a, n, l) => (r[0] = 2 / (a - o), r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = 2 / (l - n), r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[10] = 1, r[11] = 0, r[12] = -(a + o) / (a - o), r[13] = -(l + n) / (l - n), r[14] = 0, r[15] = 1, r),
  translate: (r, o) => (r[12] += o.x, r[13] += o.y, r),
  scale: (r, o) => (r[0] *= o.x, r[1] *= o.x, r[4] *= o.y, r[5] *= o.y, r)
}, B = (c, e) => (e.min.x - c.max.x) * (e.max.x - c.min.x) < 0 && (e.min.y - c.max.y) * (e.max.y - c.min.y) < 0, b = (() => {
  const c = new Float32Array([
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    0,
    1,
    0,
    1,
    1
  ]), e = new Float32Array([
    -1,
    1,
    0,
    0,
    -1,
    -1,
    0,
    1,
    1,
    1,
    1,
    0,
    1,
    -1,
    1,
    1
  ]), t = 68, i = (l, h = !1) => {
    const u = h ? 1 : 4, d = t, m = new ArrayBuffer(l.length * u * d), f = new DataView(m);
    let p = 0;
    for (const g of l) {
      const D = g.position.x, A = g.position.y, P = g.scale.x, X = g.scale.y, z = g.angle, k = g.tilesetRegion.x * (g.tileset.tileWidth + g.tileset.spacing) + g.tileset.margin, S = g.tilesetRegion.y * (g.tileset.tileHeight + g.tileset.spacing) + g.tileset.margin, V = g.tileset.tileWidth + ((g.tilesetRegion.width || 1) - 1) * (g.tileset.tileWidth + g.tileset.spacing), de = g.tileset.tileHeight + ((g.tilesetRegion.height || 1) - 1) * (g.tileset.tileHeight + g.tileset.spacing);
      for (let ie = 0; ie < u; ++ie)
        f.setFloat32(p, D, !0), f.setFloat32(p + 4, A, !0), f.setFloat32(p + 8, P, !0), f.setFloat32(p + 12, X, !0), f.setFloat32(p + 16, z, !0), f.setUint16(p + 20, k, !0), f.setUint16(p + 22, S, !0), f.setUint16(p + 24, V, !0), f.setUint16(p + 26, de, !0), f.setFloat32(p + 28, g.tintColor.r, !0), f.setFloat32(p + 32, g.tintColor.g, !0), f.setFloat32(p + 36, g.tintColor.b, !0), f.setFloat32(p + 40, g.tintColor.a, !0), f.setFloat32(p + 44, g.maskColor.r, !0), f.setFloat32(p + 48, g.maskColor.g, !0), f.setFloat32(p + 52, g.maskColor.b, !0), f.setFloat32(p + 56, g.maskColor.a, !0), f.setFloat32(p + 60, g.offset.x, !0), f.setFloat32(p + 64, g.offset.y, !0), p += d;
    }
    return m;
  }, s = 48, r = (l, h = !1) => {
    const u = h ? 1 : 4, d = new Float32Array(l.length * 64);
    let m = 0;
    for (let f of l)
      for (let p = 0; p < u; ++p)
        d.set(f.position.toArray(), m), d[m + 2] = f.radius, d.set(f.color.toArray(), m + 4), d[m + 7] = f.intensity, d.set(f.direction.toArray(), m + 8), d[m + 10] = f.cutoff, m += 64;
    return d;
  }, o = (l, h) => {
    const u = h.position.clone().sub(l.position).normalize(), d = new x(-u.y, u.x).scale(h.radius), m = h.position.clone().sub(d), f = h.position.clone().add(d), p = m.clone().sub(l.position).normalize(), g = f.clone().sub(l.position).normalize(), D = l.radius, A = m.clone().add(p.scale(D)), P = f.clone().add(g.scale(D));
    return [
      // Triangle 1
      m.x,
      m.y,
      f.x,
      f.y,
      A.x,
      A.y,
      // Triangle 2
      A.x,
      A.y,
      f.x,
      f.y,
      P.x,
      P.y
    ];
  }, a = (l, h) => {
    const u = [], d = l.radius, m = h.points.map((f) => f.clone().add(h.position));
    for (let f = 0; f < m.length; f++) {
      const p = m[f], g = m[(f + 1) % m.length], A = p.clone().add(g).scale(0.5).clone().sub(l.position).normalize(), P = g.clone().sub(p).normalize(), X = new x(-P.y, P.x);
      if (x.dot(X, A) <= 0) continue;
      const z = p.clone().sub(l.position).normalize(), k = g.clone().sub(l.position).normalize(), S = p.clone().add(z.scale(d * 100)), V = g.clone().add(k.scale(d * 100));
      u.push(
        p.x,
        p.y,
        g.x,
        g.y,
        S.x,
        S.y,
        S.x,
        S.y,
        g.x,
        g.y,
        V.x,
        V.y
      );
    }
    return u;
  };
  return {
    quad: c,
    fullscreenQuad: e,
    spriteStride: t,
    createSpritesData: i,
    lightStride: s,
    createLightsGeometry: r,
    createShadowsGeometry: (l, h, u, d = 0) => {
      for (let m of u) {
        let f = [];
        switch (m.getType()) {
          case "circle":
            f = o(h, m);
            break;
          case "polygon":
            f = a(h, m);
            break;
        }
        l.set(f, d), d += f.length;
      }
      return d;
    }
  };
})(), xe = (c) => {
  switch (c) {
    case "float":
      return 1;
    case "vec2":
      return 2;
    case "vec3":
      return 3;
    case "vec4":
      return 4;
  }
};
class N {
  constructor() {
    this.ops = [], this.uniforms = [], this.uniformOffset = 0, this.uniform("resolution", "vec2"), this.uniform("time", "float");
  }
  declare(e, t) {
    return this.ops.push([0, e, t]), this;
  }
  set(e, t) {
    return this.ops.push([1, e, t]), this;
  }
  add(e, t) {
    return this.ops.push([2, e, t]), this;
  }
  sub(e, t) {
    return this.ops.push([3, e, t]), this;
  }
  mul(e, t) {
    return this.ops.push([4, e, t]), this;
  }
  div(e, t) {
    return this.ops.push([5, e, t]), this;
  }
  if(e) {
    return this.ops.push([7, e]), this;
  }
  elseif(e) {
    return this.ops.push([8, e]), this;
  }
  else() {
    return this.ops.push([
      9
      /* ELSE */
    ]), this;
  }
  endif() {
    return this.ops.push([
      10
      /* ENDIF */
    ]), this;
  }
  uniform(e, t) {
    return this.uniforms.push({ name: e, type: t, offset: this.uniformOffset }), this.uniformOffset += xe(t), this;
  }
  getUniforms() {
    return this.uniforms;
  }
  build(e) {
    const t = [];
    for (const i of this.ops) {
      const [s, ...r] = i;
      switch (s) {
        case 0: {
          const [o, a, n] = i, l = e.getBuilderOptions().declareVar(a, n);
          t.push(l);
          break;
        }
        case 1:
        case 2:
        case 3:
        case 4:
        case 5: {
          const o = r[0], a = r[1], n = `${o} ${this.getOpAssignmentSymbol(s)} ${a};`;
          t.push(this.replaceExpression(e, n));
          break;
        }
        case 7:
        case 8: {
          const o = r[0];
          t.push(`${s === 7 ? "" : "} else "}if (${this.replaceExpression(e, o)}) {`);
          break;
        }
        case 9:
        case 10: {
          t.push("}" + (s === 10 ? "" : " else {"));
          break;
        }
      }
    }
    return {
      mainImage: t,
      uniforms: this.uniforms.map((i) => e.getBuilderOptions().declareVar(i.name, i.type, !0))
    };
  }
  getOpAssignmentSymbol(e) {
    switch (e) {
      case 1:
        return "=";
      case 2:
        return "+=";
      case 3:
        return "-=";
      case 4:
        return "*=";
      case 5:
        return "/=";
      default:
        return "";
    }
  }
  replaceExpression(e, t) {
    if (e.getType() !== "webgpu")
      for (let i = 0; i < _; ++i)
        t = t.replace(new RegExp("texture\\s*\\(\\s*" + i + "\\s*,", "g"), "texture(uChannel" + i + ", ");
    return this.replaceComponents(e, t);
  }
  replaceComponents(e, t) {
    const i = e.getBuilderOptions().componentMap;
    return t.replace(/\.[rgba]{1,4}\b/g, (s) => {
      const r = s.substring(1);
      let o = ".";
      for (let a = 0; a < r.length; ++a) {
        const n = r[a];
        o += i[n] ?? n;
      }
      return o;
    });
  }
}
const F = new N().declare("uv", "vec2").set("uv", "fragCoord / uniforms.resolution").add("fragColor", "texture(0, uv)"), H = new N().declare("uv", "vec2").declare("baseColor", "vec4").set("uv", "fragCoord / uniforms.resolution").set("baseColor", "texture(0, uv)").add("fragColor", "vec4(baseColor.rgb * texture(1, uv).rgb, baseColor.a)"), W = new N().declare("uv", "vec2").declare("w", "float").declare("sum", "vec4").set("uv", "fragCoord / uniforms.resolution").set("w", "1.0 / uniforms.resolution.x").set(
  "sum",
  `(
    texture(0, uv + vec2(-3.0 * w, 0.0)) * 0.05 +
    texture(0, uv + vec2(-2.0 * w, 0.0)) * 0.1 +
    texture(0, uv + vec2(-1.0 * w, 0.0)) * 0.2 +
    texture(0, uv) * 0.3 +
    texture(0, uv + vec2(1.0 * w, 0.0)) * 0.2 +
    texture(0, uv + vec2(2.0 * w, 0.0)) * 0.1 +
    texture(0, uv + vec2(3.0 * w, 0.0)) * 0.05
)`
).set("fragColor", "sum"), $ = new N().declare("uv", "vec2").declare("h", "float").declare("sum", "vec4").set("uv", "fragCoord / uniforms.resolution").set("h", "1.0 / uniforms.resolution.y").set(
  "sum",
  `(
    texture(0, uv + vec2(0.0, -3.0 * h)) * 0.05 +
    texture(0, uv + vec2(0.0, -2.0 * h)) * 0.1 +
    texture(0, uv + vec2(0.0, -1.0 * h)) * 0.2 +
    texture(0, uv) * 0.3 +
    texture(0, uv + vec2(0.0, 1.0 * h)) * 0.2 +
    texture(0, uv + vec2(0.0, 2.0 * h)) * 0.1 +
    texture(0, uv + vec2(0.0, 3.0 * h)) * 0.05
)`
).set("fragColor", "sum");
class re {
  constructor(e, t, i, s, r) {
    this.tileset = e, this.id = t, this.x = i, this.y = s, this.properties = r?.properties, this.animation = r?.animation;
  }
  getProperty(e) {
    return this.properties?.find((t) => t.name === e)?.value;
  }
}
const O = class O {
  constructor(e) {
    if (this.name = e.name, this.imageWidth = e.imagewidth, this.imageHeight = e.imageheight, this.tileWidth = e.tilewidth, this.tileHeight = e.tileheight, this.columns = e.columns, this.tileCount = e.tilecount, this.margin = e.margin || 0, this.spacing = e.spacing || 0, this.tiledata = /* @__PURE__ */ new Map(), e.tiles)
      for (let t of e.tiles)
        this.tiledata.set(t.id, t);
  }
  static async load(e) {
    if (!this.cache.has(e)) {
      const t = await ne.loadJson(e);
      this.cache.set(e, new O(t));
    }
    return this.cache.get(e);
  }
  static getByName(e) {
    return this.cache.values().find((t) => t.name === e) || null;
  }
  getTile(e, t) {
    if (e < 0 || e >= this.columns || t < 0 || t >= Math.ceil(this.tileCount / this.columns)) return null;
    const i = t * this.columns + e, s = this.tiledata.get(i);
    return new re(this, i, e, t, s);
  }
  getTileById(e) {
    if (e >= this.tileCount || e < 0) return null;
    const t = e % this.columns, i = Math.floor(e / this.columns), s = this.tiledata.get(e);
    return new re(this, e, t, i, s);
  }
  getTileXY(e) {
    const t = e % this.columns, i = Math.floor(e / this.columns);
    return { x: t, y: i };
  }
};
O.cache = /* @__PURE__ */ new Map();
let E = O;
class he {
  constructor(e, t, i) {
    this.gl = e, this.width = t, this.height = i, this.texture = e.createTexture(), e.bindTexture(e.TEXTURE_2D, this.texture), e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, t, i, 0, e.RGBA, e.UNSIGNED_BYTE, null), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.LINEAR), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.LINEAR), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE), this.fbo = e.createFramebuffer(), e.bindFramebuffer(e.FRAMEBUFFER, this.fbo), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, this.texture, 0), e.checkFramebufferStatus(e.FRAMEBUFFER) !== e.FRAMEBUFFER_COMPLETE && console.error("Framebuffer incomplete!"), e.bindFramebuffer(e.FRAMEBUFFER, null), e.bindTexture(e.TEXTURE_2D, null);
  }
  bind() {
    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.fbo), this.gl.viewport(0, 0, this.width, this.height);
  }
  unbind() {
    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
  }
  destroy() {
    this.gl.deleteFramebuffer(this.fbo), this.gl.deleteTexture(this.texture);
  }
}
class T {
  constructor(e, t, i) {
    this.gl = e, this.uniforms = /* @__PURE__ */ new Map(), this.attribs = /* @__PURE__ */ new Map();
    const s = this.compileShader(e.VERTEX_SHADER, t), r = this.compileShader(e.FRAGMENT_SHADER, i);
    if (this.program = e.createProgram(), e.attachShader(this.program, s), e.attachShader(this.program, r), e.linkProgram(this.program), !e.getProgramParameter(this.program, e.LINK_STATUS))
      throw new Error(e.getProgramInfoLog(this.program) ?? "Could not link program");
    e.deleteShader(s), e.deleteShader(r);
  }
  compileShader(e, t) {
    const i = this.gl.createShader(e);
    if (!i) throw new Error("Could not create shader");
    if (this.gl.shaderSource(i, t), this.gl.compileShader(i), !this.gl.getShaderParameter(i, this.gl.COMPILE_STATUS))
      throw new Error(this.gl.getShaderInfoLog(i) ?? "Could not compile shader");
    return i;
  }
  use() {
    this.gl.useProgram(this.program);
  }
  getUniform(e) {
    if (!this.uniforms.has(e)) {
      const t = this.gl.getUniformLocation(this.program, e);
      this.uniforms.set(e, t);
    }
    return this.uniforms.get(e);
  }
  getAttrib(e) {
    return this.attribs.has(e) || this.attribs.set(e, this.gl.getAttribLocation(this.program, e)), this.attribs.get(e);
  }
}
const q = `
vec4 worldToClip(vec2 worldPos, vec2 cameraPos, vec2 viewport) {
    vec2 pixelPos = worldPos - cameraPos;
    vec2 clipPos = vec2(pixelPos.x / viewport.x, 1.0 - pixelPos.y / viewport.y) * 2.0 - 1.0;
    return vec4(clipPos, 0.0, 1.0);
}
`, se = `

attribute vec2 aVertexPos;
attribute vec2 aTexCoord;
attribute vec2 aTilePos;
attribute float aTileAngle;
attribute vec2 aTileScale;
attribute vec4 aTileRegion;
attribute vec4 aTintColor;
attribute vec4 aMaskColor;
attribute vec2 aTileOffset;

uniform vec2 uViewportDimensions;
uniform vec2 uCameraPos;

uniform vec2 uTilesetDimensions;

varying vec2 uv;
varying vec4 tintColor;
varying vec4 maskColor;

${q}

void main() {
    tintColor = aTintColor;
    maskColor = aMaskColor;

    vec2 flippedTexCoord = vec2(aTexCoord.x, 1.0 - aTexCoord.y);
    uv = (vec2(aTileRegion.xy) + flippedTexCoord * vec2(aTileRegion.zw)) / uTilesetDimensions;

    float c = cos(aTileAngle);
    float s = sin(aTileAngle);
    vec2 offsetPos = aVertexPos * aTileScale + aTileOffset;
    vec2 rotatedPos = vec2(
        offsetPos.x * c - offsetPos.y * s,
        offsetPos.x * s + offsetPos.y * c
    );
    vec2 worldPos = rotatedPos + aTilePos;

    gl_Position = worldToClip(worldPos, uCameraPos, uViewportDimensions);
}
`, ve = `

precision mediump float;

varying vec2 uv;
varying vec4 tintColor;

uniform sampler2D uSampler;  

void main() {
    gl_FragColor = texture2D(uSampler, uv) * tintColor;
}
`, be = `

precision mediump float;

varying vec2 uv;
varying vec4 maskColor;

uniform mediump sampler2D uSampler;  

void main() {
    vec4 texColor = texture2D(uSampler, uv);
    gl_FragColor = vec4(maskColor.rgb, texColor.a * maskColor.a);
}
`, ye = `
precision mediump float;

attribute vec2 aVertexPos;

uniform vec2 uLightCenter;
uniform float uLightRadius;

uniform vec2 uCameraPos;
uniform vec2 uViewportDimensions;

varying vec2 worldPos;

${q}

void main() {
    worldPos = uLightCenter + (aVertexPos - 0.5) * 2.0 * uLightRadius;

    gl_Position = worldToClip(worldPos, uCameraPos, uViewportDimensions);
}
`, we = `

precision mediump float;

varying vec2 worldPos;

uniform vec2 uLightCenter;
uniform float uLightRadius;
uniform vec3 uLightColor;
uniform float uLightIntensity;
uniform vec2 uLightDir;
uniform float uLightCutoff;

void main() {
    vec2 toPixel = worldPos - uLightCenter;
    float dist = length(toPixel);

    float attenuation = clamp(1.0 - pow(dist / uLightRadius, 2.0), 0.0, 1.0);

    float spotFactor = 1.0;
    if (uLightCutoff > 0.0) {
        float cosAngle = dot(normalize(uLightDir), normalize(toPixel));
        spotFactor = clamp((cosAngle - uLightCutoff) / (1.0 - uLightCutoff), 0.0, 1.0);
    }

    gl_FragColor = vec4(uLightColor * uLightIntensity * attenuation * spotFactor, 1.0);
}
`, Te = `
attribute vec2 aPos;

uniform vec2 uCameraPos;
uniform vec2 uViewportDimensions;

${q}

void main() {
    gl_Position = worldToClip(aPos, uCameraPos, uViewportDimensions);
}
`, Ce = `
precision mediump float;

uniform vec2 uLightPos;

void main() {
    gl_FragColor = vec4(vec3(0.0), 1.0);
}
`, Ae = `

attribute vec2 aPos;

void main() {
    gl_Position = vec4(aPos, 0.0, 1.0);
}
`, Pe = (c) => `
#define texture texture2D

precision mediump float;

struct Uniforms {
${c.uniforms.map((e) => "    " + e).join(`
`)}
};

uniform sampler2D uChannel0;
uniform sampler2D uChannel1;
uniform sampler2D uChannel2;
uniform sampler2D uChannel3;
uniform sampler2D uChannel4;
uniform sampler2D uChannel5;
uniform sampler2D uChannel6;
uniform sampler2D uChannel7;

uniform Uniforms uniforms;

void mainImage(out vec4 fragColor, in vec2 fragCoord) {
${c.mainImage.map((e) => "    " + e).join(`
`)}
}

void main() {
    vec2 fragCoord = vec2(gl_FragCoord.x, gl_FragCoord.y);
    mainImage(gl_FragColor, fragCoord);
}
`, Re = {
  componentMap: { r: "r", g: "g", b: "b", a: "a" },
  declareVar: (c, e) => `${e} ${c};`
};
class Ee {
  constructor(e) {
    this.canvas = e, this.layersMap = /* @__PURE__ */ new Map(), this.texturesMap = /* @__PURE__ */ new Map(), this.clearColor = new C(0, 0, 0, 0), this.shaderMap = /* @__PURE__ */ new Map(), this.initialized = !1, this.pass = [Q], this.framebuffers = [], this.shaderCache = /* @__PURE__ */ new Map(), this.time = 0;
  }
  getType() {
    return "webgl";
  }
  getBuilderOptions() {
    return Re;
  }
  addTextures(e, t) {
    for (const i of e)
      t[i.name] && this.texturesMap.set(i.name, {
        tileset: i,
        image: t[i.name]
      });
  }
  addImageTextures(e) {
    for (let t of e) {
      const i = new E({
        name: t.name,
        tilecount: 1,
        columns: 1,
        tilewidth: t.width,
        tileheight: t.height,
        imagewidth: t.width,
        imageheight: t.height
      });
      this.texturesMap.set(t.name, {
        tileset: i,
        image: t.image
      });
    }
  }
  registerShader(e, t, i = "none") {
    this.shaderMap.set(e, { builder: t, blendMode: i });
  }
  setClearColor(e) {
    this.clearColor.copy(e);
  }
  setSize(e, t) {
    this.canvas.width = e, this.canvas.height = t, this.initialized && this.initFramebuffers();
  }
  getCanvas() {
    return this.canvas;
  }
  initFramebuffers() {
    for (let e = 0; e < y; ++e) {
      const t = ee(e);
      this.framebuffers[e]?.destroy(), this.framebuffers[e] = new he(this.gl, this.canvas.width * t, this.canvas.height * t);
    }
  }
  blend(e) {
    switch (e) {
      case "alpha":
        this.gl.enable(this.gl.BLEND), this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
        break;
      case "additive":
        this.gl.enable(this.gl.BLEND), this.gl.blendFunc(this.gl.ONE, this.gl.ONE);
        break;
      default:
        this.gl.disable(this.gl.BLEND);
    }
  }
  async init() {
    const e = this.canvas.getContext("webgl");
    if (!e) throw new Error("WebGL not supported");
    this.gl = e;
    for (const r of this.texturesMap.values())
      r.tileset && (r.texture = this.createTexture(r.image));
    this.registerShader("default", F), this.registerShader("default_additive", F, "additive"), this.registerShader("light", H), this.registerShader("blurHorizontal", W), this.registerShader("blurVertical", $);
    for (const r of this.shaderMap.values()) {
      if (!this.shaderCache.has(r.builder)) {
        const o = r.builder.build(this), a = new T(e, Ae, Pe(o));
        this.shaderCache.set(r.builder, a);
      }
      r.shader = this.shaderCache.get(r.builder);
    }
    this.shaderProgram = new T(e, se, ve), this.maskShaderProgram = new T(e, se, be), this.lightShaderProgram = new T(e, ye, we), this.shadowShaderProgram = new T(e, Te, Ce), this.vbo = e.createBuffer(), e.bindBuffer(e.ARRAY_BUFFER, this.vbo);
    const t = new Float32Array(R * 4 * 4);
    for (let r = 0; r < R; ++r)
      t.set(b.quad, r * 4 * 4);
    e.bufferData(e.ARRAY_BUFFER, t, e.STATIC_DRAW);
    const i = [0, 1, 2, 1, 2, 3];
    this.ebo = e.createBuffer(), e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this.ebo);
    const s = new Uint16Array(R * 6);
    for (let r = 0; r < R; ++r)
      for (let o = 0; o < 6; ++o)
        s[r * 6 + o] = i[o] + 4 * r;
    e.bufferData(e.ELEMENT_ARRAY_BUFFER, s, e.STATIC_DRAW), this.initFramebuffers(), this.fullscreenVbo = e.createBuffer(), e.bindBuffer(e.ARRAY_BUFFER, this.fullscreenVbo), e.bufferData(e.ARRAY_BUFFER, b.fullscreenQuad, e.STATIC_DRAW), this.shadowsVbo = e.createBuffer(), e.bindBuffer(e.ARRAY_BUFFER, this.shadowsVbo), e.bufferData(e.ARRAY_BUFFER, M * L * 8, e.DYNAMIC_DRAW), this.initialized = !0;
  }
  renderScene(e, t, i, s, r) {
    e.bind(), this.blend("alpha"), s && (this.gl.clearColor(s.r, s.g, s.b, s.a), this.gl.clear(this.gl.COLOR_BUFFER_BIT)), this.gl.activeTexture(this.gl.TEXTURE0), t.use(), this.gl.uniform2f(t.getUniform("uViewportDimensions"), i.vw, i.vh), this.gl.uniform2f(t.getUniform("uCameraPos"), i.position.x, i.position.y);
    for (let o of r)
      o.render(t);
    e.unbind();
  }
  renderLights(e, t) {
    const i = t.getBounds(), s = e.getLights().filter((h) => B(i, h.getBounds())), r = new Float32Array(s.length * L * 2), o = [];
    let a = 0;
    for (let h of s) {
      const u = e.getColliders(h.getBounds()), d = b.createShadowsGeometry(r, h, u, a);
      o.push({ count: (d - a) / 2, offset: a / 2 }), a = d;
    }
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.shadowsVbo), this.gl.bufferSubData(this.gl.ARRAY_BUFFER, 0, r), this.framebuffers[v].bind(), this.gl.clearColor(
      e.ambientColor.r * e.ambientIntensity,
      e.ambientColor.g * e.ambientIntensity,
      e.ambientColor.b * e.ambientIntensity,
      1
    ), this.gl.clear(this.gl.COLOR_BUFFER_BIT), this.framebuffers[v].unbind();
    const n = this.lightShaderProgram.getAttrib("aVertexPos"), l = this.shadowShaderProgram.getAttrib("aPos");
    for (let h = 0; h < s.length; ++h) {
      const u = s[h];
      this.framebuffers[v + 1].bind(), this.blend("none"), this.gl.clearColor(0, 0, 0, 1), this.gl.clear(this.gl.COLOR_BUFFER_BIT), this.lightShaderProgram.use(), this.gl.uniform2f(this.lightShaderProgram.getUniform("uViewportDimensions"), t.vw, t.vh), this.gl.uniform2f(this.lightShaderProgram.getUniform("uCameraPos"), t.position.x, t.position.y), this.gl.uniform2f(this.lightShaderProgram.getUniform("uLightCenter"), u.position.x, u.position.y), this.gl.uniform1f(this.lightShaderProgram.getUniform("uLightRadius"), u.radius), this.gl.uniform3f(this.lightShaderProgram.getUniform("uLightColor"), u.color.r, u.color.g, u.color.b), this.gl.uniform1f(this.lightShaderProgram.getUniform("uLightIntensity"), u.intensity), this.gl.uniform2f(this.lightShaderProgram.getUniform("uLightDir"), u.direction.x, u.direction.y), this.gl.uniform1f(this.lightShaderProgram.getUniform("uLightCutoff"), u.cutoff), this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vbo), this.gl.enableVertexAttribArray(n), this.gl.vertexAttribPointer(n, 2, this.gl.FLOAT, !1, 16, 0), this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4), this.gl.disableVertexAttribArray(n);
      const d = o[h];
      d.count !== 0 && (this.shadowShaderProgram.use(), this.gl.uniform2f(this.shadowShaderProgram.getUniform("uViewportDimensions"), t.vw, t.vh), this.gl.uniform2fv(this.shadowShaderProgram.getUniform("uCameraPos"), t.position.toArray()), this.gl.uniform2fv(this.shadowShaderProgram.getUniform("uLightPos"), u.position.toArray()), this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.shadowsVbo), this.gl.enableVertexAttribArray(l), this.gl.vertexAttribPointer(l, 2, this.gl.FLOAT, !1, 8, 0), this.gl.drawArrays(this.gl.TRIANGLES, d.offset, d.count), this.gl.disableVertexAttribArray(l)), this.framebuffers[v + 1].unbind(), this.renderFullscreenPass({ shader: "blurHorizontal", inputs: [v + 1], output: 4 }), this.renderFullscreenPass({ shader: "blurVertical", inputs: [4], output: 5 }), this.renderFullscreenPass({ shader: "default_additive", inputs: [5], output: v });
    }
  }
  renderFullscreenPass(e) {
    const t = this.shaderMap.get(e.shader);
    if (!t)
      throw new Error("Unknown shader " + e.shader);
    e.clearColor && (this.gl.clearColor(this.clearColor.r, this.clearColor.g, this.clearColor.b, this.clearColor.a), this.gl.clear(this.gl.COLOR_BUFFER_BIT));
    const i = t.shader;
    let s = this.canvas.width, r = this.canvas.height;
    if (e.output !== -1) {
      const l = this.framebuffers[w.clamp(e.output, 0, y - 1)];
      s = l.width, r = l.height, l.bind();
    } else
      this.gl.viewport(0, 0, s, r);
    this.blend(t.blendMode), i.use();
    const o = [{ name: "time", value: this.time }, { name: "resolution", value: [s, r] }].concat(e.uniforms ?? []), a = t.builder.getUniforms();
    for (let l of a) {
      const h = o.find((u) => u.name === l.name);
      if (h) {
        const u = typeof h.value == "number" ? [h.value] : h.value, d = i.getUniform("uniforms." + l.name);
        switch (l.type) {
          case "float":
            this.gl.uniform1f(d, u[0]);
            break;
          case "vec2":
            this.gl.uniform2fv(d, u);
            break;
          case "vec3":
            this.gl.uniform3fv(d, u);
            break;
          case "vec4":
            this.gl.uniform4fv(d, u);
            break;
        }
      }
    }
    for (let l = 0; l < _; l++) {
      const h = e.inputs[l] ?? e.inputs[0], u = this.framebuffers[w.clamp(h, 0, y - 1)].texture;
      this.gl.activeTexture(this.gl.TEXTURE0 + l), this.gl.bindTexture(this.gl.TEXTURE_2D, u);
      const d = i.getUniform(`uChannel${l}`);
      this.gl.uniform1i(d, l);
    }
    const n = i.getAttrib("aPos");
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.fullscreenVbo), this.gl.enableVertexAttribArray(n), this.gl.vertexAttribPointer(n, 2, this.gl.FLOAT, !1, 16, 0), this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4), this.gl.disableVertexAttribArray(n);
    for (let l = 0; l < _; l++)
      this.gl.activeTexture(this.gl.TEXTURE0 + l), this.gl.bindTexture(this.gl.TEXTURE_2D, null);
    e.output !== -1 && this.framebuffers[w.clamp(e.output, 0, y - 1)].unbind();
  }
  render(e, t) {
    if (!this.initialized)
      throw new Error("Renderer is not initialized");
    const i = t.getBounds();
    this.time = performance.now() * 1e-3;
    const s = [], r = [], o = [];
    for (const a of e.getLayersOrdered()) {
      let n;
      if (this.layersMap.has(a) || this.layersMap.set(a, new Se(this.gl, this, a.isStatic)), n = this.layersMap.get(a), n.needsUpdate) {
        let l = a.getSpritesOrdered();
        n.isStatic || (l = l.filter((h) => B(i, h.getBounds()))), n.uploadSprites(a.getSpritesOrdered());
      }
      s.push(n), a.zIndex <= e.shadowsZIndex ? r.push(n) : o.push(n);
    }
    this.renderScene(this.framebuffers[0], this.shaderProgram, t, this.clearColor, s), this.renderFullscreenPass({ shader: "default", inputs: [0], output: -1 }), this.renderLights(e, t), this.renderScene(this.framebuffers[I], this.shaderProgram, t, this.clearColor, r), this.renderFullscreenPass({ shader: "light", inputs: [I, v], output: 0 }), this.renderScene(this.framebuffers[0], this.shaderProgram, t, null, o), this.renderScene(this.framebuffers[J], this.maskShaderProgram, t, te, s);
    for (let a = 0; a < this.pass.length; ++a) {
      const n = this.pass[a];
      this.renderFullscreenPass(n);
    }
    for (const [a, n] of this.layersMap)
      n.lifetime <= 0 && (this.layersMap.delete(a), n.destroy());
  }
  getTextureInfo(e) {
    const t = this.texturesMap.get(e);
    if (!t) throw new Error("Texture not found: " + e);
    return t;
  }
  getVBO() {
    return this.vbo;
  }
  getEBO() {
    return this.ebo;
  }
  createTexture(e) {
    const t = this.gl, i = t.createTexture();
    return t.bindTexture(t.TEXTURE_2D, i), t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, t.RGBA, t.UNSIGNED_BYTE, e), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.NEAREST), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.NEAREST), i;
  }
}
let Se = class {
  constructor(e, t, i) {
    this.gl = e, this.renderer = t, this.isStatic = i, this.needsUpdate = !0, this.drawCalls = [], this.lifetime = U, this.spriteBuffer = e.createBuffer(), e.bindBuffer(e.ARRAY_BUFFER, this.spriteBuffer), e.bufferData(e.ARRAY_BUFFER, (this.isStatic ? R : Z) * b.spriteStride * 4, this.isStatic ? e.STATIC_DRAW : e.DYNAMIC_DRAW);
  }
  uploadSprites(e) {
    const t = this.gl;
    t.bindBuffer(t.ARRAY_BUFFER, this.spriteBuffer), t.bufferSubData(t.ARRAY_BUFFER, 0, b.createSpritesData(e, !1)), this.isStatic && (this.needsUpdate = !1), this.drawCalls.length = 0;
    let i = null;
    for (let s = 0; s < e.length; ++s) {
      const r = e[s].tileset.name;
      !i || r !== i.texName ? (i = { texName: r, spriteOffset: s, spriteCount: 1 }, this.drawCalls.push(i)) : i.spriteCount++;
    }
  }
  render(e) {
    const t = this.gl;
    t.bindBuffer(t.ARRAY_BUFFER, this.renderer.getVBO());
    const i = {
      vertexPos: e.getAttrib("aVertexPos"),
      texCoord: e.getAttrib("aTexCoord"),
      tilePos: e.getAttrib("aTilePos"),
      tileScale: e.getAttrib("aTileScale"),
      tileAngle: e.getAttrib("aTileAngle"),
      tileRegion: e.getAttrib("aTileRegion"),
      tintColor: e.getAttrib("aTintColor"),
      maskColor: e.getAttrib("aMaskColor"),
      tileOffset: e.getAttrib("aTileOffset")
    };
    t.enableVertexAttribArray(i.vertexPos), t.vertexAttribPointer(i.vertexPos, 2, t.FLOAT, !1, 16, 0), t.enableVertexAttribArray(i.texCoord), t.vertexAttribPointer(i.texCoord, 2, t.FLOAT, !1, 16, 8), t.bindBuffer(t.ARRAY_BUFFER, this.spriteBuffer);
    const s = b.spriteStride;
    t.enableVertexAttribArray(i.tilePos), t.vertexAttribPointer(i.tilePos, 2, t.FLOAT, !1, s, 0), t.enableVertexAttribArray(i.tileScale), t.vertexAttribPointer(i.tileScale, 2, t.FLOAT, !1, s, 8), t.enableVertexAttribArray(i.tileAngle), t.vertexAttribPointer(i.tileAngle, 1, t.FLOAT, !1, s, 16), t.enableVertexAttribArray(i.tileRegion), t.vertexAttribPointer(i.tileRegion, 4, t.UNSIGNED_SHORT, !1, s, 20), t.enableVertexAttribArray(i.tintColor), t.vertexAttribPointer(i.tintColor, 4, t.FLOAT, !1, s, 28), t.enableVertexAttribArray(i.maskColor), t.vertexAttribPointer(i.maskColor, 4, t.FLOAT, !1, s, 44), t.enableVertexAttribArray(i.tileOffset), t.vertexAttribPointer(i.tileOffset, 2, t.FLOAT, !1, s, 60), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.renderer.getEBO());
    for (const r of this.drawCalls) {
      const o = this.renderer.getTextureInfo(r.texName);
      t.bindTexture(t.TEXTURE_2D, o.texture), this.gl.uniform2f(e.getUniform("uTilesetDimensions"), o.tileset.imageWidth, o.tileset.imageHeight), t.drawElements(t.TRIANGLES, 6 * r.spriteCount, t.UNSIGNED_SHORT, r.spriteOffset * 6 * 2);
    }
    t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, null), t.disableVertexAttribArray(i.vertexPos), t.disableVertexAttribArray(i.texCoord), t.disableVertexAttribArray(i.tilePos), t.disableVertexAttribArray(i.tileScale), t.disableVertexAttribArray(i.tileAngle), t.disableVertexAttribArray(i.tileRegion), t.disableVertexAttribArray(i.tintColor), t.disableVertexAttribArray(i.maskColor), this.lifetime = U;
  }
  destroy() {
    this.gl.deleteBuffer(this.spriteBuffer);
  }
};
const j = `
vec4 worldToClip(vec2 worldPos, vec2 cameraPos, vec2 viewport) {
    vec2 pixelPos = worldPos - cameraPos;
    vec2 clipPos = vec2(pixelPos.x / viewport.x, 1.0 - pixelPos.y / viewport.y) * 2.0 - 1.0;
    return vec4(clipPos, 0.0, 1.0);
}
`, oe = `#version 300 es

layout(location = 0) in vec2 aVertexPos;
layout(location = 1) in vec2 aTexCoord;

layout(location = 2) in vec2 aTilePos;
layout(location = 3) in vec2 aTileScale;
layout(location = 4) in float aTileAngle;
layout(location = 5) in uvec4 aTileRegion;

layout(location = 6) in vec4 aTintColor;
layout(location = 7) in vec4 aMaskColor;

layout(location = 8) in vec2 aTileOffset;

uniform vec2 uViewportDimensions;
uniform vec2 uCameraPos;

uniform vec2 uTilesetDimensions;

out vec2 uv;
out vec4 tintColor;
out vec4 maskColor;

${j}

void main() {
    tintColor = aTintColor;
    maskColor = aMaskColor;

    vec2 flippedTexCoord = vec2(aTexCoord.x, 1.0 - aTexCoord.y);
    uv = (vec2(aTileRegion.xy) + flippedTexCoord * vec2(aTileRegion.zw)) / uTilesetDimensions;

    float c = cos(aTileAngle);
    float s = sin(aTileAngle);
    vec2 offsetPos = aVertexPos * aTileScale + aTileOffset;
    vec2 rotatedPos = vec2(
        offsetPos.x * c - offsetPos.y * s,
        offsetPos.x * s + offsetPos.y * c
    );
    vec2 worldPos = rotatedPos + aTilePos;

    gl_Position = worldToClip(worldPos, uCameraPos, uViewportDimensions);
}
`, Be = `#version 300 es

precision mediump float;

in vec2 uv;
in vec4 tintColor;

uniform mediump sampler2D uSampler;

out vec4 fragColor;

void main() {
    fragColor = texture(uSampler, uv) * tintColor;
}
`, Fe = `#version 300 es

precision mediump float;

in vec2 uv;
in vec4 maskColor;

uniform mediump sampler2D uSampler;  

out vec4 fragColor;

void main() {
    vec4 texColor = texture(uSampler, uv);
    fragColor = vec4(maskColor.rgb, texColor.a * maskColor.a);
}
`, Ue = `#version 300 es
precision mediump float;

layout(location = 0) in vec2 aVertexPos;

uniform vec2 uLightCenter;
uniform float uLightRadius;

uniform vec2 uCameraPos;
uniform vec2 uViewportDimensions;

out vec2 worldPos;

${j}

void main() {
    worldPos = uLightCenter + (aVertexPos - 0.5) * 2.0 * uLightRadius;

    gl_Position = worldToClip(worldPos, uCameraPos, uViewportDimensions);
}
`, _e = `#version 300 es

precision mediump float;

in vec2 worldPos;

uniform vec2 uLightCenter;
uniform float uLightRadius;
uniform vec3 uLightColor;
uniform float uLightIntensity;
uniform vec2 uLightDir;
uniform float uLightCutoff;

out vec4 fragColor;

void main() {
    vec2 toPixel = worldPos - uLightCenter;
    float dist = length(toPixel);

    float attenuation = clamp(1.0 - pow(dist / uLightRadius, 2.0), 0.0, 1.0);

    float spotFactor = 1.0;
    if (uLightCutoff > 0.0) {
        float cosAngle = dot(normalize(uLightDir), normalize(toPixel));
        spotFactor = clamp((cosAngle - uLightCutoff) / (1.0 - uLightCutoff), 0.0, 1.0);
    }

    fragColor = vec4(uLightColor * uLightIntensity * attenuation * spotFactor, 1.0);
}
`, Le = `#version 300 es

layout(location = 0) in vec2 aPos;

uniform vec2 uCameraPos;
uniform vec2 uViewportDimensions;

${j}

void main() {
    gl_Position = worldToClip(aPos, uCameraPos, uViewportDimensions);
}
`, Ie = `#version 300 es

precision mediump float;

uniform vec2 uLightPos;

out vec4 fragColor;

void main() {
    fragColor = vec4(vec3(0.0), 1.0);
}
`, De = `#version 300 es

out vec2 uv;

void main() {
    float x = float((gl_VertexID & 1) << 2);
    float y = float((gl_VertexID & 2) << 1);

    gl_Position = vec4(x - 1.0, y - 1.0, 0.0, 1.0);
}
`, Ve = (c) => `#version 300 es
precision mediump float;

struct Uniforms {
${c.uniforms.map((e) => "    " + e).join(`
`)}
};

uniform sampler2D uChannel0;
uniform sampler2D uChannel1;
uniform sampler2D uChannel2;
uniform sampler2D uChannel3;
uniform sampler2D uChannel4;
uniform sampler2D uChannel5;
uniform sampler2D uChannel6;
uniform sampler2D uChannel7;

uniform Uniforms uniforms;

out vec4 fragColor;

void mainImage(out vec4 fragColor, in vec2 fragCoord) {
${c.mainImage.map((e) => "    " + e).join(`
`)}
}

void main() {
    vec2 fragCoord = gl_FragCoord.xy;
    mainImage(fragColor, fragCoord);
}
`, Me = {
  componentMap: { r: "r", g: "g", b: "b", a: "a" },
  declareVar: (c, e) => `${e} ${c};`
};
class Oe {
  constructor(e) {
    this.canvas = e, this.layersMap = /* @__PURE__ */ new Map(), this.texturesMap = /* @__PURE__ */ new Map(), this.clearColor = new C(0, 0, 0, 0), this.shaderMap = /* @__PURE__ */ new Map(), this.initialized = !1, this.pass = [Q], this.framebuffers = [], this.time = 0, this.shaderCache = /* @__PURE__ */ new Map();
  }
  getType() {
    return "webgl2";
  }
  getBuilderOptions() {
    return Me;
  }
  addTextures(e, t) {
    for (const i of e)
      t[i.name] && this.texturesMap.set(i.name, {
        tileset: i,
        image: t[i.name]
      });
  }
  addImageTextures(e) {
    for (let t of e) {
      const i = new E({
        name: t.name,
        tilecount: 1,
        columns: 1,
        tilewidth: t.width,
        tileheight: t.height,
        imagewidth: t.width,
        imageheight: t.height
      });
      this.texturesMap.set(t.name, {
        tileset: i,
        image: t.image
      });
    }
  }
  registerShader(e, t, i = "none") {
    this.shaderMap.set(e, { builder: t, blendMode: i });
  }
  setClearColor(e) {
    this.clearColor.copy(e);
  }
  setSize(e, t) {
    this.canvas.width = e, this.canvas.height = t, this.initialized && this.initFramebuffers();
  }
  getCanvas() {
    return this.canvas;
  }
  initFramebuffers() {
    for (let e = 0; e < y; ++e) {
      const t = ee(e);
      this.framebuffers[e]?.destroy(), this.framebuffers[e] = new he(this.gl, this.canvas.width * t, this.canvas.height * t);
    }
  }
  blend(e) {
    switch (e) {
      case "alpha":
        this.gl.enable(this.gl.BLEND), this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
        break;
      case "additive":
        this.gl.enable(this.gl.BLEND), this.gl.blendFunc(this.gl.ONE, this.gl.ONE);
        break;
      default:
        this.gl.disable(this.gl.BLEND);
    }
  }
  async init() {
    const e = this.canvas.getContext("webgl2");
    if (!e) throw new Error("WebGL2 not supported");
    this.gl = e;
    for (const t of this.texturesMap.values())
      t.tileset && (t.texture = this.createTexture(t.image));
    this.initFramebuffers(), this.registerShader("default", F), this.registerShader("default_additive", F, "additive"), this.registerShader("light", H), this.registerShader("blurHorizontal", W), this.registerShader("blurVertical", $);
    for (const t of this.shaderMap.values()) {
      if (!this.shaderCache.has(t.builder)) {
        const i = t.builder.build(this), s = new T(e, De, Ve(i));
        this.shaderCache.set(t.builder, s);
      }
      t.shader = this.shaderCache.get(t.builder);
    }
    this.shaderProgram = new T(e, oe, Be), this.maskShaderProgram = new T(e, oe, Fe), this.lightShaderProgram = new T(e, Ue, _e), this.shadowShaderProgram = new T(e, Le, Ie), this.vbo = e.createBuffer(), e.bindBuffer(e.ARRAY_BUFFER, this.vbo), e.bufferData(e.ARRAY_BUFFER, b.quad, e.STATIC_DRAW), this.lightVao = e.createVertexArray(), e.bindVertexArray(this.lightVao), e.bindBuffer(e.ARRAY_BUFFER, this.vbo), e.enableVertexAttribArray(0), e.vertexAttribPointer(0, 2, e.FLOAT, !1, 16, 0), e.bindVertexArray(null), this.shadowsVbo = e.createBuffer(), e.bindBuffer(e.ARRAY_BUFFER, this.shadowsVbo), e.bufferData(e.ARRAY_BUFFER, M * L * 8, e.DYNAMIC_DRAW), this.shadowsVao = e.createVertexArray(), e.bindVertexArray(this.shadowsVao), e.bindBuffer(e.ARRAY_BUFFER, this.shadowsVbo), e.enableVertexAttribArray(0), e.vertexAttribPointer(0, 2, e.FLOAT, !1, 8, 0), e.bindVertexArray(null), this.initialized = !0;
  }
  renderScene(e, t, i, s, r) {
    e.bind(), this.blend("alpha"), s && (this.gl.clearColor(s.r, s.g, s.b, s.a), this.gl.clear(this.gl.COLOR_BUFFER_BIT)), this.gl.activeTexture(this.gl.TEXTURE0), t.use(), this.gl.uniform2f(t.getUniform("uViewportDimensions"), i.vw, i.vh), this.gl.uniform2f(t.getUniform("uCameraPos"), i.position.x, i.position.y);
    for (let o of r)
      o.render(t);
    e.unbind();
  }
  renderLights(e, t) {
    const i = t.getBounds(), s = e.getLights().filter((n) => B(i, n.getBounds())), r = new Float32Array(s.length * L * 2), o = [];
    let a = 0;
    for (let n of s) {
      const l = e.getColliders(n.getBounds()), h = b.createShadowsGeometry(r, n, l, a);
      o.push({ count: (h - a) / 2, offset: a / 2 }), a = h;
    }
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.shadowsVbo), this.gl.bufferSubData(this.gl.ARRAY_BUFFER, 0, r, 0, a), this.framebuffers[v].bind(), this.gl.clearColor(
      e.ambientColor.r * e.ambientIntensity,
      e.ambientColor.g * e.ambientIntensity,
      e.ambientColor.b * e.ambientIntensity,
      1
    ), this.gl.clear(this.gl.COLOR_BUFFER_BIT), this.framebuffers[v].unbind();
    for (let n = 0; n < s.length; ++n) {
      const l = s[n];
      this.framebuffers[v + 1].bind(), this.blend("none"), this.gl.clearColor(0, 0, 0, 1), this.gl.clear(this.gl.COLOR_BUFFER_BIT), this.lightShaderProgram.use(), this.gl.uniform2f(this.lightShaderProgram.getUniform("uViewportDimensions"), t.vw, t.vh), this.gl.uniform2f(this.lightShaderProgram.getUniform("uCameraPos"), t.position.x, t.position.y), this.gl.uniform2f(this.lightShaderProgram.getUniform("uLightCenter"), l.position.x, l.position.y), this.gl.uniform1f(this.lightShaderProgram.getUniform("uLightRadius"), l.radius), this.gl.uniform3f(this.lightShaderProgram.getUniform("uLightColor"), l.color.r, l.color.g, l.color.b), this.gl.uniform1f(this.lightShaderProgram.getUniform("uLightIntensity"), l.intensity), this.gl.uniform2f(this.lightShaderProgram.getUniform("uLightDir"), l.direction.x, l.direction.y), this.gl.uniform1f(this.lightShaderProgram.getUniform("uLightCutoff"), l.cutoff), this.gl.bindVertexArray(this.lightVao), this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4), this.gl.bindVertexArray(null);
      const h = o[n];
      h.count !== 0 && (this.shadowShaderProgram.use(), this.gl.uniform2f(this.shadowShaderProgram.getUniform("uViewportDimensions"), t.vw, t.vh), this.gl.uniform2fv(this.shadowShaderProgram.getUniform("uCameraPos"), t.position.toArray()), this.gl.uniform2fv(this.shadowShaderProgram.getUniform("uLightPos"), l.position.toArray()), this.gl.bindVertexArray(this.shadowsVao), this.gl.drawArrays(this.gl.TRIANGLES, h.offset, h.count), this.gl.bindVertexArray(null)), this.framebuffers[v + 1].unbind(), this.renderFullscreenPass({ shader: "blurHorizontal", inputs: [v + 1], output: 4 }), this.renderFullscreenPass({ shader: "blurVertical", inputs: [4], output: 5 }), this.renderFullscreenPass({ shader: "default_additive", inputs: [5], output: v });
    }
  }
  renderFullscreenPass(e) {
    const t = this.shaderMap.get(e.shader);
    if (!t)
      throw new Error("Unknown shader " + e.shader);
    e.clearColor && (this.gl.clearColor(this.clearColor.r, this.clearColor.g, this.clearColor.b, this.clearColor.a), this.gl.clear(this.gl.COLOR_BUFFER_BIT));
    const i = t.shader;
    let s = this.canvas.width, r = this.canvas.height;
    if (e.output !== -1) {
      const n = this.framebuffers[w.clamp(e.output, 0, y - 1)];
      s = n.width, r = n.height, n.bind();
    } else
      this.gl.viewport(0, 0, s, r);
    this.blend(t.blendMode), i.use();
    const o = [{ name: "time", value: this.time }, { name: "resolution", value: [s, r] }].concat(e.uniforms ?? []), a = t.builder.getUniforms();
    for (let n of a) {
      const l = o.find((h) => h.name === n.name);
      if (l) {
        const h = typeof l.value == "number" ? [l.value] : l.value, u = i.getUniform("uniforms." + n.name);
        switch (n.type) {
          case "float":
            this.gl.uniform1f(u, h[0]);
            break;
          case "vec2":
            this.gl.uniform2fv(u, h);
            break;
          case "vec3":
            this.gl.uniform3fv(u, h);
            break;
          case "vec4":
            this.gl.uniform4fv(u, h);
            break;
        }
      }
    }
    for (let n = 0; n < _; n++) {
      const l = e.inputs[n] ?? e.inputs[0], h = this.framebuffers[w.clamp(l, 0, y - 1)].texture;
      this.gl.activeTexture(this.gl.TEXTURE0 + n), this.gl.bindTexture(this.gl.TEXTURE_2D, h);
      const u = i.getUniform(`uChannel${n}`);
      this.gl.uniform1i(u, n);
    }
    this.gl.drawArrays(this.gl.TRIANGLES, 0, 3);
    for (let n = 0; n < _; n++)
      this.gl.activeTexture(this.gl.TEXTURE0 + n), this.gl.bindTexture(this.gl.TEXTURE_2D, null);
    e.output !== -1 && this.framebuffers[w.clamp(e.output, 0, y - 1)].unbind();
  }
  render(e, t) {
    if (!this.initialized)
      throw new Error("Renderer is not initialized");
    const i = t.getBounds();
    this.time = performance.now() * 1e-3;
    const s = [], r = [], o = [];
    for (const a of e.getLayersOrdered()) {
      let n;
      if (this.layersMap.has(a) || this.layersMap.set(a, new Ge(this.gl, this, a.isStatic)), n = this.layersMap.get(a), n.needsUpdate) {
        let l = a.getSpritesOrdered();
        n.isStatic || (l = l.filter((h) => B(i, h.getBounds()))), n.uploadSprites(a.getSpritesOrdered());
      }
      s.push(n), a.zIndex <= e.shadowsZIndex ? r.push(n) : o.push(n);
    }
    this.renderLights(e, t), this.renderScene(this.framebuffers[I], this.shaderProgram, t, this.clearColor, r), this.renderFullscreenPass({ shader: "light", inputs: [I, v], output: 0 }), this.renderScene(this.framebuffers[0], this.shaderProgram, t, null, o), this.renderScene(this.framebuffers[J], this.maskShaderProgram, t, te, s);
    for (let a = 0; a < this.pass.length; ++a) {
      const n = this.pass[a];
      this.renderFullscreenPass(n);
    }
    for (const [a, n] of this.layersMap)
      n.lifetime <= 0 && (this.layersMap.delete(a), n.destroy());
  }
  getTextureInfo(e) {
    const t = this.texturesMap.get(e);
    if (!t) throw new Error("Texture not found: " + e);
    return t;
  }
  getVBO() {
    return this.vbo;
  }
  createTexture(e) {
    const t = this.gl, i = t.createTexture();
    return t.bindTexture(t.TEXTURE_2D, i), t.texImage2D(t.TEXTURE_2D, 0, t.RGBA8, t.RGBA, t.UNSIGNED_BYTE, e), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.NEAREST), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.NEAREST), i;
  }
  createTextureArray(e, t) {
    const i = this.gl, s = i.createBuffer();
    i.bindBuffer(i.PIXEL_UNPACK_BUFFER, s), i.bufferData(i.PIXEL_UNPACK_BUFFER, t, i.STATIC_DRAW), i.pixelStorei(i.UNPACK_ROW_LENGTH, e.imageWidth), i.pixelStorei(i.UNPACK_IMAGE_HEIGHT, e.imageHeight);
    const r = i.createTexture();
    i.bindTexture(i.TEXTURE_2D_ARRAY, r), i.texStorage3D(i.TEXTURE_2D_ARRAY, 4, i.RGBA8, e.tileWidth, e.tileHeight, e.tileCount);
    for (let o = 0; o < e.tileCount; ++o) {
      const a = o % e.columns, n = Math.floor(o / e.columns);
      i.pixelStorei(i.UNPACK_SKIP_PIXELS, a * e.tileWidth), i.pixelStorei(i.UNPACK_SKIP_ROWS, n * e.tileHeight), i.texSubImage3D(i.TEXTURE_2D_ARRAY, 0, 0, 0, o, e.tileWidth, e.tileHeight, 1, i.RGBA, i.UNSIGNED_BYTE, 0);
    }
    return i.deleteBuffer(s), i.generateMipmap(i.TEXTURE_2D_ARRAY), i.texParameteri(i.TEXTURE_2D_ARRAY, i.TEXTURE_MAG_FILTER, i.NEAREST), i.texParameteri(i.TEXTURE_2D_ARRAY, i.TEXTURE_MIN_FILTER, i.NEAREST), r;
  }
}
class Ge {
  constructor(e, t, i) {
    this.gl = e, this.renderer = t, this.isStatic = i, this.needsUpdate = !0, this.drawCalls = [], this.lifetime = U, this.vao = e.createVertexArray(), e.bindVertexArray(this.vao), e.bindBuffer(e.ARRAY_BUFFER, t.getVBO()), e.enableVertexAttribArray(0), e.vertexAttribPointer(0, 2, e.FLOAT, !1, 16, 0), e.enableVertexAttribArray(1), e.vertexAttribPointer(1, 2, e.FLOAT, !1, 16, 8), this.instanceBuffer = e.createBuffer(), e.bindBuffer(e.ARRAY_BUFFER, this.instanceBuffer);
    const s = b.spriteStride;
    e.bufferData(e.ARRAY_BUFFER, (this.isStatic ? R : Z) * s, this.isStatic ? e.STATIC_DRAW : e.DYNAMIC_DRAW);
    for (let r = 2; r <= 8; ++r)
      e.enableVertexAttribArray(r), e.vertexAttribDivisor(r, 1);
    e.bindVertexArray(null);
  }
  uploadSprites(e) {
    const t = this.gl;
    t.bindBuffer(t.ARRAY_BUFFER, this.instanceBuffer), t.bufferSubData(t.ARRAY_BUFFER, 0, b.createSpritesData(e, !0)), this.isStatic && (this.needsUpdate = !1), this.drawCalls.length = 0;
    let i = null;
    for (let s = 0; s < e.length; ++s) {
      const r = e[s].tileset.name;
      !i || r !== i.texName ? (i = { texName: r, offset: s, count: 1 }, this.drawCalls.push(i)) : i.count++;
    }
  }
  render(e) {
    const t = this.gl;
    t.bindVertexArray(this.vao);
    for (const i of this.drawCalls) {
      const s = this.renderer.getTextureInfo(i.texName);
      t.bindTexture(t.TEXTURE_2D, s.texture), this.gl.uniform2f(e.getUniform("uTilesetDimensions"), s.tileset.imageWidth, s.tileset.imageHeight), t.bindBuffer(t.ARRAY_BUFFER, this.instanceBuffer);
      const r = b.spriteStride, o = i.offset * r;
      t.vertexAttribPointer(2, 2, t.FLOAT, !1, r, 0 + o), t.vertexAttribPointer(3, 2, t.FLOAT, !1, r, 8 + o), t.vertexAttribPointer(4, 1, t.FLOAT, !1, r, 16 + o), t.vertexAttribIPointer(5, 4, t.UNSIGNED_SHORT, r, 20 + o), t.vertexAttribPointer(6, 4, t.FLOAT, !1, r, 28 + o), t.vertexAttribPointer(7, 4, t.FLOAT, !1, r, 44 + o), t.vertexAttribPointer(8, 2, t.FLOAT, !1, r, 60 + o), t.drawArraysInstanced(t.TRIANGLE_STRIP, 0, 4, i.count);
    }
    t.bindVertexArray(null), this.lifetime = U;
  }
  destroy() {
    this.gl.deleteBuffer(this.instanceBuffer), this.gl.deleteVertexArray(this.vao);
  }
}
const Ne = async () => {
  const e = await (await navigator.gpu?.requestAdapter())?.requestDevice();
  if (!e) return null;
  const t = navigator.gpu.getPreferredCanvasFormat();
  return {
    device: e,
    format: t
  };
}, K = `
fn worldToClip(worldPos: vec2f, cameraPos: vec2f, viewport: vec2f) -> vec4f {
    let pixelPos = worldPos - cameraPos;
    let clipPos = vec2f(pixelPos.x / viewport.x, 1.0 - pixelPos.y / viewport.y) * 2.0 - 1.0;
    return vec4f(clipPos, 0.0, 1.0);
}
`, ue = `
struct VSInput {
    @location(0) vertexPos: vec2f,
    @location(1) texCoord: vec2f,
    
    @location(2) tilePos: vec2f,
    @location(3) tileScale: vec2f,
    @location(4) tileAngle: f32,
    @location(5) tileRegion: vec2u,

    @location(6) tintColor: vec4f,
    @location(7) maskColor: vec4f,

    @location(8) tileOffset: vec2f
}

struct Camera {
    pos: vec2f,
    viewportDimensions: vec2f
}

@group(0) @binding(0)
var<uniform> camera: Camera;

@group(1) @binding(2)
var<uniform> tilesetDimensions: vec2f;

struct VSOutput {
    @builtin(position) pos: vec4f,
    @location(0) uv: vec2f,
    @location(1) tintColor: vec4f,
    @location(2) maskColor: vec4f
}

${K}

@vertex
fn vs_main(input: VSInput) -> VSOutput {
    var out: VSOutput;

    out.tintColor = input.tintColor;
    out.maskColor = input.maskColor;

    let x = f32(input.tileRegion.x & 0xFFFFu);
    let y = f32(input.tileRegion.x >> 16);
    let w = f32(input.tileRegion.y & 0xFFFFu);
    let h = f32(input.tileRegion.y >> 16);

    let tileRegion = vec4f(x, y, w, h);

    let flippedTexCoord = vec2f(input.texCoord.x, 1.0 - input.texCoord.y);
    out.uv = (tileRegion.xy + flippedTexCoord * tileRegion.zw) / tilesetDimensions;

    let c = cos(input.tileAngle);
    let s = sin(input.tileAngle);
    let offsetPos = input.vertexPos * input.tileScale + input.tileOffset;
    let rotatedPos = vec2f(
        offsetPos.x * c - offsetPos.y * s,
        offsetPos.x * s + offsetPos.y * c
    );
    let worldPos = rotatedPos + input.tilePos;

    out.pos = worldToClip(worldPos, camera.pos, camera.viewportDimensions);
    return out;
}`, Xe = `

@group(1) @binding(0)
var spriteSampler: sampler;

@group(1) @binding(1)
var spriteTexture: texture_2d<f32>;

@fragment
fn fs_main(input: VSOutput) -> @location(0) vec4f {
    return textureSample(spriteTexture, spriteSampler, input.uv) * input.tintColor;
}
`, ze = `
@group(1) @binding(0)
var spriteSampler: sampler;

@group(1) @binding(1)
var spriteTexture: texture_2d<f32>;

@fragment
fn fs_main(input: VSOutput) -> @location(0) vec4f {
    let texColor: vec4f = textureSample(spriteTexture, spriteSampler, input.uv);
    return vec4f(input.maskColor.xyz, texColor.w * input.maskColor.a);
}
`, ke = ue + Xe, Ye = ue + ze, He = `
struct VSInput {
    @location(0) pos: vec2f
}

struct VSOutput {
    @builtin(position) pos: vec4f,
    @location(0) worldPos: vec2f
}

struct Camera {
    pos: vec2f,
    viewportDimensions: vec2f
}

struct Light {
    center: vec2f,
    radius: f32,
    color: vec3f,
    intensity: f32,
    direction: vec2f,
    cutoff: f32
}

@group(0) @binding(0)
var<uniform> camera: Camera;

@group(1) @binding(0)
var<uniform> light: Light;

${K}

@vertex
fn vs_main(input: VSInput) -> VSOutput {
    var out: VSOutput;

    out.worldPos = light.center + (input.pos - 0.5) * 2.0 * light.radius;

    out.pos = worldToClip(out.worldPos, camera.pos, camera.viewportDimensions);
    return out;
}

@fragment
fn fs_main(input: VSOutput) -> @location(0) vec4f {
    let toPixel = input.worldPos - light.center;
    let dist = length(toPixel);

    let attenuation = clamp(1.0 - pow(dist / light.radius, 2.0), 0.0, 1.0);

    var spotFactor = 1.0;
    if (light.cutoff > 0.0) {
        let cosAngle = dot(normalize(toPixel), normalize(light.direction));
        spotFactor = clamp((cosAngle - light.cutoff) / (1.0 - light.cutoff), 0.0, 1.0);
    }

    return vec4f(light.color * light.intensity * attenuation * spotFactor, 1.0);
}
`, We = `
struct VSInput {
    @location(0) pos: vec2f
}

struct VSOutput {
    @builtin(position) pos: vec4f
}

struct Camera {
    pos: vec2f,
    viewportDimensions: vec2f
}

@group(0) @binding(0)
var<uniform> camera: Camera;

${K}

@vertex
fn vs_main(input: VSInput) -> VSOutput {
    var out: VSOutput;

    out.pos = worldToClip(input.pos, camera.pos, camera.viewportDimensions);
    return out;
}

@fragment
fn fs_main(input: VSOutput) -> @location(0) vec4f {
    return vec4f(0.0, 0.0, 0.0, 1.0);
}
`, $e = (c) => `

struct VSOutput {
    @builtin(position) pos: vec4f,
    @location(0) uv: vec2f
}

@vertex
fn vs_main(@builtin(vertex_index) vertexIndex: u32) -> VSOutput {
    var out: VSOutput;

    let x = f32((vertexIndex & 1) << 2);
    let y = f32((vertexIndex & 2) << 1);

    out.uv = vec2f(x, 2.0 - y) / 2.0;
    out.pos = vec4f(x - 1.0, y - 1.0, 0.0, 1.0);
    return out;
}

struct Uniforms {
${c.uniforms.map((e) => "    " + e).join(`,
`)}
}

@group(0) @binding(0)
var<uniform> uniforms: Uniforms;

@group(1) @binding(0)
var defaultSampler: sampler;

@group(1) @binding(1)
var channel0: texture_2d<f32>;

@group(1) @binding(2)
var channel1: texture_2d<f32>;

@group(1) @binding(3)
var channel2: texture_2d<f32>;

@group(1) @binding(4)
var channel3: texture_2d<f32>;

@group(1) @binding(5)
var channel4: texture_2d<f32>;

@group(1) @binding(6)
var channel5: texture_2d<f32>;

@group(1) @binding(7)
var channel6: texture_2d<f32>;

@group(1) @binding(8)
var channel7: texture_2d<f32>;

fn texture(ch: i32, uv: vec2f) -> vec4f {
    let scaledUV = uv;

    switch (ch) {
        case 1:  { return textureSample(channel1, defaultSampler, scaledUV); }
        case 2:  { return textureSample(channel2, defaultSampler, scaledUV); }
        case 3:  { return textureSample(channel3, defaultSampler, scaledUV); }
        case 4:  { return textureSample(channel4, defaultSampler, scaledUV); }
        case 5:  { return textureSample(channel5, defaultSampler, scaledUV); }
        case 6:  { return textureSample(channel6, defaultSampler, scaledUV); }
        case 7:  { return textureSample(channel7, defaultSampler, scaledUV); }
        default: { return textureSample(channel0, defaultSampler, scaledUV); }
    }
}

fn mainImage(fragCoord: vec2f) -> vec4f {
    var fragColor: vec4f;
${c.mainImage.map((e) => "    " + e).join(`
`)}
    return fragColor;
}

@fragment
fn fs_main(input: VSOutput) -> @location(0) vec4f {
    let fragCoord = input.uv * uniforms.resolution;
    return mainImage(fragCoord);
}
`, qe = {
  componentMap: { r: "x", g: "y", b: "z", a: "w" },
  declareVar: (c, e, t = !1) => {
    const i = `${c}: ${e === "float" ? "f32" : e + "f"}`;
    return t ? i : `var ${i};`;
  }
};
class je {
  constructor(e) {
    this.shaderMap = /* @__PURE__ */ new Map(), this.layersMap = /* @__PURE__ */ new Map(), this.texturesMap = /* @__PURE__ */ new Map(), this.canvas = e, this.clearColor = new C(0, 0, 0, 0), this.shaderMap = /* @__PURE__ */ new Map(), this.initialized = !1, this.pass = [Q], this.offscreenTextures = [], this.time = 0, this.shaderCache = /* @__PURE__ */ new Map(), this.renderPassUniformMap = /* @__PURE__ */ new Map(), this.fullscreenPassStages = {
      mainLight: { shader: "light", inputs: [I, v], output: 0 },
      lightBlurHorizontal: { shader: "blurHorizontal", inputs: [v + 1], output: 4 },
      lightBlurVertical: { shader: "blurVertical", inputs: [4], output: 5 },
      lightAdditive: { shader: "default_additive", inputs: [5], output: v }
    };
  }
  getType() {
    return "webgpu";
  }
  getBuilderOptions() {
    return qe;
  }
  addTextures(e, t) {
    for (const i of e)
      t[i.name] && this.texturesMap.set(i.name, {
        tileset: i,
        image: t[i.name]
      });
  }
  addImageTextures(e) {
    for (let t of e) {
      const i = new E({
        name: t.name,
        tilecount: 1,
        columns: 1,
        tilewidth: t.width,
        tileheight: t.height,
        imagewidth: t.width,
        imageheight: t.height
      });
      this.texturesMap.set(t.name, {
        tileset: i,
        image: t.image
      });
    }
  }
  registerShader(e, t, i = "none") {
    this.shaderMap.set(e, { builder: t, blendMode: i });
  }
  setClearColor(e) {
    this.clearColor.copy(e);
  }
  setSize(e, t) {
    this.canvas.width = e, this.canvas.height = t, this.initialized && this.initOffscreenTextures(y);
  }
  getCanvas() {
    return this.canvas;
  }
  initOffscreenTextures(e) {
    for (let t = 0; t < e; ++t) {
      this.offscreenTextures[t]?.destroy();
      const i = ee(t);
      this.offscreenTextures[t] = this.cfg.device.createTexture({
        size: { width: this.canvas.width * i, height: this.canvas.height * i, depthOrArrayLayers: 1 },
        format: this.cfg.format,
        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING,
        label: "offscreen texture " + t
      });
    }
  }
  getBlendOptions(e) {
    switch (e) {
      case "alpha":
        return {
          color: {
            srcFactor: "src-alpha",
            dstFactor: "one-minus-src-alpha",
            operation: "add"
          },
          alpha: {
            srcFactor: "one",
            dstFactor: "one-minus-src-alpha",
            operation: "add"
          }
        };
      case "additive":
        return {
          color: {
            srcFactor: "one",
            dstFactor: "one",
            operation: "add"
          },
          alpha: {
            srcFactor: "zero",
            dstFactor: "one",
            operation: "add"
          }
        };
      default:
        return;
    }
  }
  async init() {
    const e = await Ne();
    if (!e) throw new Error("WebGPU not supported");
    this.cfg = e;
    const t = this.cfg.device, i = this.canvas.getContext("webgpu");
    this.ctx = i, this.ctx.configure(this.cfg);
    for (const n of this.texturesMap.values())
      n.tileset && (n.texture = this.createTexture(n.tileset, n.image));
    this.initOffscreenTextures(y), this.sampler = t.createSampler({
      magFilter: "nearest",
      minFilter: "nearest",
      addressModeU: "clamp-to-edge",
      addressModeV: "clamp-to-edge"
    }), this.fullscreenSampler = t.createSampler({
      magFilter: "linear",
      minFilter: "linear",
      addressModeU: "clamp-to-edge",
      addressModeV: "clamp-to-edge"
    }), this.registerShader("default", F), this.registerShader("default_additive", F, "additive"), this.registerShader("light", H), this.registerShader("blurHorizontal", W), this.registerShader("blurVertical", $);
    for (const [n, l] of this.shaderMap.entries()) {
      if (!this.shaderCache.has(l.builder)) {
        const d = $e(l.builder.build(this)), m = t.createShaderModule({
          label: n + " shader module",
          code: d
        });
        this.shaderCache.set(l.builder, m);
      }
      const h = this.shaderCache.get(l.builder), u = t.createRenderPipeline({
        layout: "auto",
        vertex: {
          module: h,
          entryPoint: "vs_main"
        },
        fragment: {
          module: h,
          entryPoint: "fs_main",
          targets: [{
            format: this.cfg.format,
            blend: this.getBlendOptions(l.blendMode)
          }]
        },
        primitive: { topology: "triangle-strip" }
      });
      l.pipeline = u;
    }
    this.commonBGL = this.cfg.device.createBindGroupLayout({
      entries: [
        { binding: 0, visibility: GPUShaderStage.FRAGMENT, sampler: {} },
        { binding: 1, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 2, visibility: GPUShaderStage.VERTEX, buffer: { type: "uniform" } }
      ]
    }), this.cameraBGL = this.cfg.device.createBindGroupLayout({
      entries: [
        { binding: 0, visibility: GPUShaderStage.VERTEX, buffer: { type: "uniform" } }
      ]
    }), this.lightBGL = this.cfg.device.createBindGroupLayout({
      entries: [
        { binding: 0, visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT, buffer: { type: "uniform", hasDynamicOffset: !0 } }
      ]
    }), this.pipeline = this.createMainPipeline(ke), this.maskPipeline = this.createMainPipeline(Ye), this.lightUniformBuffer = this.cfg.device.createBuffer({
      label: "Light uniform buffer",
      size: M * 256,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    const s = this.cfg.device.createPipelineLayout({
      bindGroupLayouts: [this.cameraBGL, this.lightBGL]
    }), r = this.cfg.device.createShaderModule({
      code: He
    });
    this.lightPipeline = this.cfg.device.createRenderPipeline({
      label: "Light pipeline",
      layout: s,
      vertex: {
        module: r,
        entryPoint: "vs_main",
        buffers: [
          {
            arrayStride: 16,
            attributes: [{ shaderLocation: 0, offset: 0, format: "float32x2" }]
          }
        ]
      },
      fragment: {
        module: r,
        entryPoint: "fs_main",
        targets: [{
          format: this.cfg.format
        }]
      },
      primitive: { topology: "triangle-strip" }
    }), this.lightUniformBindGroup = this.cfg.device.createBindGroup({
      label: "Light uniform bind group",
      layout: this.lightPipeline.getBindGroupLayout(1),
      entries: [{ binding: 0, resource: { buffer: this.lightUniformBuffer, size: b.lightStride } }]
    });
    const o = this.cfg.device.createPipelineLayout({
      bindGroupLayouts: [this.cameraBGL]
    }), a = this.cfg.device.createShaderModule({
      code: We
    });
    this.shadowPipeline = this.cfg.device.createRenderPipeline({
      label: "Shadow pipeline",
      layout: o,
      vertex: {
        module: a,
        entryPoint: "vs_main",
        buffers: [
          {
            arrayStride: 8,
            attributes: [{ shaderLocation: 0, offset: 0, format: "float32x2" }]
          }
        ]
      },
      fragment: {
        module: a,
        entryPoint: "fs_main",
        targets: [{ format: this.cfg.format }]
      }
    }), this.cameraBuffer = t.createBuffer({
      size: 16,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    }), this.cameraBindGroup = t.createBindGroup({
      label: "Camera bind group",
      layout: this.pipeline.getBindGroupLayout(0),
      entries: [{
        binding: 0,
        resource: { buffer: this.cameraBuffer }
      }]
    }), this.vbo = t.createBuffer({
      size: b.quad.byteLength,
      usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
    }), t.queue.writeBuffer(this.vbo, 0, b.quad), this.shadowsVbo = this.cfg.device.createBuffer({
      size: M * L * 8,
      usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
    }), this.initialized = !0;
  }
  createMainPipeline(e) {
    const t = this.cfg.device.createShaderModule({
      code: e
    }), i = this.cfg.device.createPipelineLayout({
      bindGroupLayouts: [this.cameraBGL, this.commonBGL]
    });
    return this.cfg.device.createRenderPipeline({
      layout: i,
      vertex: {
        module: t,
        entryPoint: "vs_main",
        buffers: [
          {
            arrayStride: 16,
            stepMode: "vertex",
            attributes: [
              { shaderLocation: 0, offset: 0, format: "float32x2" },
              { shaderLocation: 1, offset: 8, format: "float32x2" }
            ]
          },
          {
            arrayStride: b.spriteStride,
            stepMode: "instance",
            attributes: [
              { shaderLocation: 2, offset: 0, format: "float32x2" },
              { shaderLocation: 3, offset: 8, format: "float32x2" },
              { shaderLocation: 4, offset: 16, format: "float32" },
              { shaderLocation: 5, offset: 20, format: "uint32x2" },
              { shaderLocation: 6, offset: 28, format: "float32x4" },
              { shaderLocation: 7, offset: 44, format: "float32x4" },
              { shaderLocation: 8, offset: 60, format: "float32x2" }
            ]
          }
        ]
      },
      fragment: {
        module: t,
        entryPoint: "fs_main",
        targets: [
          {
            format: this.cfg.format,
            blend: this.getBlendOptions("alpha")
          }
        ]
      },
      primitive: { topology: "triangle-strip" }
    });
  }
  renderScene(e, t, i, s, r) {
    const o = e.beginRenderPass({
      colorAttachments: [{
        clearValue: s || void 0,
        view: i.createView(),
        loadOp: s ? "clear" : "load",
        storeOp: "store"
      }]
    });
    o.setPipeline(t), o.setBindGroup(0, this.cameraBindGroup), o.setVertexBuffer(0, this.vbo);
    for (const a of r)
      a.render(o);
    o.end();
  }
  renderLights(e, t, i) {
    const s = i.getBounds(), r = t.getLights().filter((m) => B(s, m.getBounds())), o = new Float32Array(r.length * L * 2), a = [];
    let n = 0;
    for (let m of r) {
      const f = t.getColliders(m.getBounds()), p = b.createShadowsGeometry(o, m, f, n);
      a.push({ count: (p - n) / 2, offset: n / 2 }), n = p;
    }
    this.cfg.device.queue.writeBuffer(this.shadowsVbo, 0, o, 0, n);
    const l = new C(
      t.ambientColor.r * t.ambientIntensity,
      t.ambientColor.g * t.ambientIntensity,
      t.ambientColor.b * t.ambientIntensity,
      1
    );
    e.beginRenderPass({
      colorAttachments: [{
        view: this.offscreenTextures[v].createView(),
        clearValue: l,
        loadOp: "clear",
        storeOp: "store"
      }]
    }).end();
    const u = b.createLightsGeometry(r, !0);
    this.cfg.device.queue.writeBuffer(this.lightUniformBuffer, 0, u);
    const d = this.offscreenTextures[v + 1].createView();
    for (let m = 0; m < r.length; ++m) {
      const f = e.beginRenderPass({
        colorAttachments: [{
          view: d,
          clearValue: new C(0, 0, 0, 1),
          loadOp: "clear",
          storeOp: "store"
        }]
      });
      f.setPipeline(this.lightPipeline), f.setVertexBuffer(0, this.vbo), f.setBindGroup(0, this.cameraBindGroup), f.setBindGroup(1, this.lightUniformBindGroup, [m * 256]), f.draw(4);
      const p = a[m];
      p.count !== 0 && (f.setPipeline(this.shadowPipeline), f.setVertexBuffer(0, this.shadowsVbo), f.setBindGroup(0, this.cameraBindGroup), f.draw(p.count, 1, p.offset)), f.end(), this.renderFullscreenPass(e, this.fullscreenPassStages.lightBlurHorizontal), this.renderFullscreenPass(e, this.fullscreenPassStages.lightBlurVertical), this.renderFullscreenPass(e, this.fullscreenPassStages.lightAdditive);
    }
  }
  renderFullscreenPass(e, t) {
    const i = this.shaderMap.get(t.shader);
    if (!i)
      throw new Error("Unknown shader " + t.shader);
    const s = t.output === -1 ? this.ctx.getCurrentTexture() : this.offscreenTextures[w.clamp(t.output, 0, y - 1)], r = i.builder.getUniforms(), o = [{ name: "time", value: this.time }, { name: "resolution", value: [s.width, s.height] }].concat(t.uniforms ?? []), a = new Float32Array(Je);
    for (let h of r) {
      const u = o.find((d) => d.name === h.name);
      if (u) {
        const d = typeof u.value == "number" ? [u.value] : u.value;
        a.set(d, h.offset);
      }
    }
    if (!this.renderPassUniformMap.has(t)) {
      const h = this.cfg.device.createBuffer({
        size: 256,
        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
      }), u = this.cfg.device.createBindGroup({
        layout: i.pipeline.getBindGroupLayout(0),
        entries: [{ binding: 0, resource: { buffer: h } }]
      }), d = [
        { binding: 0, resource: this.fullscreenSampler }
      ];
      for (let f = 0; f < _; f++) {
        const p = t.inputs[f] ?? t.inputs[0], g = this.offscreenTextures[w.clamp(p, 0, y - 1)];
        d.push({
          binding: f + 1,
          resource: g.createView()
        });
      }
      const m = this.cfg.device.createBindGroup({
        label: t.shader + " texture bind group",
        layout: i.pipeline.getBindGroupLayout(1),
        entries: d
      });
      this.renderPassUniformMap.set(t, { ubo: h, uniformBindGroup: u, textureBindGroup: m });
    }
    const n = this.renderPassUniformMap.get(t);
    this.cfg.device.queue.writeBuffer(n.ubo, 0, a);
    const l = e.beginRenderPass({
      colorAttachments: [{
        view: s.createView(),
        loadOp: t.clearColor ? "clear" : "load",
        clearValue: t.clearColor,
        storeOp: "store"
      }]
    });
    l.setPipeline(i.pipeline), l.setBindGroup(0, n.uniformBindGroup), l.setBindGroup(1, n.textureBindGroup), l.draw(3), l.end();
  }
  render(e, t) {
    if (!this.initialized)
      throw new Error("Renderer is not initialized");
    const i = t.getBounds();
    this.time = performance.now() * 1e-3;
    const s = [], r = [], o = [];
    for (const l of e.getLayersOrdered()) {
      if (!this.layersMap.has(l)) {
        const u = new Ke(this, l.isStatic);
        this.layersMap.set(l, u);
      }
      const h = this.layersMap.get(l);
      if (h.needsUpdate) {
        let u = l.getSpritesOrdered();
        h.isStatic || (u = u.filter((d) => B(i, d.getBounds()))), h.uploadSprites(u);
      }
      s.push(h), l.zIndex <= e.shadowsZIndex ? r.push(h) : o.push(h);
    }
    this.cfg.device.queue.writeBuffer(
      this.cameraBuffer,
      0,
      new Float32Array([
        t.position.x,
        t.position.y,
        t.vw,
        t.vh
      ])
    );
    const a = this.cfg.device.createCommandEncoder();
    this.renderLights(a, e, t), this.renderScene(a, this.pipeline, this.offscreenTextures[I], this.clearColor, r), this.renderFullscreenPass(a, this.fullscreenPassStages.mainLight), this.renderScene(a, this.pipeline, this.offscreenTextures[0], null, o), this.renderScene(a, this.maskPipeline, this.offscreenTextures[J], te, s);
    for (let l = 0; l < this.pass.length; ++l) {
      const h = this.pass[l];
      this.renderFullscreenPass(a, h);
    }
    const n = a.finish();
    this.cfg.device.queue.submit([n]);
    for (const [l, h] of this.layersMap)
      h.lifetime <= 0 && (h.destroy(), this.layersMap.delete(l));
  }
  createTexture(e, t) {
    const i = this.cfg.device.createTexture({
      size: {
        width: e.imageWidth,
        height: e.imageHeight,
        depthOrArrayLayers: 1
      },
      format: "rgba8unorm",
      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT
    });
    return this.cfg.device.queue.copyExternalImageToTexture, this.cfg.device.queue.copyExternalImageToTexture(
      { source: t },
      { texture: i },
      [e.imageWidth, e.imageHeight, 1]
    ), i;
  }
  createTextureArray(e, t) {
    const i = e.tileWidth, s = e.tileHeight, r = this.cfg.device.createTexture({
      size: {
        width: i,
        height: s,
        depthOrArrayLayers: e.tileCount
      },
      format: "rgba8unorm",
      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT
    });
    for (let o = 0; o < e.tileCount; ++o) {
      const a = Math.floor(o / e.columns), n = o % e.columns, l = new Uint8Array(i * s * 4);
      for (let h = 0; h < s; ++h) {
        const u = ((a * s + h) * e.columns + n) * i * 4, d = u + i * 4;
        l.set(t.slice(u, d), h * i * 4);
      }
      this.cfg.device.queue.writeTexture(
        {
          texture: r,
          origin: { x: 0, y: 0, z: o }
        },
        l,
        {
          bytesPerRow: i * 4,
          rowsPerImage: s
        },
        {
          width: i,
          height: s,
          depthOrArrayLayers: 1
        }
      );
    }
    return r;
  }
  getConfig() {
    return this.cfg;
  }
  getTextureInfo(e) {
    const t = this.texturesMap.get(e);
    if (!t) throw new Error("Texture not found: " + e);
    return t;
  }
  getPipeline() {
    return this.pipeline;
  }
  getSampler() {
    return this.sampler;
  }
}
class Ke {
  constructor(e, t) {
    this.renderer = e, this.isStatic = t, this.needsUpdate = !0, this.drawCalls = [], this.bindGroups = /* @__PURE__ */ new Map(), this.lifetime = U, this.lastTexIdx = 0, this.instanceBuffer = e.getConfig().device.createBuffer({
      label: "Instance Buffer",
      size: b.spriteStride * (t ? R : Z),
      usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
    }), this.tilesetDimBuffer = e.getConfig().device.createBuffer({
      label: "Tileset Dimensions Buffer",
      size: Ze * 256,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
  }
  uploadSprites(e) {
    const t = this.renderer.getConfig().device, i = this.renderer.getPipeline(), s = this.renderer.getSampler();
    t.queue.writeBuffer(this.instanceBuffer, 0, b.createSpritesData(e, !0)), this.isStatic && (this.needsUpdate = !1), this.drawCalls.length = 0;
    let r = null;
    for (let o = 0; o < e.length; ++o) {
      const a = e[o].tileset.name;
      if (!r || a !== r.texName) {
        const n = this.renderer.getTextureInfo(a);
        t.queue.writeBuffer(
          this.tilesetDimBuffer,
          this.lastTexIdx * 256,
          new Float32Array([n.tileset.imageWidth, n.tileset.imageHeight])
        );
        const l = t.createBindGroup({
          layout: i.getBindGroupLayout(1),
          entries: [
            { binding: 0, resource: s },
            { binding: 1, resource: n.texture.createView() },
            {
              binding: 2,
              resource: {
                buffer: this.tilesetDimBuffer,
                offset: this.lastTexIdx * 256,
                size: 8
              }
            }
          ]
        });
        r = {
          texName: a,
          instanceOffset: o,
          instanceCount: 1
        }, this.bindGroups.has(r.texName) || (this.bindGroups.set(r.texName, l), ++this.lastTexIdx), this.drawCalls.push(r);
      } else
        r.instanceCount++;
    }
  }
  render(e) {
    e.setVertexBuffer(1, this.instanceBuffer);
    for (const t of this.drawCalls)
      e.setBindGroup(1, this.bindGroups.get(t.texName)), e.draw(4, t.instanceCount, 0, t.instanceOffset);
    this.lifetime = U;
  }
  destroy() {
    this.instanceBuffer.destroy(), this.tilesetDimBuffer.destroy();
  }
}
const R = 1e5, Z = 5e4, U = 30, Ze = 16, y = 12, _ = 8, Je = 64, M = 1e3, L = 768, I = 3, J = 1, v = 1, Q = { shader: "default", inputs: [0], output: -1 }, ee = (c) => 1 / (1 << Math.max(0, Math.floor((c - 2) * 0.5))), te = new C(0, 0, 0, 1), gt = (c) => {
  const e = document.createElement("canvas");
  switch (c) {
    case "webgl":
      return new Ee(e);
    case "webgl2":
      return new Oe(e);
    case "webgpu":
      return new je(e);
    default:
      throw new Error("Unknown renderer type");
  }
};
class Qe {
  constructor(e) {
    this.prev = null, this.next = null, this.value = e;
  }
}
class et {
  constructor() {
    this.head = null;
  }
  insert(e) {
    const t = new Qe(e);
    return t.next = this.head, this.head = t, t;
  }
  remove(e) {
    e.next && (e.next.prev = e.prev), e.prev && (e.prev.next = e.next), this.head === e && (this.head = e.next), e.prev = null, e.next = null;
  }
  [Symbol.iterator]() {
    let e = this.head;
    return {
      next() {
        if (e) {
          const t = e.value;
          return e = e.next, { value: t, done: !1 };
        }
        return { value: void 0, done: !0 };
      }
    };
  }
}
class tt {
  constructor(e, t) {
    this.bounds = t, this.parent = e, this.queryId = 0;
  }
}
const G = class G {
  constructor(e) {
    this.bounds = e.bounds, this.dimensions = e.dimensions, this.cells = this.cells = Array.from(
      { length: e.dimensions[1] },
      () => Array.from(
        { length: e.dimensions[0] },
        () => new et()
      )
    );
  }
  findNearby(e) {
    const t = ++G.queryIds, i = this.getCellIndices(e.min), s = this.getCellIndices(e.max), r = [];
    for (let o = i[1]; o <= s[1]; ++o)
      for (let a = i[0]; a <= s[0]; ++a)
        for (let n of this.cells[o][a])
          n.queryId !== t && (n.queryId = t, r.push(n));
    return r;
  }
  createClient(e, t) {
    const i = new tt(e, t);
    return this.insert(i), i;
  }
  updateClient(e) {
    const t = this.getCellIndices(e.bounds.min), i = this.getCellIndices(e.bounds.max);
    t[0] === e.cells.min[0] && t[1] === e.cells.min[1] && i[0] === e.cells.max[0] && i[1] === e.cells.max[1] || (this.removeClient(e), this.insert(e));
  }
  removeClient(e) {
    for (let t = e.cells.min[1]; t <= e.cells.max[1]; ++t)
      for (let i = e.cells.min[0]; i <= e.cells.max[0]; ++i)
        this.cells[t][i].remove(e.cells.nodes[t - e.cells.min[1]][i - e.cells.min[0]]);
  }
  insert(e) {
    const t = this.getCellIndices(e.bounds.min), i = this.getCellIndices(e.bounds.max), s = [];
    for (let r = t[1]; r <= i[1]; ++r) {
      s.push([]);
      for (let o = t[0]; o <= i[0]; ++o) {
        const a = this.cells[r][o].insert(e);
        s[r - t[1]].push(a);
      }
    }
    e.cells = {
      min: t,
      max: i,
      nodes: s
    };
  }
  getCellIndices(e) {
    const t = w.clamp(Math.floor((e.x - this.bounds.min.x) / (this.bounds.max.x - this.bounds.min.x) * this.dimensions[0]), 0, this.dimensions[0] - 1), i = w.clamp(Math.floor((e.y - this.bounds.min.y) / (this.bounds.max.y - this.bounds.min.y) * this.dimensions[1]), 0, this.dimensions[1] - 1);
    return [t, i];
  }
};
G.queryIds = 0;
let Y = G;
class it {
  constructor(e) {
    this.zIndex = e.zIndex || 0, this.tileset = e.tileset, this.tilesetRegion = e.tilesetRegion, this.isStatic = e.isStatic || !1, this.position = new x(), this.offset = new x(), this.scale = new x(1, 1), this.angle = e.angle || 0, this.tintColor = new C(1, 1, 1, 1), this.maskColor = new C(0, 0, 0, 1);
  }
  setTilesetRegion(e, t, i = 1, s = 1) {
    this.tilesetRegion.x = e, this.tilesetRegion.y = t, this.tilesetRegion.width = i, this.tilesetRegion.height = s;
  }
  getTile() {
    return this.tileset.getTile(this.tilesetRegion.x, this.tilesetRegion.y);
  }
  getBounds() {
    const e = Math.max(Math.abs(this.scale.x), Math.abs(this.scale.y)), t = new x(e, e), i = this.position.clone().add(this.offset).sub(t), s = i.clone().add(t).add(t);
    return {
      min: i,
      max: s
    };
  }
}
class mt {
  constructor(e = {}) {
    this.layers = [], this.ambientIntensity = e.ambientIntensity || 1, this.ambientColor = e.ambientColor || new C(1, 1, 1), this.lights = [], this.colliders = [], this.shadowsZIndex = e.shadowsZIndex || 0, this.collidersHashGrid = new Y(e.spatialHashGridParams || {
      bounds: { min: new x(-1e3, -1e3), max: new x(1e3, 1e3) },
      dimensions: [20, 20]
    });
  }
  findLayerBySprite(e) {
    return this.layers.find((t) => t.isStatic === e.isStatic && t.zIndex === e.zIndex);
  }
  addLight(e) {
    this.lights.push(e);
  }
  removeLight(e) {
    const t = this.lights.indexOf(e);
    t !== -1 && this.lights.splice(t, 1);
  }
  addSprite(e) {
    let t;
    return t = this.findLayerBySprite(e), t || (t = this.createLayer({
      zIndex: e.zIndex,
      isStatic: e.isStatic
    })), t.add(e), e;
  }
  removeSprite(e) {
    const t = this.findLayerBySprite(e);
    t && t.remove(e);
  }
  addTilemap(e, t = {}) {
    const i = e.getLayers();
    let s = 0;
    const r = [], o = [];
    for (const a of i) {
      const n = t.layers?.find((l) => l.name === a.name);
      switch (n?.zIndex && (s = n.zIndex), a.renderOrder !== "manual" && this.createLayer({
        zIndex: s,
        renderOrder: a.renderOrder,
        isStatic: !1
      }), a.type) {
        case "tilelayer": {
          for (let l = 0; l < a.height; ++l)
            for (let h = 0; h < a.width; ++h) {
              const u = a.getTile(h, l);
              if (!u) continue;
              const d = new it({
                isStatic: u.animation === void 0,
                zIndex: s,
                tileset: u.tileset,
                tilesetRegion: { x: u.x, y: u.y }
              });
              if (d.position.set((h + a.x) * e.tileWidth, (l + a.y) * e.tileHeight), d.scale.set(e.tileWidth, e.tileHeight), r.push(this.addSprite(d)), u.animation) {
                const m = new ge(d);
                m.play({ x: u.x, y: u.y }, { repeat: !0 }), o.push(m);
              }
            }
          break;
        }
        case "objectgroup": {
          if (t.onObject) {
            const l = a.getObjects();
            for (const h of l)
              t.onObject(this, h, a, s);
          }
          break;
        }
      }
      ++s;
    }
    return {
      sprites: r,
      animators: o
    };
  }
  createLayer(e) {
    const t = new rt(e);
    return this.layers.push(t), t;
  }
  getLayersOrdered() {
    return this.layers.sort((e, t) => e.zIndex - t.zIndex);
  }
  getLights() {
    return this.lights;
  }
  addCollider(e) {
    return this.colliders.push({
      collider: e,
      hashGridClient: this.collidersHashGrid.createClient(e, e.getBounds())
    }), e;
  }
  removeCollider(e) {
    const t = this.colliders.findIndex((i) => i.collider === e);
    t !== -1 && (this.collidersHashGrid.removeClient(this.colliders[t].hashGridClient), this.colliders.splice(t, 1));
  }
  getColliders(e) {
    return this.collidersHashGrid.findNearby(e).map((t) => t.parent);
  }
  update() {
    for (let e of this.colliders)
      e.hashGridClient.bounds = e.collider.getBounds(), this.collidersHashGrid.updateClient(e.hashGridClient);
  }
  getInfo() {
    return {
      lights: this.lights.length,
      colliders: this.colliders.length,
      sprites: this.layers.reduce((e, t) => e + t.sprites.length, 0),
      staticSprites: this.layers.reduce((e, t) => e + t.sprites.filter((i) => i.isStatic).length, 0),
      layers: this.layers.length
    };
  }
}
class rt {
  constructor(e) {
    this.zIndex = e.zIndex, this.isStatic = e.isStatic, this.renderOrder = e.renderOrder || "manual", this.sprites = [];
  }
  add(e) {
    if (this.renderOrder === "manual") {
      let t = -1;
      for (let i = this.sprites.length - 1; i >= 0; --i)
        if (this.sprites[i].tileset.name <= e.tileset.name) {
          t = i;
          break;
        }
      t === -1 ? this.sprites.unshift(e) : this.sprites.splice(t + 1, 0, e);
    } else
      this.sprites.push(e);
  }
  remove(e) {
    const t = this.sprites.indexOf(e);
    t !== -1 && this.sprites.splice(t, 1);
  }
  getSpritesOrdered() {
    switch (this.renderOrder) {
      case "topdown":
        return this.sprites.sort((e, t) => e.position.y - t.position.y);
      default:
        return this.sprites;
    }
  }
}
class ce {
  constructor(e) {
    this.name = e.name, this.x = e.x, this.y = e.y, this.width = e.width, this.height = e.height, this.type = e.type, this.renderOrder = e.draworder || "manual";
  }
}
class st extends ce {
  constructor(e) {
    super(e), this.data = e.data;
  }
  getTile(e, t) {
    const i = this.data[t * this.width + e];
    return i - 1 == -1 ? null : this.tilemap.getTileById(i);
  }
}
class ot {
  constructor(e, t, i, s, r, o) {
    this.name = e, this.type = t, this.x = i, this.y = s, this.rotation = r || 0, this.properties = o;
  }
  getProperty(e) {
    return this.properties?.find((t) => t.name === e)?.value;
  }
}
class nt extends ce {
  constructor(e) {
    super(e), this.objects = e.objects;
  }
  getObjects() {
    return this.objects.map((e) => new ot(e.name, e.type, e.x, e.y, e.rotation, e.properties));
  }
}
class fe {
  constructor(e, t, i, s) {
    this.width = e, this.height = t, this.tileWidth = i, this.tileHeight = s, this.tilesets = [], this.layers = [];
  }
  static async load(e, t) {
    const i = await ne.loadJson(e), s = new fe(i.width, i.height, i.tilewidth, i.tileheight);
    for (const r of i.layers)
      switch (r.type) {
        case "tilelayer":
          s.addLayer(new st(r));
          break;
        case "objectgroup":
          s.addLayer(new nt(r));
          break;
      }
    for (let r of i.tilesets) {
      let o;
      if (r.source) {
        const a = r.source.split(/(\/|\\\/)/), n = a[a.length - 1].split(".tsj")[0];
        if (!t[n]) throw new Error("Source is missing for tileset: " + n);
        o = await E.load(t[n]);
      } else
        o = new E(r);
      s.tilesets.push({ tileset: o, firstGlobalId: r.firstgid });
    }
    return s;
  }
  addLayer(e) {
    e.tilemap = this, this.layers.push(e);
  }
  getTilesets() {
    return this.tilesets.map((e) => e.tileset);
  }
  getTilesetByName(e) {
    return this.tilesets.find((t) => t.tileset.name === e)?.tileset || null;
  }
  getLayers() {
    return this.layers;
  }
  getLayerByName(e) {
    return this.layers.find((t) => t.name === e) || null;
  }
  getTileById(e) {
    const t = this.tilesets;
    for (let i of t) {
      let s = i.tileset.getTileById(e - i.firstGlobalId);
      if (s)
        return s;
    }
    return null;
  }
}
export {
  ge as Animator,
  ht as Camera,
  C as Color,
  ct as Light,
  at as LinearSpline,
  lt as LinearSplineVector,
  mt as Scene,
  N as ShaderBuilder,
  it as Sprite,
  fe as Tilemap,
  E as Tileset,
  x as Vector,
  ne as assets,
  ut as colliders,
  gt as createRenderer,
  w as math,
  ft as matrix
};
