class L {
  constructor(e) {
    this.repeat = !0, this.currentFrameIndex = 0, this.frameTimer = 0, this.sprite = e, this.animation = null;
  }
  play(e, t = {}) {
    const s = this.sprite.tileset.getTile(e.x, e.y);
    if (!s) return;
    const i = s.animation || [{ tileid: s.id, duration: 100 }];
    if (!t.restart && this.animation === i)
      return;
    this.animation = i, this.repeat = t.repeat ?? !0, this.currentFrameIndex = 0, this.frameTimer = 0;
    const r = this.animation[0], a = this.sprite.tileset.getTileXY(r.tileid);
    this.sprite.setTilesetRegion(a.x, a.y);
  }
  update(e) {
    if (!this.animation) return;
    const t = this.animation[this.currentFrameIndex];
    if (this.frameTimer += e * 1e3, this.frameTimer < t.duration) return;
    if (this.frameTimer -= t.duration, this.currentFrameIndex++, this.currentFrameIndex >= this.animation.length)
      if (this.repeat)
        this.currentFrameIndex = 0;
      else {
        this.currentFrameIndex = this.animation.length - 1, this.animation = null;
        return;
      }
    const s = this.animation[this.currentFrameIndex], i = this.sprite.tileset.getTileXY(s.tileid);
    this.sprite.setTilesetRegion(i.x, i.y);
  }
}
const S = {
  loadImage: (t) => new Promise((s, i) => {
    const r = new Image();
    r.crossOrigin = "anonymous", r.src = t, r.onload = () => {
      s(r);
    }, r.onerror = () => {
      i();
    };
  }),
  loadJson: async (t) => {
    try {
      return await (await fetch(t)).json();
    } catch {
      throw new Error(`Failed to load: ${t}`);
    }
  }
}, T = {
  create: () => new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
  identity: (r) => (r[0] = 1, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = 1, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[10] = 1, r[11] = 0, r[12] = 0, r[13] = 0, r[14] = 0, r[15] = 1, r),
  createOrtho: (r, a, n, h, o) => (r[0] = 2 / (n - a), r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = 2 / (o - h), r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[10] = 1, r[11] = 0, r[12] = -(n + a) / (n - a), r[13] = -(o + h) / (o - h), r[14] = 0, r[15] = 1, r),
  translate: (r, a) => (r[12] += a.x, r[13] += a.y, r),
  scale: (r, a) => (r[0] *= a.x, r[1] *= a.x, r[4] *= a.y, r[5] *= a.y, r)
}, P = /* @__PURE__ */ (() => {
  const l = (i, r, a) => Math.min(Math.max(i, r), a);
  return {
    clamp: l,
    lerp: (i, r, a) => i + (r - i) * a,
    unlerp: (i, r, a) => l((a - i) / (r - i), 0, 1),
    sat: (i) => l(i, 0, 1)
  };
})();
class Q {
  constructor(e = []) {
    this.points = e;
  }
  addPoint(e) {
    this.points.push(e);
  }
  getValue(e) {
    const t = this.points.length;
    if (t === 0) return 0;
    if (e <= 0) return this.points[0];
    if (e >= t - 1) return this.points[t - 1];
    const s = Math.floor(e), i = e - s;
    return P.lerp(this.points[s], this.points[s + 1], i);
  }
}
class d {
  constructor(e = 0, t = 0) {
    this.x = e, this.y = t;
  }
  set(e, t) {
    return this.x = e, this.y = t, this;
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this;
  }
  clone() {
    return new d(this.x, this.y);
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }
  scale(e) {
    return this.x *= e, this.y *= e, this;
  }
  mul(e) {
    return this.x *= e.x, this.y *= e.y, this;
  }
  div(e) {
    return e !== 0 ? (this.x /= e, this.y /= e) : (this.x = 0, this.y = 0), this;
  }
  static dot(e, t) {
    return e.x * t.x + e.y * t.y;
  }
  static cross(e, t) {
    return e.x * t.y - e.y * t.x;
  }
  len() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  lenSq() {
    return this.x * this.x + this.y * this.y;
  }
  unit() {
    const e = this.len();
    return e > 0 && this.div(e), this;
  }
  project(e) {
    const t = e.lenSq();
    if (t > 0) return this.scale(0);
    const s = d.dot(this, e);
    return this.copy(e).scale(s / t);
  }
  static distance(e, t) {
    const s = e.x - t.x, i = e.y - t.y;
    return Math.sqrt(s * s + i * i);
  }
  angle() {
    return Math.atan2(this.y, this.x);
  }
  rot(e) {
    const t = Math.cos(e), s = Math.sin(e), i = this.x * t - this.y * s, r = this.x * s + this.y * t;
    return this.x = i, this.y = r, this;
  }
  fromAngle(e, t = 1) {
    return this.x = Math.cos(e) * t, this.y = Math.sin(e) * t, this;
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this;
  }
  toString() {
    return `Vector(${this.x}, ${this.y})`;
  }
  toArray() {
    return new Float32Array([this.x, this.y]);
  }
}
class Z {
  constructor(e = []) {
    this.points = e.slice().sort((t, s) => t.x - s.x);
  }
  addPoint(e) {
    this.points.push(e), this.points.sort((t, s) => t.x - s.x);
  }
  getValue(e) {
    const t = this.points.length;
    if (t === 0) return new d();
    if (e <= this.points[0].x) return this.points[0].clone();
    if (e >= this.points[t - 1].x) return this.points[t - 1].clone();
    for (let s = 0; s < t - 1; s++) {
      const i = this.points[s], r = this.points[s + 1];
      if (e >= i.x && e <= r.x) {
        const a = P.unlerp(i.x, r.x, e);
        return i.clone().lerp(r, a);
      }
    }
    return new d();
  }
}
class ee {
  constructor(e, t) {
    this.projectionMatrix = T.create(), this.viewMatrix = T.create(), this.position = new d(), this.zoom = 1, this.vw = 0, this.vh = 0, this.updateProjection(e, t);
  }
  updateProjection(e, t) {
    this.vw = e, this.vh = t;
  }
  update() {
    T.identity(this.viewMatrix), T.translate(this.viewMatrix, new d(-this.position.x, -this.position.y));
    const e = this.vw * 0.5 / this.zoom, t = this.vh * 0.5 / this.zoom;
    T.createOrtho(this.projectionMatrix, -e, e, -t, t);
  }
}
class A {
  constructor(e, t, s, i = 1) {
    this.r = e, this.g = t, this.b = s, this.a = i;
  }
  copy(e) {
    this.r = e.r, this.g = e.g, this.b = e.b, this.a = e.a;
  }
}
const p = {
  quad: new Float32Array([
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    0,
    1,
    0,
    1,
    1
  ]),
  createSpritesData: (t, s = !1) => {
    const i = s ? 1 : 4, r = 24, a = new ArrayBuffer(t.length * i * r), n = new DataView(a);
    let h = 0;
    for (const o of t) {
      const u = o.position.x + o.offset.x, c = o.position.y + o.offset.y, g = o.scale.x, x = o.scale.y, B = o.tilesetRegion.x * (o.tileset.tileWidth + o.tileset.spacing) + o.tileset.margin, I = o.tilesetRegion.y * (o.tileset.tileHeight + o.tileset.spacing) + o.tileset.margin, F = o.tileset.tileWidth + ((o.tilesetRegion.width || 1) - 1) * (o.tileset.tileWidth + o.tileset.spacing), D = o.tileset.tileHeight + ((o.tilesetRegion.height || 1) - 1) * (o.tileset.tileHeight + o.tileset.spacing);
      for (let w = 0; w < i; ++w)
        n.setFloat32(h, u, !0), n.setFloat32(h + 4, c, !0), n.setFloat32(h + 8, g, !0), n.setFloat32(h + 12, x, !0), n.setUint16(h + 16, B, !0), n.setUint16(h + 18, I, !0), n.setUint16(h + 20, F, !0), n.setUint16(h + 22, D, !0), h += r;
    }
    return a;
  }
};
class C {
  constructor(e, t, s) {
    this.gl = e, this.uniforms = /* @__PURE__ */ new Map();
    const i = this.compileShader(e.VERTEX_SHADER, t), r = this.compileShader(e.FRAGMENT_SHADER, s);
    if (this.program = e.createProgram(), e.attachShader(this.program, i), e.attachShader(this.program, r), e.linkProgram(this.program), !e.getProgramParameter(this.program, e.LINK_STATUS))
      throw new Error(e.getProgramInfoLog(this.program) ?? "Could not link program");
    e.deleteShader(i), e.deleteShader(r);
  }
  compileShader(e, t) {
    const s = this.gl.createShader(e);
    if (!s) throw new Error("Could not create shader");
    if (this.gl.shaderSource(s, t), this.gl.compileShader(s), !this.gl.getShaderParameter(s, this.gl.COMPILE_STATUS))
      throw new Error(this.gl.getShaderInfoLog(s) ?? "Could not compile shader");
    return s;
  }
  use() {
    this.gl.useProgram(this.program);
  }
  getUniform(e) {
    if (!this.uniforms.has(e)) {
      const t = this.gl.getUniformLocation(this.program, e);
      t || console.log("Could not get uniform location:", e), this.uniforms.set(e, t);
    }
    return this.uniforms.get(e);
  }
  getAttrib(e) {
    return this.gl.getAttribLocation(this.program, e);
  }
}
const M = `

attribute vec2 aVertexPos;
attribute vec2 aTexCoord;
attribute vec2 aTilePos;
attribute vec2 aTileScale;
attribute vec4 aTileRegion;

uniform vec2 uViewportDimensions;
uniform vec2 uCameraPos;

uniform vec2 uTilesetDimensions;

varying vec2 uv;

void main() {
    vec2 flippedTexCoord = vec2(aTexCoord.x, 1.0 - aTexCoord.y);
    uv = (vec2(aTileRegion.xy) + flippedTexCoord * vec2(aTileRegion.zw)) / uTilesetDimensions;

    vec2 worldPos = aVertexPos * aTileScale + aTilePos;
    vec2 pixelPos = worldPos - uCameraPos;
    vec2 clipPos = vec2(pixelPos.x / uViewportDimensions.x, 1.0 - pixelPos.y / uViewportDimensions.y) * 2.0 - 1.0;
    gl_Position = vec4(clipPos, 0.0, 1.0);
}
`, O = `

precision mediump float;

varying vec2 uv;

uniform sampler2D uSampler;  

void main() {
    gl_FragColor = texture2D(uSampler, uv);
}
`;
class N {
  constructor(e) {
    this.canvas = e, this.layersMap = /* @__PURE__ */ new Map(), this.texturesMap = /* @__PURE__ */ new Map(), this.clearColor = new A(0, 0, 0, 0), this.texturesInfo = [];
  }
  addTextures(e, t) {
    for (const s of e)
      t[s.name] && this.texturesInfo.push({
        tileset: s,
        image: t[s.name]
      });
  }
  setClearColor(e) {
    this.clearColor.copy(e);
  }
  setSize(e, t) {
    this.canvas.width = e, this.canvas.height = t;
  }
  getCanvas() {
    return this.canvas;
  }
  async init() {
    const e = this.canvas.getContext("webgl");
    if (!e) throw new Error("WebGL not supported");
    this.gl = e;
    for (const r of this.texturesInfo)
      r.tileset && this.createTexture(r.tileset, r.tileset.name, r.image);
    this.shaderProgram = new C(e, M, O), this.attribLocations = {
      vertexPos: this.shaderProgram.getAttrib("aVertexPos"),
      texCoord: this.shaderProgram.getAttrib("aTexCoord"),
      tilePos: this.shaderProgram.getAttrib("aTilePos"),
      tileScale: this.shaderProgram.getAttrib("aTileScale"),
      tileRegion: this.shaderProgram.getAttrib("aTileRegion")
    }, this.vbo = e.createBuffer(), e.bindBuffer(e.ARRAY_BUFFER, this.vbo);
    const t = new Float32Array(f * 4 * 4);
    for (let r = 0; r < f; ++r)
      t.set(p.quad, r * 4 * 4);
    e.bufferData(e.ARRAY_BUFFER, t, e.STATIC_DRAW);
    const s = [0, 1, 2, 1, 2, 3];
    this.ebo = e.createBuffer(), e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this.ebo);
    const i = new Uint16Array(f * 6);
    for (let r = 0; r < f; ++r)
      for (let a = 0; a < 6; ++a)
        i[r * 6 + a] = s[a] + 4 * r;
    e.bufferData(e.ELEMENT_ARRAY_BUFFER, i, e.STATIC_DRAW), e.enable(e.BLEND), e.blendFunc(e.SRC_ALPHA, e.ONE_MINUS_SRC_ALPHA);
  }
  render(e, t) {
    const s = [];
    for (const i of e.getLayersOrdered()) {
      if (!this.layersMap.has(i)) {
        const a = new G(this.gl, this, i.isStatic);
        this.layersMap.set(i, a);
      }
      const r = this.layersMap.get(i);
      r.needsUpdate && r.upload(i.getSpritesOrdered()), s.push(r);
    }
    this.gl.viewport(0, 0, t.vw, t.vh), this.gl.clearColor(this.clearColor.r, this.clearColor.g, this.clearColor.b, this.clearColor.a), this.gl.clear(this.gl.COLOR_BUFFER_BIT), this.shaderProgram.use(), this.gl.uniform2f(this.shaderProgram.getUniform("uViewportDimensions"), t.vw, t.vh), this.gl.uniform2f(this.shaderProgram.getUniform("uCameraPos"), t.position.x, t.position.y);
    for (let i of s)
      i.render();
    for (const [i, r] of this.layersMap)
      r.lifetime <= 0 && (this.layersMap.delete(i), r.destroy());
  }
  getTextureInfo(e) {
    const t = this.texturesMap.get(e);
    if (!t) throw new Error("Texture not found: " + e);
    return t;
  }
  getVBO() {
    return this.vbo;
  }
  getEBO() {
    return this.ebo;
  }
  getShaderProgram() {
    return this.shaderProgram;
  }
  getAttribLocations() {
    return this.attribLocations;
  }
  createTexture(e, t, s) {
    const i = this.gl, r = i.createTexture();
    i.bindTexture(i.TEXTURE_2D, r), i.texImage2D(i.TEXTURE_2D, 0, i.RGBA, i.RGBA, i.UNSIGNED_BYTE, s), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_S, i.CLAMP_TO_EDGE), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_T, i.CLAMP_TO_EDGE), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, i.NEAREST), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MAG_FILTER, i.NEAREST), this.texturesMap.set(t, { texture: r, tileset: e });
  }
}
let G = class {
  constructor(e, t, s) {
    this.gl = e, this.renderer = t, this.isStatic = s, this.needsUpdate = !0, this.drawCalls = [], this.lifetime = m, this.spriteBuffer = e.createBuffer(), e.bindBuffer(e.ARRAY_BUFFER, this.spriteBuffer), e.bufferData(e.ARRAY_BUFFER, (this.isStatic ? f : E) * 5 * 4 * 4, this.isStatic ? e.STATIC_DRAW : e.DYNAMIC_DRAW);
  }
  upload(e) {
    const t = this.gl;
    t.bindBuffer(t.ARRAY_BUFFER, this.spriteBuffer), t.bufferSubData(t.ARRAY_BUFFER, 0, p.createSpritesData(e)), this.isStatic && (this.needsUpdate = !1), this.drawCalls.length = 0;
    let s = null;
    for (let i = 0; i < e.length; ++i) {
      const r = e[i].tileset.name;
      !s || r !== s.texName ? (s = { texName: r, spriteOffset: i, spriteCount: 1 }, this.drawCalls.push(s)) : s.spriteCount++;
    }
  }
  render() {
    const e = this.gl, t = this.renderer.getAttribLocations();
    e.bindBuffer(e.ARRAY_BUFFER, this.renderer.getVBO()), e.enableVertexAttribArray(t.vertexPos), e.vertexAttribPointer(t.vertexPos, 2, e.FLOAT, !1, 16, 0), e.enableVertexAttribArray(t.texCoord), e.vertexAttribPointer(t.texCoord, 2, e.FLOAT, !1, 16, 8), e.bindBuffer(e.ARRAY_BUFFER, this.spriteBuffer), e.enableVertexAttribArray(t.tilePos), e.vertexAttribPointer(t.tilePos, 2, e.FLOAT, !1, 24, 0), e.enableVertexAttribArray(t.tileScale), e.vertexAttribPointer(t.tileScale, 2, e.FLOAT, !1, 24, 8), e.enableVertexAttribArray(t.tileRegion), e.vertexAttribPointer(t.tileRegion, 4, e.UNSIGNED_SHORT, !1, 24, 16), e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this.renderer.getEBO());
    for (const s of this.drawCalls) {
      const i = this.renderer.getTextureInfo(s.texName);
      e.bindTexture(e.TEXTURE_2D, i.texture), this.gl.uniform2f(this.renderer.getShaderProgram().getUniform("uTilesetDimensions"), i.tileset.imageWidth, i.tileset.imageHeight), e.drawElements(e.TRIANGLES, 6 * s.spriteCount, e.UNSIGNED_SHORT, s.spriteOffset * 6 * 2);
    }
    this.lifetime = m;
  }
  destroy() {
    this.gl.deleteBuffer(this.spriteBuffer);
  }
};
const V = `#version 300 es

layout(location = 0) in vec2 aVertexPos;
layout(location = 1) in vec2 aTexCoord;

layout(location = 2) in vec2 aTilePos;
layout(location = 3) in vec2 aTileScale;
layout(location = 4) in uvec4 aTileRegion;

uniform vec2 uViewportDimensions;
uniform vec2 uCameraPos;

uniform vec2 uTilesetDimensions;

out vec2 uv;

void main() {
    vec2 flippedTexCoord = vec2(aTexCoord.x, 1.0 - aTexCoord.y);
    uv = (vec2(aTileRegion.xy) + flippedTexCoord * vec2(aTileRegion.zw)) / uTilesetDimensions;

    vec2 worldPos = aVertexPos * aTileScale + aTilePos;
    vec2 pixelPos = worldPos - uCameraPos;
    vec2 clipPos = vec2(pixelPos.x / uViewportDimensions.x, 1.0 - pixelPos.y / uViewportDimensions.y) * 2.0 - 1.0;
    gl_Position = vec4(clipPos, 0.0, 1.0);
}
`, Y = `#version 300 es

precision mediump float;

in vec2 uv;

uniform mediump sampler2D uSampler;  

out vec4 fragColor;

void main() {
    fragColor = texture(uSampler, uv);
}
`;
class X {
  constructor(e) {
    this.canvas = e, this.layersMap = /* @__PURE__ */ new Map(), this.texturesMap = /* @__PURE__ */ new Map(), this.clearColor = new A(0, 0, 0, 0), this.texturesInfo = [];
  }
  addTextures(e, t) {
    for (const s of e)
      t[s.name] && this.texturesInfo.push({
        tileset: s,
        image: t[s.name]
      });
  }
  setClearColor(e) {
    this.clearColor.copy(e);
  }
  setSize(e, t) {
    this.canvas.width = e, this.canvas.height = t;
  }
  getCanvas() {
    return this.canvas;
  }
  async init() {
    const e = this.canvas.getContext("webgl2");
    if (!e) throw new Error("WebGL2 not supported");
    this.gl = e;
    for (const r of this.texturesInfo)
      r.tileset && this.createTexture(r.tileset, r.tileset.name, r.image);
    this.shaderProgram = new C(e, V, Y), this.vbo = e.createBuffer(), e.bindBuffer(e.ARRAY_BUFFER, this.vbo);
    const t = new Float32Array(f * 4 * 4);
    for (let r = 0; r < f; ++r)
      t.set(p.quad, r * 4 * 4);
    e.bufferData(e.ARRAY_BUFFER, t, e.STATIC_DRAW);
    const s = [0, 1, 2, 1, 2, 3];
    this.ebo = e.createBuffer(), e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this.ebo);
    const i = new Uint32Array(f * 6);
    for (let r = 0; r < f; ++r)
      for (let a = 0; a < 6; ++a)
        i[r * 6 + a] = s[a] + 4 * r;
    e.bufferData(e.ELEMENT_ARRAY_BUFFER, i, e.STATIC_DRAW), e.enable(e.BLEND), e.blendFunc(e.SRC_ALPHA, e.ONE_MINUS_SRC_ALPHA);
  }
  render(e, t) {
    const s = [];
    for (const i of e.getLayersOrdered()) {
      if (!this.layersMap.has(i)) {
        const a = new W(this.gl, this, i.isStatic);
        this.layersMap.set(i, a);
      }
      const r = this.layersMap.get(i);
      r.needsUpdate && r.upload(i.getSpritesOrdered()), s.push(r);
    }
    this.gl.viewport(0, 0, this.canvas.width, this.canvas.height), this.gl.clearColor(this.clearColor.r, this.clearColor.g, this.clearColor.b, this.clearColor.a), this.gl.clear(this.gl.COLOR_BUFFER_BIT), this.shaderProgram.use(), this.gl.uniform2f(this.shaderProgram.getUniform("uViewportDimensions"), t.vw, t.vh), this.gl.uniform2f(this.shaderProgram.getUniform("uCameraPos"), t.position.x, t.position.y);
    for (let i of s)
      i.render();
    for (const [i, r] of this.layersMap)
      r.lifetime <= 0 && (this.layersMap.delete(i), r.destroy());
  }
  getTextureInfo(e) {
    const t = this.texturesMap.get(e);
    if (!t) throw new Error("Texture not found: " + e);
    return t;
  }
  getVBO() {
    return this.vbo;
  }
  getEBO() {
    return this.ebo;
  }
  getShaderProgram() {
    return this.shaderProgram;
  }
  createTexture(e, t, s) {
    const i = this.gl, r = i.createTexture();
    i.bindTexture(i.TEXTURE_2D, r), i.texImage2D(i.TEXTURE_2D, 0, i.RGBA8, i.RGBA, i.UNSIGNED_BYTE, s), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_S, i.CLAMP_TO_EDGE), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_T, i.CLAMP_TO_EDGE), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, i.NEAREST), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MAG_FILTER, i.NEAREST), this.texturesMap.set(t, { texture: r, tileset: e });
  }
  createTextureArray(e, t, s) {
    const i = this.gl, r = i.createBuffer();
    i.bindBuffer(i.PIXEL_UNPACK_BUFFER, r), i.bufferData(i.PIXEL_UNPACK_BUFFER, s, i.STATIC_DRAW), i.pixelStorei(i.UNPACK_ROW_LENGTH, e.imageWidth), i.pixelStorei(i.UNPACK_IMAGE_HEIGHT, e.imageHeight);
    const a = i.createTexture();
    i.bindTexture(i.TEXTURE_2D_ARRAY, a), i.texStorage3D(i.TEXTURE_2D_ARRAY, 4, i.RGBA8, e.tileWidth, e.tileHeight, e.tileCount);
    for (let n = 0; n < e.tileCount; ++n) {
      const h = n % e.columns, o = Math.floor(n / e.columns);
      i.pixelStorei(i.UNPACK_SKIP_PIXELS, h * e.tileWidth), i.pixelStorei(i.UNPACK_SKIP_ROWS, o * e.tileHeight), i.texSubImage3D(i.TEXTURE_2D_ARRAY, 0, 0, 0, n, e.tileWidth, e.tileHeight, 1, i.RGBA, i.UNSIGNED_BYTE, 0);
    }
    i.deleteBuffer(r), i.generateMipmap(i.TEXTURE_2D_ARRAY), i.texParameteri(i.TEXTURE_2D_ARRAY, i.TEXTURE_MAG_FILTER, i.NEAREST), i.texParameteri(i.TEXTURE_2D_ARRAY, i.TEXTURE_MIN_FILTER, i.NEAREST), this.texturesMap.set(t, { texture: a, tileset: e });
  }
}
class W {
  constructor(e, t, s) {
    this.gl = e, this.renderer = t, this.isStatic = s, this.needsUpdate = !0, this.drawCalls = [], this.lifetime = m, this.vao = e.createVertexArray(), e.bindVertexArray(this.vao), e.bindBuffer(e.ARRAY_BUFFER, t.getVBO()), e.enableVertexAttribArray(0), e.vertexAttribPointer(0, 2, e.FLOAT, !1, 16, 0), e.enableVertexAttribArray(1), e.vertexAttribPointer(1, 2, e.FLOAT, !1, 16, 8);
    const i = 24;
    this.spriteBuffer = e.createBuffer(), e.bindBuffer(e.ARRAY_BUFFER, this.spriteBuffer), e.bufferData(e.ARRAY_BUFFER, (this.isStatic ? f : E) * 4 * i, this.isStatic ? e.STATIC_DRAW : e.DYNAMIC_DRAW), e.enableVertexAttribArray(2), e.vertexAttribPointer(2, 2, e.FLOAT, !1, i, 0), e.enableVertexAttribArray(3), e.vertexAttribPointer(3, 2, e.FLOAT, !1, i, 8), e.enableVertexAttribArray(4), e.vertexAttribIPointer(4, 4, e.UNSIGNED_SHORT, i, 16), e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, t.getEBO()), e.bindVertexArray(null);
  }
  upload(e) {
    const t = this.gl;
    t.bindBuffer(t.ARRAY_BUFFER, this.spriteBuffer), t.bufferSubData(t.ARRAY_BUFFER, 0, p.createSpritesData(e)), this.isStatic && (this.needsUpdate = !1), this.drawCalls.length = 0;
    let s = null;
    for (let i = 0; i < e.length; ++i) {
      const r = e[i].tileset.name;
      !s || r !== s.texName ? (s = { texName: r, spriteOffset: i, spriteCount: 1 }, this.drawCalls.push(s)) : s.spriteCount++;
    }
  }
  render() {
    const e = this.gl;
    e.bindVertexArray(this.vao);
    for (const t of this.drawCalls) {
      const s = this.renderer.getTextureInfo(t.texName);
      e.bindTexture(e.TEXTURE_2D, s.texture), this.gl.uniform2f(this.renderer.getShaderProgram().getUniform("uTilesetDimensions"), s.tileset.imageWidth, s.tileset.imageHeight), e.drawElements(e.TRIANGLES, 6 * t.spriteCount, e.UNSIGNED_INT, t.spriteOffset * 6 * 4);
    }
    e.bindVertexArray(null), this.lifetime = m;
  }
  destroy() {
    this.gl.deleteBuffer(this.spriteBuffer), this.gl.deleteVertexArray(this.vao);
  }
}
const H = async () => {
  const e = await (await navigator.gpu?.requestAdapter())?.requestDevice();
  if (!e) return null;
  const t = navigator.gpu.getPreferredCanvasFormat();
  return {
    device: e,
    format: t
  };
}, z = `
struct VSInput {
    @location(0) vertexPos: vec2f,
    @location(1) texCoord: vec2f,
    
    @location(2) tilePos: vec2f,
    @location(3) tileScale: vec2f,
    @location(4) tileRegion: vec2u
}

struct Camera {
    pos: vec2f,
    viewportDimensions: vec2f
}

@group(0) @binding(0)
var<uniform> camera: Camera;

@group(1) @binding(2)
var<uniform> tilesetDimensions: vec2f;

struct VSOutput {
    @builtin(position) pos: vec4f,
    @location(0) uv: vec2f,
}

@vertex
fn vs_main(input: VSInput) -> VSOutput {
    var out: VSOutput;

    let x = f32(input.tileRegion.x & 0xFFFFu);
    let y = f32(input.tileRegion.x >> 16);
    let w = f32(input.tileRegion.y & 0xFFFFu);
    let h = f32(input.tileRegion.y >> 16);

    let tileRegion = vec4f(x, y, w, h);

    let flippedTexCoord = vec2f(input.texCoord.x, 1.0 - input.texCoord.y);
    out.uv = (tileRegion.xy + flippedTexCoord * tileRegion.zw) / tilesetDimensions;

    let worldPos = input.vertexPos * input.tileScale + input.tilePos;
    let pixelPos = worldPos - camera.pos;
    let clipPos = vec2f(pixelPos.x / camera.viewportDimensions.x, 1.0 - pixelPos.y / camera.viewportDimensions.y) * 2.0 - 1.0;
    out.pos = vec4f(clipPos, 0.0, 1.0);

    return out;
}

@group(1) @binding(0)
var spriteSampler: sampler;

@group(1) @binding(1)
var spriteTexture: texture_2d<f32>;

@fragment
fn fs_main(input: VSOutput) -> @location(0) vec4f {
    return textureSample(spriteTexture, spriteSampler, input.uv);
}
`;
class q {
  constructor(e) {
    this.layersMap = /* @__PURE__ */ new Map(), this.texturesMap = /* @__PURE__ */ new Map(), this.canvas = e, this.clearColor = new A(0, 0, 0, 0), this.texturesInfo = [];
  }
  addTextures(e, t) {
    for (const s of e)
      t[s.name] && this.texturesInfo.push({
        tileset: s,
        image: t[s.name]
      });
  }
  setClearColor(e) {
    this.clearColor.copy(e);
  }
  setSize(e, t) {
    this.canvas.width = e, this.canvas.height = t;
  }
  getCanvas() {
    return this.canvas;
  }
  async init() {
    const e = await H();
    if (!e) throw new Error("WebGPU not supported");
    this.cfg = e;
    const t = this.cfg.device, s = this.canvas.getContext("webgpu");
    this.ctx = s, this.ctx.configure(this.cfg);
    for (const r of this.texturesInfo)
      r.tileset && this.createTexture(r.tileset, r.tileset.name, r.image);
    const i = t.createShaderModule({
      code: z
    });
    this.pipeline = t.createRenderPipeline({
      layout: "auto",
      vertex: {
        module: i,
        entryPoint: "vs_main",
        buffers: [
          {
            arrayStride: 16,
            stepMode: "vertex",
            attributes: [
              { shaderLocation: 0, offset: 0, format: "float32x2" },
              { shaderLocation: 1, offset: 8, format: "float32x2" }
            ]
          },
          {
            arrayStride: 24,
            stepMode: "instance",
            attributes: [
              { shaderLocation: 2, offset: 0, format: "float32x2" },
              { shaderLocation: 3, offset: 8, format: "float32x2" },
              { shaderLocation: 4, offset: 16, format: "uint32x2" }
            ]
          }
        ]
      },
      fragment: {
        module: i,
        entryPoint: "fs_main",
        targets: [
          {
            format: this.cfg.format,
            blend: {
              color: {
                srcFactor: "src-alpha",
                dstFactor: "one-minus-src-alpha",
                operation: "add"
              },
              alpha: {
                srcFactor: "one",
                dstFactor: "one-minus-src-alpha",
                operation: "add"
              }
            }
          }
        ]
      },
      primitive: { topology: "triangle-strip" }
    }), this.cameraBuffer = t.createBuffer({
      size: 16,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    }), this.cameraBindGroup = t.createBindGroup({
      layout: this.pipeline.getBindGroupLayout(0),
      entries: [{
        binding: 0,
        resource: { buffer: this.cameraBuffer }
      }]
    }), this.sampler = t.createSampler({
      magFilter: "nearest",
      minFilter: "nearest",
      addressModeU: "clamp-to-edge",
      addressModeV: "clamp-to-edge"
    }), this.vbo = t.createBuffer({
      size: p.quad.byteLength,
      usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
    }), t.queue.writeBuffer(this.vbo, 0, p.quad);
  }
  render(e, t) {
    const s = [];
    for (const n of e.getLayersOrdered()) {
      if (!this.layersMap.has(n)) {
        const o = new k(this, n.isStatic);
        this.layersMap.set(n, o);
      }
      const h = this.layersMap.get(n);
      h.needsUpdate && h.upload(n.getSpritesOrdered()), s.push(h);
    }
    this.cfg.device.queue.writeBuffer(
      this.cameraBuffer,
      0,
      t.position.toArray()
    ), this.cfg.device.queue.writeBuffer(
      this.cameraBuffer,
      8,
      new Float32Array([t.vw, t.vh])
    );
    const i = this.cfg.device.createCommandEncoder(), r = i.beginRenderPass({
      colorAttachments: [{
        clearValue: this.clearColor,
        view: this.ctx.getCurrentTexture().createView(),
        loadOp: "clear",
        storeOp: "store"
      }]
    });
    r.setPipeline(this.pipeline), r.setBindGroup(0, this.cameraBindGroup), r.setVertexBuffer(0, this.vbo);
    for (const n of s)
      n.render(r);
    r.end();
    const a = i.finish();
    this.cfg.device.queue.submit([a]);
    for (const [n, h] of this.layersMap)
      h.lifetime <= 0 && (h.destroy(), this.layersMap.delete(n));
  }
  createTexture(e, t, s) {
    const i = this.cfg.device.createTexture({
      size: {
        width: e.imageWidth,
        height: e.imageHeight,
        depthOrArrayLayers: 1
      },
      format: "rgba8unorm",
      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT
    });
    this.cfg.device.queue.copyExternalImageToTexture, this.cfg.device.queue.copyExternalImageToTexture(
      { source: s },
      { texture: i },
      [e.imageWidth, e.imageHeight, 1]
    ), this.texturesMap.set(t, { texture: i, tileset: e });
  }
  createTextureArray(e, t, s) {
    const i = e.tileWidth, r = e.tileHeight, a = this.cfg.device.createTexture({
      size: {
        width: i,
        height: r,
        depthOrArrayLayers: e.tileCount
      },
      format: "rgba8unorm",
      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT
    });
    for (let n = 0; n < e.tileCount; ++n) {
      const h = Math.floor(n / e.columns), o = n % e.columns, u = new Uint8Array(i * r * 4);
      for (let c = 0; c < r; ++c) {
        const g = ((h * r + c) * e.columns + o) * i * 4, x = g + i * 4;
        u.set(s.slice(g, x), c * i * 4);
      }
      this.cfg.device.queue.writeTexture(
        {
          texture: a,
          origin: { x: 0, y: 0, z: n }
        },
        u,
        {
          bytesPerRow: i * 4,
          rowsPerImage: r
        },
        {
          width: i,
          height: r,
          depthOrArrayLayers: 1
        }
      );
    }
    this.texturesMap.set(t, { texture: a, tileset: e });
  }
  getConfig() {
    return this.cfg;
  }
  getTextureInfo(e) {
    const t = this.texturesMap.get(e);
    if (!t) throw new Error("Texture not found: " + e);
    return t;
  }
  getPipeline() {
    return this.pipeline;
  }
  getSampler() {
    return this.sampler;
  }
}
class k {
  constructor(e, t) {
    this.renderer = e, this.isStatic = t, this.needsUpdate = !0, this.drawCalls = [], this.bindGroups = /* @__PURE__ */ new Map(), this.lifetime = m, this.lastTexIdx = 0, this.instanceBuffer = e.getConfig().device.createBuffer({
      label: "Instance Buffer",
      size: 24 * (t ? f : E),
      usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
    }), this.tilesetDimBuffer = e.getConfig().device.createBuffer({
      label: "Tileset Dimensions Buffer",
      size: K * 256,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
  }
  upload(e) {
    const t = this.renderer.getConfig().device, s = this.renderer.getPipeline(), i = this.renderer.getSampler();
    t.queue.writeBuffer(this.instanceBuffer, 0, p.createSpritesData(e, !0)), this.isStatic && (this.needsUpdate = !1), this.drawCalls.length = 0;
    let r = null;
    for (let a = 0; a < e.length; ++a) {
      const n = e[a].tileset.name;
      if (!r || n !== r.texName) {
        const h = this.renderer.getTextureInfo(n);
        t.queue.writeBuffer(
          this.tilesetDimBuffer,
          this.lastTexIdx * 256,
          new Float32Array([h.tileset.imageWidth, h.tileset.imageHeight])
        );
        const o = t.createBindGroup({
          layout: s.getBindGroupLayout(1),
          entries: [
            { binding: 0, resource: i },
            { binding: 1, resource: h.texture.createView() },
            {
              binding: 2,
              resource: {
                buffer: this.tilesetDimBuffer,
                offset: this.lastTexIdx * 256,
                size: 8
              }
            }
          ]
        });
        r = {
          texName: n,
          instanceOffset: a,
          instanceCount: 1
        }, this.bindGroups.has(r.texName) || (this.bindGroups.set(r.texName, o), ++this.lastTexIdx), this.drawCalls.push(r);
      } else
        r.instanceCount++;
    }
  }
  render(e) {
    e.setVertexBuffer(1, this.instanceBuffer);
    for (const t of this.drawCalls)
      e.setBindGroup(1, this.bindGroups.get(t.texName)), e.draw(4, t.instanceCount, 0, t.instanceOffset);
    this.lifetime = m;
  }
  destroy() {
    this.instanceBuffer.destroy(), this.tilesetDimBuffer.destroy();
  }
}
const f = 1e5, E = 1e5, m = 30, K = 16, ie = (l) => {
  const e = document.createElement("canvas");
  switch (l) {
    case "webgl":
      return new N(e);
    case "webgl2":
      return new X(e);
    case "webgpu":
      return new q(e);
    default:
      throw new Error("Unknwn renderer type");
  }
};
class j {
  constructor(e) {
    this.zIndex = e.zIndex || 0, this.tileset = e.tileset, this.tilesetRegion = e.tilesetRegion, this.isStatic = e.isStatic || !1, this.position = new d(), this.offset = new d(), this.scale = new d(1, 1);
  }
  setTilesetRegion(e, t, s = 1, i = 1) {
    this.tilesetRegion.x = e, this.tilesetRegion.y = t, this.tilesetRegion.width = s, this.tilesetRegion.height = i;
  }
  getTile() {
    return this.tileset.getTile(this.tilesetRegion.x, this.tilesetRegion.y);
  }
}
class re {
  constructor() {
    this.layers = [];
  }
  addSprite(e) {
    let t = this.layers.find((s) => s.isStatic === e.isStatic && s.zIndex === e.zIndex);
    return t || (t = new v({
      zIndex: e.zIndex,
      isStatic: e.isStatic
    }), this.layers.push(t)), t.add(e), e;
  }
  addTilemap(e, t = {}) {
    const s = e.getLayers();
    let i = 0;
    const r = [], a = [];
    for (const n of s) {
      const h = t.layers?.find((o) => o.name === n.name);
      switch (h?.zIndex && (i = h.zIndex), n.renderOrder !== "manual" && this.createLayer({
        zIndex: i,
        renderOrder: n.renderOrder,
        isStatic: !1
      }), n.type) {
        case "tilelayer": {
          for (let o = 0; o < n.height; ++o)
            for (let u = 0; u < n.width; ++u) {
              const c = n.getTile(u, o);
              if (!c) continue;
              const g = new j({
                isStatic: c.animation === void 0,
                zIndex: i,
                tileset: c.tileset,
                tilesetRegion: { x: c.x, y: c.y }
              });
              if (g.position.set((u + n.x) * e.tileWidth, (o + n.y) * e.tileHeight), g.scale.set(e.tileWidth, e.tileHeight), r.push(this.addSprite(g)), c.animation) {
                const x = new L(g);
                x.play({ x: c.x, y: c.y }, { repeat: !0 }), a.push(x);
              }
            }
          break;
        }
        case "objectgroup": {
          if (t.onObject) {
            const o = n.getObjects();
            for (const u of o)
              t.onObject(this, u, n, i);
          }
          break;
        }
      }
      ++i;
    }
    return {
      sprites: r,
      animators: a
    };
  }
  createLayer(e) {
    const t = new v(e);
    return this.layers.push(t), t;
  }
  getLayersOrdered() {
    return this.layers.sort((e, t) => e.zIndex - t.zIndex);
  }
}
class v {
  constructor(e) {
    this.zIndex = e.zIndex, this.isStatic = e.isStatic, this.renderOrder = e.renderOrder || "manual", this.sprites = [];
  }
  add(e) {
    if (this.renderOrder === "manual") {
      let t = -1;
      for (let s = this.sprites.length - 1; s >= 0; --s)
        if (this.sprites[s].tileset.name <= e.tileset.name) {
          t = s;
          break;
        }
      t === -1 ? this.sprites.unshift(e) : this.sprites.splice(t + 1, 0, e);
    } else
      this.sprites.push(e);
  }
  getSpritesOrdered() {
    switch (this.renderOrder) {
      case "topdown":
        return this.sprites.sort((e, t) => e.position.y - t.position.y);
      default:
        return this.sprites;
    }
  }
}
class b {
  constructor(e, t, s, i, r) {
    this.tileset = e, this.id = t, this.x = s, this.y = i, this.properties = r?.properties, this.animation = r?.animation;
  }
  getProperty(e) {
    return this.properties?.find((t) => t.name === e) ?? null;
  }
}
const R = class R {
  constructor(e) {
    if (this.name = e.name, this.imageWidth = e.imagewidth, this.imageHeight = e.imageheight, this.tileWidth = e.tilewidth, this.tileHeight = e.tileheight, this.columns = e.columns, this.tileCount = e.tilecount, this.margin = e.margin || 0, this.spacing = e.spacing || 0, this.tiledata = /* @__PURE__ */ new Map(), e.tiles)
      for (let t of e.tiles)
        this.tiledata.set(t.id, t);
  }
  static async load(e) {
    if (!this.cache.has(e)) {
      const t = await S.loadJson(e);
      this.cache.set(e, new R(t));
    }
    return this.cache.get(e);
  }
  static getByName(e) {
    return this.cache.values().find((t) => t.name === e) || null;
  }
  getTile(e, t) {
    if (e < 0 || e >= this.columns || t < 0 || t >= Math.ceil(this.tileCount / this.columns)) return null;
    const s = t * this.columns + e, i = this.tiledata.get(s);
    return new b(this, s, e, t, i);
  }
  getTileById(e) {
    if (e >= this.tileCount || e < 0) return null;
    const t = e % this.columns, s = Math.floor(e / this.columns), i = this.tiledata.get(e);
    return new b(this, e, t, s, i);
  }
  getTileXY(e) {
    const t = e % this.columns, s = Math.floor(e / this.columns);
    return { x: t, y: s };
  }
};
R.cache = /* @__PURE__ */ new Map();
let y = R;
class _ {
  constructor(e) {
    this.name = e.name, this.x = e.x, this.y = e.y, this.width = e.width, this.height = e.height, this.type = e.type, this.renderOrder = e.draworder || "manual";
  }
}
class $ extends _ {
  constructor(e) {
    super(e), this.data = e.data;
  }
  getTile(e, t) {
    const s = this.data[t * this.width + e];
    return s - 1 == -1 ? null : this.tilemap.getTileById(s);
  }
}
class J extends _ {
  constructor(e) {
    super(e), this.objects = e.objects;
  }
  getObjects() {
    return this.objects;
  }
}
class U {
  constructor(e, t, s, i) {
    this.width = e, this.height = t, this.tileWidth = s, this.tileHeight = i, this.tilesets = [], this.layers = [];
  }
  static async load(e, t) {
    const s = await S.loadJson(e), i = new U(s.width, s.height, s.tilewidth, s.tileheight);
    for (const r of s.layers)
      switch (r.type) {
        case "tilelayer":
          i.addLayer(new $(r));
          break;
        case "objectgroup":
          i.addLayer(new J(r));
          break;
      }
    for (let r of s.tilesets) {
      let a;
      if (r.source) {
        const n = r.source.split(/(\/|\\\/)/), h = n[n.length - 1].split(".tsj")[0];
        if (!t[h]) throw new Error("Source is missing for tileset: " + h);
        a = await y.load(t[h]);
      } else
        a = new y(r);
      i.tilesets.push({ tileset: a, firstGlobalId: r.firstgid });
    }
    return i;
  }
  addLayer(e) {
    e.tilemap = this, this.layers.push(e);
  }
  getTilesets() {
    return this.tilesets.map((e) => e.tileset);
  }
  getTilesetByName(e) {
    return this.tilesets.find((t) => t.tileset.name === e)?.tileset || null;
  }
  getLayers() {
    return this.layers;
  }
  getLayerByName(e) {
    return this.layers.find((t) => t.name === e) || null;
  }
  getTileById(e) {
    const t = this.tilesets;
    for (let s of t) {
      let i = s.tileset.getTileById(e - s.firstGlobalId);
      if (i)
        return i;
    }
    return null;
  }
}
export {
  L as Animator,
  ee as Camera,
  A as Color,
  Q as LinearSpline,
  Z as LinearSplineVector,
  re as Scene,
  j as Sprite,
  U as Tilemap,
  y as Tileset,
  d as Vector,
  S as assets,
  ie as createRenderer,
  P as math,
  T as matrix
};
