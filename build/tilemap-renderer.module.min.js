class q {
  constructor(e) {
    this.repeat = !0, this.currentFrameIndex = 0, this.frameTimer = 0, this.sprite = e, this.animation = null;
  }
  play(e, t = {}) {
    const r = this.sprite.tileset.getTile(e.x, e.y);
    if (!r) return;
    const s = r.animation || [{ tileid: r.id, duration: 100 }];
    if (!t.restart && this.animation === s)
      return;
    this.animation = s, this.repeat = t.repeat ?? !0, this.currentFrameIndex = 0, this.frameTimer = 0;
    const i = this.animation[0], n = this.sprite.tileset.getTileXY(i.tileid);
    this.sprite.setTilesetRegion(n.x, n.y);
  }
  update(e) {
    if (!this.animation) return;
    const t = this.animation[this.currentFrameIndex];
    if (this.frameTimer += e * 1e3, this.frameTimer < t.duration) return;
    if (this.frameTimer -= t.duration, this.currentFrameIndex++, this.currentFrameIndex >= this.animation.length)
      if (this.repeat)
        this.currentFrameIndex = 0;
      else {
        this.currentFrameIndex = this.animation.length - 1, this.animation = null;
        return;
      }
    const r = this.animation[this.currentFrameIndex], s = this.sprite.tileset.getTileXY(r.tileid);
    this.sprite.setTilesetRegion(s.x, s.y);
  }
}
const Y = {
  loadImage: (t) => new Promise((r, s) => {
    const i = new Image();
    i.crossOrigin = "anonymous", i.src = t, i.onload = () => {
      r(i);
    }, i.onerror = () => {
      s();
    };
  }),
  loadJson: async (t) => {
    try {
      return await (await fetch(t)).json();
    } catch {
      throw new Error(`Failed to load: ${t}`);
    }
  }
}, U = {
  create: () => new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
  identity: (i) => (i[0] = 1, i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = 1, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[10] = 1, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, i),
  createOrtho: (i, n, o, a, l) => (i[0] = 2 / (o - n), i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = 2 / (l - a), i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[10] = 1, i[11] = 0, i[12] = -(o + n) / (o - n), i[13] = -(l + a) / (l - a), i[14] = 0, i[15] = 1, i),
  translate: (i, n) => (i[12] += n.x, i[13] += n.y, i),
  scale: (i, n) => (i[0] *= n.x, i[1] *= n.x, i[4] *= n.y, i[5] *= n.y, i)
}, v = /* @__PURE__ */ (() => {
  const c = (s, i, n) => Math.min(Math.max(s, i), n);
  return {
    clamp: c,
    lerp: (s, i, n) => s + (i - s) * n,
    unlerp: (s, i, n) => c((n - s) / (i - s), 0, 1),
    sat: (s) => c(s, 0, 1)
  };
})();
class Re {
  constructor(e = []) {
    this.points = e;
  }
  addPoint(e) {
    this.points.push(e);
  }
  getValue(e) {
    const t = this.points.length;
    if (t === 0) return 0;
    if (e <= 0) return this.points[0];
    if (e >= t - 1) return this.points[t - 1];
    const r = Math.floor(e), s = e - r;
    return v.lerp(this.points[r], this.points[r + 1], s);
  }
}
class y {
  constructor(e = 0, t = 0) {
    this.x = e, this.y = t;
  }
  set(e, t) {
    return this.x = e, this.y = t, this;
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this;
  }
  clone() {
    return new y(this.x, this.y);
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }
  scale(e) {
    return this.x *= e, this.y *= e, this;
  }
  mul(e) {
    return this.x *= e.x, this.y *= e.y, this;
  }
  div(e) {
    return e !== 0 ? (this.x /= e, this.y /= e) : (this.x = 0, this.y = 0), this;
  }
  static dot(e, t) {
    return e.x * t.x + e.y * t.y;
  }
  static cross(e, t) {
    return e.x * t.y - e.y * t.x;
  }
  len() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  lenSq() {
    return this.x * this.x + this.y * this.y;
  }
  unit() {
    const e = this.len();
    return e > 0 && this.div(e), this;
  }
  project(e) {
    const t = e.lenSq();
    if (t > 0) return this.scale(0);
    const r = y.dot(this, e);
    return this.copy(e).scale(r / t);
  }
  static distance(e, t) {
    const r = e.x - t.x, s = e.y - t.y;
    return Math.sqrt(r * r + s * s);
  }
  angle() {
    return Math.atan2(this.y, this.x);
  }
  rot(e) {
    const t = Math.cos(e), r = Math.sin(e), s = this.x * t - this.y * r, i = this.x * r + this.y * t;
    return this.x = s, this.y = i, this;
  }
  fromAngle(e, t = 1) {
    return this.x = Math.cos(e) * t, this.y = Math.sin(e) * t, this;
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this;
  }
  toString() {
    return `Vector(${this.x}, ${this.y})`;
  }
  toArray() {
    return new Float32Array([this.x, this.y]);
  }
}
class we {
  constructor(e = []) {
    this.points = e.slice().sort((t, r) => t.x - r.x);
  }
  addPoint(e) {
    this.points.push(e), this.points.sort((t, r) => t.x - r.x);
  }
  getValue(e) {
    const t = this.points.length;
    if (t === 0) return new y();
    if (e <= this.points[0].x) return this.points[0].clone();
    if (e >= this.points[t - 1].x) return this.points[t - 1].clone();
    for (let r = 0; r < t - 1; r++) {
      const s = this.points[r], i = this.points[r + 1];
      if (e >= s.x && e <= i.x) {
        const n = v.unlerp(s.x, i.x, e);
        return s.clone().lerp(i, n);
      }
    }
    return new y();
  }
}
class Se {
  constructor(e, t) {
    this.projectionMatrix = U.create(), this.viewMatrix = U.create(), this.position = new y(), this.zoom = 1, this.vw = 0, this.vh = 0, this.updateProjection(e, t);
  }
  updateProjection(e, t) {
    this.vw = e, this.vh = t;
  }
  update() {
    U.identity(this.viewMatrix), U.translate(this.viewMatrix, new y(-this.position.x, -this.position.y));
    const e = this.vw * 0.5 / this.zoom, t = this.vh * 0.5 / this.zoom;
    U.createOrtho(this.projectionMatrix, -e, e, -t, t);
  }
}
class _ {
  constructor(e, t, r, s = 1) {
    this.r = e, this.g = t, this.b = r, this.a = s;
  }
  set(e, t, r, s) {
    this.r = e, this.g = t, this.b = r, this.a = s;
  }
  copy(e) {
    this.r = e.r, this.g = e.g, this.b = e.b, this.a = e.a;
  }
}
const A = (() => {
  const c = new Float32Array([
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    0,
    1,
    0,
    1,
    1
  ]), e = new Float32Array([
    -1,
    1,
    0,
    0,
    -1,
    -1,
    0,
    1,
    1,
    1,
    1,
    0,
    1,
    -1,
    1,
    1
  ]);
  return {
    quad: c,
    fullscreenQuad: e,
    createSpritesData: (r, s = !1) => {
      const i = s ? 1 : 4, n = 44, o = new ArrayBuffer(r.length * i * n), a = new DataView(o);
      let l = 0;
      for (const u of r) {
        const m = u.position.x + u.offset.x, x = u.position.y + u.offset.y, f = u.scale.x, h = u.scale.y, p = u.angle, d = u.tilesetRegion.x * (u.tileset.tileWidth + u.tileset.spacing) + u.tileset.margin, g = u.tilesetRegion.y * (u.tileset.tileHeight + u.tileset.spacing) + u.tileset.margin, E = u.tileset.tileWidth + ((u.tilesetRegion.width || 1) - 1) * (u.tileset.tileWidth + u.tileset.spacing), R = u.tileset.tileHeight + ((u.tilesetRegion.height || 1) - 1) * (u.tileset.tileHeight + u.tileset.spacing);
        for (let O = 0; O < i; ++O)
          a.setFloat32(l, m, !0), a.setFloat32(l + 4, x, !0), a.setFloat32(l + 8, f, !0), a.setFloat32(l + 12, h, !0), a.setFloat32(l + 16, p, !0), a.setUint16(l + 20, d, !0), a.setUint16(l + 22, g, !0), a.setUint16(l + 24, E, !0), a.setUint16(l + 26, R, !0), a.setFloat32(l + 28, u.maskColor.r, !0), a.setFloat32(l + 32, u.maskColor.g, !0), a.setFloat32(l + 36, u.maskColor.b, !0), a.setFloat32(l + 40, u.maskColor.a, !0), l += n;
      }
      return o;
    }
  };
})(), j = (c) => {
  switch (c) {
    case "float":
      return 1;
    case "vec2":
      return 2;
    case "vec3":
      return 3;
    case "vec4":
      return 4;
  }
};
class K {
  constructor() {
    this.ops = [], this.uniforms = [], this.uniformOffset = 0, this.uniform("resolution", "vec2"), this.uniform("time", "float");
  }
  declare(e, t) {
    return this.ops.push([0, e, t]), this;
  }
  set(e, t) {
    return this.ops.push([1, e, t]), this;
  }
  add(e, t) {
    return this.ops.push([2, e, t]), this;
  }
  sub(e, t) {
    return this.ops.push([3, e, t]), this;
  }
  mul(e, t) {
    return this.ops.push([4, e, t]), this;
  }
  div(e, t) {
    return this.ops.push([5, e, t]), this;
  }
  if(e) {
    return this.ops.push([7, e]), this;
  }
  elseif(e) {
    return this.ops.push([8, e]), this;
  }
  else() {
    return this.ops.push([
      9
      /* ELSE */
    ]), this;
  }
  endif() {
    return this.ops.push([
      10
      /* ENDIF */
    ]), this;
  }
  uniform(e, t) {
    return this.uniforms.push({ name: e, type: t, offset: this.uniformOffset }), this.uniformOffset += j(t), this;
  }
  getUniforms() {
    return this.uniforms;
  }
  build(e) {
    const t = [];
    for (const r of this.ops) {
      const [s, ...i] = r;
      switch (s) {
        case 0: {
          const [n, o, a] = r, l = e.getBuilderOptions().declareVar(o, a);
          t.push(l);
          break;
        }
        case 1:
        case 2:
        case 3:
        case 4:
        case 5: {
          const n = i[0], o = i[1], a = `${n} ${this.getOpAssignmentSymbol(s)} ${o};`;
          t.push(this.replaceExpression(e, a));
          break;
        }
        case 7:
        case 8: {
          const n = i[0];
          t.push(`${s === 7 ? "" : "} else "}if (${this.replaceExpression(e, n)}) {`);
          break;
        }
        case 9:
        case 10: {
          t.push("}" + (s === 10 ? "" : " else {"));
          break;
        }
      }
    }
    return {
      mainImage: t,
      uniforms: this.uniforms.map((r) => e.getBuilderOptions().declareVar(r.name, r.type, !0))
    };
  }
  getOpAssignmentSymbol(e) {
    switch (e) {
      case 1:
        return "=";
      case 2:
        return "+=";
      case 3:
        return "-=";
      case 4:
        return "*=";
      case 5:
        return "/=";
      default:
        return "";
    }
  }
  replaceExpression(e, t) {
    if (e.getType() !== "webgpu")
      for (let r = 0; r < C; ++r)
        t = t.replace(new RegExp("texture\\s*\\(\\s*" + r + "\\s*,", "g"), "texture(uChannel" + r + ", ");
    return this.replaceComponents(e, t);
  }
  replaceComponents(e, t) {
    const r = e.getBuilderOptions().componentMap;
    return t.replace(/\.[rgba]{1,4}\b/g, (s) => {
      const i = s.substring(1);
      let n = ".";
      for (let o = 0; o < i.length; ++o) {
        const a = i[o];
        n += r[a] ?? a;
      }
      return n;
    });
  }
}
const B = new K().declare("uv", "vec2").set("uv", "fragCoord / uniforms.resolution").add("fragColor", "texture(0, uv)");
class W {
  constructor(e, t, r) {
    this.gl = e, this.width = t, this.height = r, this.texture = e.createTexture(), e.bindTexture(e.TEXTURE_2D, this.texture), e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, t, r, 0, e.RGBA, e.UNSIGNED_BYTE, null), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.LINEAR), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.LINEAR), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE), this.fbo = e.createFramebuffer(), e.bindFramebuffer(e.FRAMEBUFFER, this.fbo), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, this.texture, 0), e.checkFramebufferStatus(e.FRAMEBUFFER) !== e.FRAMEBUFFER_COMPLETE && console.error("Framebuffer incomplete!"), e.bindFramebuffer(e.FRAMEBUFFER, null), e.bindTexture(e.TEXTURE_2D, null);
  }
  bind() {
    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.fbo), this.gl.viewport(0, 0, this.width, this.height);
  }
  unbind() {
    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
  }
  destroy() {
    this.gl.deleteFramebuffer(this.fbo), this.gl.deleteTexture(this.texture);
  }
}
class w {
  constructor(e, t, r) {
    this.gl = e, this.uniforms = /* @__PURE__ */ new Map(), this.attribs = /* @__PURE__ */ new Map();
    const s = this.compileShader(e.VERTEX_SHADER, t), i = this.compileShader(e.FRAGMENT_SHADER, r);
    if (this.program = e.createProgram(), e.attachShader(this.program, s), e.attachShader(this.program, i), e.linkProgram(this.program), !e.getProgramParameter(this.program, e.LINK_STATUS))
      throw new Error(e.getProgramInfoLog(this.program) ?? "Could not link program");
    e.deleteShader(s), e.deleteShader(i);
  }
  compileShader(e, t) {
    const r = this.gl.createShader(e);
    if (!r) throw new Error("Could not create shader");
    if (this.gl.shaderSource(r, t), this.gl.compileShader(r), !this.gl.getShaderParameter(r, this.gl.COMPILE_STATUS))
      throw new Error(this.gl.getShaderInfoLog(r) ?? "Could not compile shader");
    return r;
  }
  use() {
    this.gl.useProgram(this.program);
  }
  getUniform(e) {
    if (!this.uniforms.has(e)) {
      const t = this.gl.getUniformLocation(this.program, e);
      this.uniforms.set(e, t);
    }
    return this.uniforms.get(e);
  }
  getAttrib(e) {
    return this.attribs.has(e) || this.attribs.set(e, this.gl.getAttribLocation(this.program, e)), this.attribs.get(e);
  }
}
const V = `

attribute vec2 aVertexPos;
attribute vec2 aTexCoord;
attribute vec2 aTilePos;
attribute float aTileAngle;
attribute vec2 aTileScale;
attribute vec4 aTileRegion;
attribute vec4 aMaskColor;

uniform vec2 uViewportDimensions;
uniform vec2 uCameraPos;

uniform vec2 uTilesetDimensions;

varying vec2 uv;
varying vec4 maskColor;

void main() {
    maskColor = aMaskColor;

    vec2 flippedTexCoord = vec2(aTexCoord.x, 1.0 - aTexCoord.y);
    uv = (vec2(aTileRegion.xy) + flippedTexCoord * vec2(aTileRegion.zw)) / uTilesetDimensions;

    float c = cos(aTileAngle);
    float s = sin(aTileAngle);
    vec2 rotatedPos = vec2(
        aVertexPos.x * c - aVertexPos.y * s,
        aVertexPos.x * s + aVertexPos.y * c
    );
    vec2 worldPos = rotatedPos * aTileScale + aTilePos;
    vec2 pixelPos = worldPos - uCameraPos;
    vec2 clipPos = vec2(pixelPos.x / uViewportDimensions.x, 1.0 - pixelPos.y / uViewportDimensions.y) * 2.0 - 1.0;
    gl_Position = vec4(clipPos, 0.0, 1.0);
}
`, J = `

precision mediump float;

varying vec2 uv;

uniform sampler2D uSampler;  

void main() {
    gl_FragColor = texture2D(uSampler, uv);
}
`, Q = `

precision mediump float;

varying vec2 uv;
varying vec4 maskColor;

uniform mediump sampler2D uSampler;  

void main() {
    vec4 texColor = texture2D(uSampler, uv);
    gl_FragColor = vec4(maskColor.rgb, texColor.a * maskColor.a);
}
`, Z = `

attribute vec2 aPos;

void main() {
    gl_Position = vec4(aPos, 0.0, 1.0);
}
`, ee = (c) => `
#define texture texture2D

precision mediump float;

struct Uniforms {
${c.uniforms.map((e) => "    " + e).join(`
`)}
};

uniform sampler2D uChannel0;
uniform sampler2D uChannel1;
uniform sampler2D uChannel2;
uniform sampler2D uChannel3;
uniform sampler2D uChannel4;
uniform sampler2D uChannel5;
uniform sampler2D uChannel6;
uniform sampler2D uChannel7;

uniform Uniforms uniforms;

void mainImage(out vec4 fragColor, in vec2 fragCoord) {
${c.mainImage.map((e) => "    " + e).join(`
`)}
}

void main() {
    vec2 fragCoord = vec2(gl_FragCoord.x, gl_FragCoord.y);
    mainImage(gl_FragColor, fragCoord);
}
`, te = {
  componentMap: { r: "r", g: "g", b: "b", a: "a" },
  declareVar: (c, e) => `${e} ${c};`
};
class re {
  constructor(e) {
    this.canvas = e, this.layersMap = /* @__PURE__ */ new Map(), this.texturesMap = /* @__PURE__ */ new Map(), this.clearColor = new _(0, 0, 0, 0), this.shaderMap = /* @__PURE__ */ new Map(), this.initialized = !1, this.pass = [D], this.framebuffers = [];
  }
  getType() {
    return "webgl";
  }
  getBuilderOptions() {
    return te;
  }
  addTextures(e, t) {
    for (const r of e)
      t[r.name] && this.texturesMap.set(r.name, {
        tileset: r,
        image: t[r.name]
      });
  }
  registerShader(e, t) {
    this.shaderMap.set(e, { builder: t });
  }
  setClearColor(e) {
    this.clearColor.copy(e);
  }
  setSize(e, t) {
    this.canvas.width = e, this.canvas.height = t, this.initialized && this.initFramebuffers();
  }
  getCanvas() {
    return this.canvas;
  }
  initFramebuffers() {
    for (let e = 0; e < T; ++e) {
      const t = M(e);
      this.framebuffers[e]?.destroy(), this.framebuffers[e] = new W(this.gl, this.canvas.width * t, this.canvas.height * t);
    }
  }
  async init() {
    const e = this.canvas.getContext("webgl");
    if (!e) throw new Error("WebGL not supported");
    this.gl = e;
    for (const i of this.texturesMap.values())
      i.tileset && (i.texture = this.createTexture(i.image));
    this.registerShader("default", B);
    for (const i of this.shaderMap.values()) {
      const n = i.builder.build(this);
      i.shader = new w(e, Z, ee(n));
    }
    this.shaderProgram = new w(e, V, J), this.maskShaderProgram = new w(e, V, Q), this.vbo = e.createBuffer(), e.bindBuffer(e.ARRAY_BUFFER, this.vbo);
    const t = new Float32Array(b * 4 * 4);
    for (let i = 0; i < b; ++i)
      t.set(A.quad, i * 4 * 4);
    e.bufferData(e.ARRAY_BUFFER, t, e.STATIC_DRAW);
    const r = [0, 1, 2, 1, 2, 3];
    this.ebo = e.createBuffer(), e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this.ebo);
    const s = new Uint16Array(b * 6);
    for (let i = 0; i < b; ++i)
      for (let n = 0; n < 6; ++n)
        s[i * 6 + n] = r[n] + 4 * i;
    e.bufferData(e.ELEMENT_ARRAY_BUFFER, s, e.STATIC_DRAW), e.enable(e.BLEND), e.blendFunc(e.SRC_ALPHA, e.ONE_MINUS_SRC_ALPHA), this.initFramebuffers(), this.fullscreenVbo = e.createBuffer(), e.bindBuffer(e.ARRAY_BUFFER, this.fullscreenVbo), e.bufferData(e.ARRAY_BUFFER, A.fullscreenQuad, e.STATIC_DRAW), this.initialized = !0;
  }
  renderScene(e, t, r, s, i) {
    e.bind(), this.gl.clearColor(s.r, s.g, s.b, s.a), this.gl.clear(this.gl.COLOR_BUFFER_BIT), t.use(), this.gl.uniform2f(t.getUniform("uViewportDimensions"), r.vw, r.vh), this.gl.uniform2f(t.getUniform("uCameraPos"), r.position.x, r.position.y), this.gl.activeTexture(this.gl.TEXTURE0);
    for (let n of i)
      n.render(t);
    e.unbind();
  }
  render(e, t) {
    const r = [];
    for (const i of e.getLayersOrdered()) {
      if (!this.layersMap.has(i)) {
        const o = new ie(this.gl, this, i.isStatic);
        this.layersMap.set(i, o);
      }
      const n = this.layersMap.get(i);
      n.needsUpdate && n.upload(i.getSpritesOrdered()), r.push(n);
    }
    this.renderScene(this.framebuffers[0], this.shaderProgram, t, this.clearColor, r), this.renderScene(this.framebuffers[1], this.maskShaderProgram, t, L, r);
    const s = performance.now() * 1e-3;
    for (let i = 0; i < this.pass.length; ++i) {
      const n = this.pass[i], o = this.shaderMap.get(n.shader);
      if (!o)
        throw new Error("Unknown shader " + n.shader);
      const a = o.shader;
      let l = this.canvas.width, u = this.canvas.height;
      if (n.output !== -1) {
        const h = this.framebuffers[v.clamp(n.output, 0, T - 1)];
        l = h.width, u = h.height, h.bind();
      } else
        this.gl.viewport(0, 0, l, u);
      a.use();
      const m = [{ name: "time", value: s }, { name: "resolution", value: [l, u] }].concat(n.uniforms ?? []), x = o.builder.getUniforms();
      for (let h of x) {
        const p = m.find((d) => d.name === h.name);
        if (p) {
          const d = typeof p.value == "number" ? [p.value] : p.value, g = a.getUniform("uniforms." + h.name);
          switch (h.type) {
            case "float":
              this.gl.uniform1f(g, d[0]);
              break;
            case "vec2":
              this.gl.uniform2fv(g, d);
              break;
            case "vec3":
              this.gl.uniform3fv(g, d);
              break;
            case "vec4":
              this.gl.uniform4fv(g, d);
              break;
          }
        }
      }
      for (let h = 0; h < C; h++) {
        const p = n.inputs[h] ?? n.inputs[0], d = this.framebuffers[v.clamp(p, 0, T - 1)].texture;
        this.gl.activeTexture(this.gl.TEXTURE0 + h), this.gl.bindTexture(this.gl.TEXTURE_2D, d);
        const g = a.getUniform(`uChannel${h}`);
        this.gl.uniform1i(g, h);
      }
      const f = a.getAttrib("aPos");
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.fullscreenVbo), this.gl.enableVertexAttribArray(f), this.gl.vertexAttribPointer(f, 2, this.gl.FLOAT, !1, 16, 0), this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4), this.gl.disableVertexAttribArray(f);
      for (let h = 0; h < C; h++)
        this.gl.activeTexture(this.gl.TEXTURE0 + h), this.gl.bindTexture(this.gl.TEXTURE_2D, null);
      n.output !== -1 && this.framebuffers[v.clamp(n.output, 0, T - 1)].unbind();
    }
    for (const [i, n] of this.layersMap)
      n.lifetime <= 0 && (this.layersMap.delete(i), n.destroy());
  }
  getTextureInfo(e) {
    const t = this.texturesMap.get(e);
    if (!t) throw new Error("Texture not found: " + e);
    return t;
  }
  getVBO() {
    return this.vbo;
  }
  getEBO() {
    return this.ebo;
  }
  createTexture(e) {
    const t = this.gl, r = t.createTexture();
    return t.bindTexture(t.TEXTURE_2D, r), t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, t.RGBA, t.UNSIGNED_BYTE, e), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.NEAREST), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.NEAREST), r;
  }
}
let ie = class {
  constructor(e, t, r) {
    this.gl = e, this.renderer = t, this.isStatic = r, this.needsUpdate = !0, this.drawCalls = [], this.lifetime = S, this.spriteBuffer = e.createBuffer(), e.bindBuffer(e.ARRAY_BUFFER, this.spriteBuffer), e.bufferData(e.ARRAY_BUFFER, (this.isStatic ? b : I) * 5 * 4 * 4, this.isStatic ? e.STATIC_DRAW : e.DYNAMIC_DRAW);
  }
  upload(e) {
    const t = this.gl;
    t.bindBuffer(t.ARRAY_BUFFER, this.spriteBuffer), t.bufferSubData(t.ARRAY_BUFFER, 0, A.createSpritesData(e)), this.isStatic && (this.needsUpdate = !1), this.drawCalls.length = 0;
    let r = null;
    for (let s = 0; s < e.length; ++s) {
      const i = e[s].tileset.name;
      !r || i !== r.texName ? (r = { texName: i, spriteOffset: s, spriteCount: 1 }, this.drawCalls.push(r)) : r.spriteCount++;
    }
  }
  render(e) {
    const t = this.gl;
    t.bindBuffer(t.ARRAY_BUFFER, this.renderer.getVBO());
    const r = {
      vertexPos: e.getAttrib("aVertexPos"),
      texCoord: e.getAttrib("aTexCoord"),
      tilePos: e.getAttrib("aTilePos"),
      tileScale: e.getAttrib("aTileScale"),
      tileAngle: e.getAttrib("aTileAngle"),
      tileRegion: e.getAttrib("aTileRegion"),
      maskColor: e.getAttrib("aMaskColor")
    };
    t.enableVertexAttribArray(r.vertexPos), t.vertexAttribPointer(r.vertexPos, 2, t.FLOAT, !1, 16, 0), t.enableVertexAttribArray(r.texCoord), t.vertexAttribPointer(r.texCoord, 2, t.FLOAT, !1, 16, 8), t.bindBuffer(t.ARRAY_BUFFER, this.spriteBuffer);
    const s = 44;
    t.enableVertexAttribArray(r.tilePos), t.vertexAttribPointer(r.tilePos, 2, t.FLOAT, !1, s, 0), t.enableVertexAttribArray(r.tileScale), t.vertexAttribPointer(r.tileScale, 2, t.FLOAT, !1, s, 8), t.enableVertexAttribArray(r.tileAngle), t.vertexAttribPointer(r.tileAngle, 1, t.FLOAT, !1, s, 16), t.enableVertexAttribArray(r.tileRegion), t.vertexAttribPointer(r.tileRegion, 4, t.UNSIGNED_SHORT, !1, s, 20), t.enableVertexAttribArray(r.maskColor), t.vertexAttribPointer(r.maskColor, 4, t.FLOAT, !1, s, 28), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.renderer.getEBO());
    for (const i of this.drawCalls) {
      const n = this.renderer.getTextureInfo(i.texName);
      t.bindTexture(t.TEXTURE_2D, n.texture), this.gl.uniform2f(e.getUniform("uTilesetDimensions"), n.tileset.imageWidth, n.tileset.imageHeight), t.drawElements(t.TRIANGLES, 6 * i.spriteCount, t.UNSIGNED_SHORT, i.spriteOffset * 6 * 2);
    }
    t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, null), t.disableVertexAttribArray(r.vertexPos), t.disableVertexAttribArray(r.texCoord), t.disableVertexAttribArray(r.tilePos), t.disableVertexAttribArray(r.tileScale), t.disableVertexAttribArray(r.tileAngle), t.disableVertexAttribArray(r.tileRegion), t.disableVertexAttribArray(r.maskColor), this.lifetime = S;
  }
  destroy() {
    this.gl.deleteBuffer(this.spriteBuffer);
  }
};
const G = `#version 300 es

layout(location = 0) in vec2 aVertexPos;
layout(location = 1) in vec2 aTexCoord;

layout(location = 2) in vec2 aTilePos;
layout(location = 3) in vec2 aTileScale;
layout(location = 4) in float aTileAngle;
layout(location = 5) in uvec4 aTileRegion;

layout(location=6) in vec4 aMaskColor;

uniform vec2 uViewportDimensions;
uniform vec2 uCameraPos;

uniform vec2 uTilesetDimensions;

out vec2 uv;
out vec4 maskColor;

void main() {
    maskColor = aMaskColor;

    vec2 flippedTexCoord = vec2(aTexCoord.x, 1.0 - aTexCoord.y);
    uv = (vec2(aTileRegion.xy) + flippedTexCoord * vec2(aTileRegion.zw)) / uTilesetDimensions;

    float c = cos(aTileAngle);
    float s = sin(aTileAngle);
    vec2 rotatedPos = vec2(
        aVertexPos.x * c - aVertexPos.y * s,
        aVertexPos.x * s + aVertexPos.y * c
    );
    vec2 worldPos = rotatedPos * aTileScale + aTilePos;
    vec2 pixelPos = worldPos - uCameraPos;
    vec2 clipPos = vec2(pixelPos.x / uViewportDimensions.x, 1.0 - pixelPos.y / uViewportDimensions.y) * 2.0 - 1.0;
    gl_Position = vec4(clipPos, 0.0, 1.0);
}
`, se = `#version 300 es

precision mediump float;

in vec2 uv;

uniform mediump sampler2D uSampler;  

out vec4 fragColor;

void main() {
    fragColor = texture(uSampler, uv);
}
`, ne = `#version 300 es

precision mediump float;

in vec2 uv;
in vec4 maskColor;

uniform mediump sampler2D uSampler;  

out vec4 fragColor;

void main() {
    vec4 texColor = texture(uSampler, uv);
    fragColor = vec4(maskColor.rgb, texColor.a * maskColor.a);
}
`, ae = `#version 300 es

out vec2 uv;

void main() {
    float x = float((gl_VertexID & 1) << 2);
    float y = float((gl_VertexID & 2) << 1);

    gl_Position = vec4(x - 1.0, y - 1.0, 0.0, 1.0);
}
`, oe = (c) => `#version 300 es
precision mediump float;

struct Uniforms {
${c.uniforms.map((e) => "    " + e).join(`
`)}
};

uniform sampler2D uChannel0;
uniform sampler2D uChannel1;
uniform sampler2D uChannel2;
uniform sampler2D uChannel3;
uniform sampler2D uChannel4;
uniform sampler2D uChannel5;
uniform sampler2D uChannel6;
uniform sampler2D uChannel7;

uniform Uniforms uniforms;

out vec4 fragColor;

void mainImage(out vec4 fragColor, in vec2 fragCoord) {
${c.mainImage.map((e) => "    " + e).join(`
`)}
}

void main() {
    vec2 fragCoord = gl_FragCoord.xy;
    mainImage(fragColor, fragCoord);
}
`, le = {
  componentMap: { r: "r", g: "g", b: "b", a: "a" },
  declareVar: (c, e) => `${e} ${c};`
};
class ue {
  constructor(e) {
    this.canvas = e, this.layersMap = /* @__PURE__ */ new Map(), this.texturesMap = /* @__PURE__ */ new Map(), this.clearColor = new _(0, 0, 0, 0), this.shaderMap = /* @__PURE__ */ new Map(), this.initialized = !1, this.pass = [D], this.framebuffers = [];
  }
  getType() {
    return "webgl2";
  }
  getBuilderOptions() {
    return le;
  }
  addTextures(e, t) {
    for (const r of e)
      t[r.name] && this.texturesMap.set(r.name, {
        tileset: r,
        image: t[r.name]
      });
  }
  registerShader(e, t) {
    this.shaderMap.set(e, { builder: t });
  }
  setClearColor(e) {
    this.clearColor.copy(e);
  }
  setSize(e, t) {
    this.canvas.width = e, this.canvas.height = t, this.initialized && this.initFramebuffers();
  }
  getCanvas() {
    return this.canvas;
  }
  initFramebuffers() {
    for (let e = 0; e < T; ++e) {
      const t = M(e);
      this.framebuffers[e]?.destroy(), this.framebuffers[e] = new W(this.gl, this.canvas.width * t, this.canvas.height * t);
    }
  }
  async init() {
    const e = this.canvas.getContext("webgl2");
    if (!e) throw new Error("WebGL2 not supported");
    this.gl = e;
    for (const i of this.texturesMap.values())
      i.tileset && (i.texture = this.createTexture(i.image));
    this.initFramebuffers(), this.registerShader("default", B);
    for (const i of this.shaderMap.values()) {
      const n = i.builder.build(this);
      i.shader = new w(e, ae, oe(n));
    }
    this.shaderProgram = new w(e, G, se), this.maskShaderProgram = new w(e, G, ne), this.vbo = e.createBuffer(), e.bindBuffer(e.ARRAY_BUFFER, this.vbo);
    const t = new Float32Array(b * 4 * 4);
    for (let i = 0; i < b; ++i)
      t.set(A.quad, i * 4 * 4);
    e.bufferData(e.ARRAY_BUFFER, t, e.STATIC_DRAW);
    const r = [0, 1, 2, 1, 2, 3];
    this.ebo = e.createBuffer(), e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this.ebo);
    const s = new Uint32Array(b * 6);
    for (let i = 0; i < b; ++i)
      for (let n = 0; n < 6; ++n)
        s[i * 6 + n] = r[n] + 4 * i;
    e.bufferData(e.ELEMENT_ARRAY_BUFFER, s, e.STATIC_DRAW), e.enable(e.BLEND), e.blendFunc(e.SRC_ALPHA, e.ONE_MINUS_SRC_ALPHA), this.initialized = !0;
  }
  renderScene(e, t, r, s, i) {
    e.bind(), this.gl.clearColor(s.r, s.g, s.b, s.a), this.gl.clear(this.gl.COLOR_BUFFER_BIT), t.use(), this.gl.uniform2f(t.getUniform("uViewportDimensions"), r.vw, r.vh), this.gl.uniform2f(t.getUniform("uCameraPos"), r.position.x, r.position.y), this.gl.activeTexture(this.gl.TEXTURE0);
    for (let n of i)
      n.render(t);
    e.unbind();
  }
  render(e, t) {
    const r = [];
    for (const i of e.getLayersOrdered()) {
      if (!this.layersMap.has(i)) {
        const o = new ce(this.gl, this, i.isStatic);
        this.layersMap.set(i, o);
      }
      const n = this.layersMap.get(i);
      n.needsUpdate && n.upload(i.getSpritesOrdered()), r.push(n);
    }
    this.renderScene(this.framebuffers[0], this.shaderProgram, t, this.clearColor, r), this.renderScene(this.framebuffers[1], this.maskShaderProgram, t, L, r);
    const s = performance.now() * 1e-3;
    for (let i = 0; i < this.pass.length; ++i) {
      const n = this.pass[i], o = this.shaderMap.get(n.shader);
      if (!o)
        throw new Error("Unknown shader " + n.shader);
      const a = o.shader;
      let l = this.canvas.width, u = this.canvas.height;
      if (n.output !== -1) {
        const f = this.framebuffers[v.clamp(n.output, 0, T - 1)];
        l = f.width, u = f.height, f.bind();
      } else
        this.gl.viewport(0, 0, l, u);
      a.use();
      const m = [{ name: "time", value: s }, { name: "resolution", value: [l, u] }].concat(n.uniforms ?? []), x = o.builder.getUniforms();
      for (let f of x) {
        const h = m.find((p) => p.name === f.name);
        if (h) {
          const p = typeof h.value == "number" ? [h.value] : h.value, d = a.getUniform("uniforms." + f.name);
          switch (f.type) {
            case "float":
              this.gl.uniform1f(d, p[0]);
              break;
            case "vec2":
              this.gl.uniform2fv(d, p);
              break;
            case "vec3":
              this.gl.uniform3fv(d, p);
              break;
            case "vec4":
              this.gl.uniform4fv(d, p);
              break;
          }
        }
      }
      for (let f = 0; f < C; f++) {
        const h = n.inputs[f] ?? n.inputs[0], p = this.framebuffers[v.clamp(h, 0, T - 1)].texture;
        this.gl.activeTexture(this.gl.TEXTURE0 + f), this.gl.bindTexture(this.gl.TEXTURE_2D, p);
        const d = a.getUniform(`uChannel${f}`);
        this.gl.uniform1i(d, f);
      }
      this.gl.drawArrays(this.gl.TRIANGLES, 0, 3);
      for (let f = 0; f < C; f++)
        this.gl.activeTexture(this.gl.TEXTURE0 + f), this.gl.bindTexture(this.gl.TEXTURE_2D, null);
      n.output !== -1 && this.framebuffers[v.clamp(n.output, 0, T - 1)].unbind();
    }
    for (const [i, n] of this.layersMap)
      n.lifetime <= 0 && (this.layersMap.delete(i), n.destroy());
  }
  getTextureInfo(e) {
    const t = this.texturesMap.get(e);
    if (!t) throw new Error("Texture not found: " + e);
    return t;
  }
  getVBO() {
    return this.vbo;
  }
  getEBO() {
    return this.ebo;
  }
  createTexture(e) {
    const t = this.gl, r = t.createTexture();
    return t.bindTexture(t.TEXTURE_2D, r), t.texImage2D(t.TEXTURE_2D, 0, t.RGBA8, t.RGBA, t.UNSIGNED_BYTE, e), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.NEAREST), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.NEAREST), r;
  }
  createTextureArray(e, t) {
    const r = this.gl, s = r.createBuffer();
    r.bindBuffer(r.PIXEL_UNPACK_BUFFER, s), r.bufferData(r.PIXEL_UNPACK_BUFFER, t, r.STATIC_DRAW), r.pixelStorei(r.UNPACK_ROW_LENGTH, e.imageWidth), r.pixelStorei(r.UNPACK_IMAGE_HEIGHT, e.imageHeight);
    const i = r.createTexture();
    r.bindTexture(r.TEXTURE_2D_ARRAY, i), r.texStorage3D(r.TEXTURE_2D_ARRAY, 4, r.RGBA8, e.tileWidth, e.tileHeight, e.tileCount);
    for (let n = 0; n < e.tileCount; ++n) {
      const o = n % e.columns, a = Math.floor(n / e.columns);
      r.pixelStorei(r.UNPACK_SKIP_PIXELS, o * e.tileWidth), r.pixelStorei(r.UNPACK_SKIP_ROWS, a * e.tileHeight), r.texSubImage3D(r.TEXTURE_2D_ARRAY, 0, 0, 0, n, e.tileWidth, e.tileHeight, 1, r.RGBA, r.UNSIGNED_BYTE, 0);
    }
    return r.deleteBuffer(s), r.generateMipmap(r.TEXTURE_2D_ARRAY), r.texParameteri(r.TEXTURE_2D_ARRAY, r.TEXTURE_MAG_FILTER, r.NEAREST), r.texParameteri(r.TEXTURE_2D_ARRAY, r.TEXTURE_MIN_FILTER, r.NEAREST), i;
  }
}
class ce {
  constructor(e, t, r) {
    this.gl = e, this.renderer = t, this.isStatic = r, this.needsUpdate = !0, this.drawCalls = [], this.lifetime = S, this.vao = e.createVertexArray(), e.bindVertexArray(this.vao), e.bindBuffer(e.ARRAY_BUFFER, t.getVBO()), e.enableVertexAttribArray(0), e.vertexAttribPointer(0, 2, e.FLOAT, !1, 16, 0), e.enableVertexAttribArray(1), e.vertexAttribPointer(1, 2, e.FLOAT, !1, 16, 8);
    const s = 44;
    this.spriteBuffer = e.createBuffer(), e.bindBuffer(e.ARRAY_BUFFER, this.spriteBuffer), e.bufferData(e.ARRAY_BUFFER, (this.isStatic ? b : I) * 4 * s, this.isStatic ? e.STATIC_DRAW : e.DYNAMIC_DRAW), e.enableVertexAttribArray(2), e.vertexAttribPointer(2, 2, e.FLOAT, !1, s, 0), e.enableVertexAttribArray(3), e.vertexAttribPointer(3, 2, e.FLOAT, !1, s, 8), e.enableVertexAttribArray(4), e.vertexAttribPointer(4, 1, e.FLOAT, !1, s, 16), e.enableVertexAttribArray(5), e.vertexAttribIPointer(5, 4, e.UNSIGNED_SHORT, s, 20), e.enableVertexAttribArray(6), e.vertexAttribPointer(6, 4, e.FLOAT, !1, s, 28), e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, t.getEBO()), e.bindVertexArray(null);
  }
  upload(e) {
    const t = this.gl;
    t.bindBuffer(t.ARRAY_BUFFER, this.spriteBuffer), t.bufferSubData(t.ARRAY_BUFFER, 0, A.createSpritesData(e)), this.isStatic && (this.needsUpdate = !1), this.drawCalls.length = 0;
    let r = null;
    for (let s = 0; s < e.length; ++s) {
      const i = e[s].tileset.name;
      !r || i !== r.texName ? (r = { texName: i, spriteOffset: s, spriteCount: 1 }, this.drawCalls.push(r)) : r.spriteCount++;
    }
  }
  render(e) {
    const t = this.gl;
    t.bindVertexArray(this.vao);
    for (const r of this.drawCalls) {
      const s = this.renderer.getTextureInfo(r.texName);
      t.bindTexture(t.TEXTURE_2D, s.texture), this.gl.uniform2f(e.getUniform("uTilesetDimensions"), s.tileset.imageWidth, s.tileset.imageHeight), t.drawElements(t.TRIANGLES, 6 * r.spriteCount, t.UNSIGNED_INT, r.spriteOffset * 6 * 4);
    }
    t.bindVertexArray(null), this.lifetime = S;
  }
  destroy() {
    this.gl.deleteBuffer(this.spriteBuffer), this.gl.deleteVertexArray(this.vao);
  }
}
const he = async () => {
  const e = await (await navigator.gpu?.requestAdapter())?.requestDevice();
  if (!e) return null;
  const t = navigator.gpu.getPreferredCanvasFormat();
  return {
    device: e,
    format: t
  };
}, z = `
struct VSInput {
    @location(0) vertexPos: vec2f,
    @location(1) texCoord: vec2f,
    
    @location(2) tilePos: vec2f,
    @location(3) tileScale: vec2f,
    @location(4) tileAngle: f32,
    @location(5) tileRegion: vec2u,

    @location(6) maskColor: vec4f
}

struct Camera {
    pos: vec2f,
    viewportDimensions: vec2f
}

@group(0) @binding(0)
var<uniform> camera: Camera;

@group(1) @binding(2)
var<uniform> tilesetDimensions: vec2f;

struct VSOutput {
    @builtin(position) pos: vec4f,
    @location(0) uv: vec2f,
    @location(1) maskColor: vec4f
}

@vertex
fn vs_main(input: VSInput) -> VSOutput {
    var out: VSOutput;

    out.maskColor = input.maskColor;

    let x = f32(input.tileRegion.x & 0xFFFFu);
    let y = f32(input.tileRegion.x >> 16);
    let w = f32(input.tileRegion.y & 0xFFFFu);
    let h = f32(input.tileRegion.y >> 16);

    let tileRegion = vec4f(x, y, w, h);

    let flippedTexCoord = vec2f(input.texCoord.x, 1.0 - input.texCoord.y);
    out.uv = (tileRegion.xy + flippedTexCoord * tileRegion.zw) / tilesetDimensions;

    let c = cos(input.tileAngle);
    let s = sin(input.tileAngle);
    let rotatedPos = vec2f(
        input.vertexPos.x * c - input.vertexPos.y * s,
        input.vertexPos.x * s + input.vertexPos.y * c
    );
    let worldPos = rotatedPos * input.tileScale + input.tilePos;
    let pixelPos = worldPos - camera.pos;
    let clipPos = vec2f(pixelPos.x / camera.viewportDimensions.x, 1.0 - pixelPos.y / camera.viewportDimensions.y) * 2.0 - 1.0;
    out.pos = vec4f(clipPos, 0.0, 1.0);

    return out;
}`, fe = `

@group(1) @binding(0)
var spriteSampler: sampler;

@group(1) @binding(1)
var spriteTexture: texture_2d<f32>;

@fragment
fn fs_main(input: VSOutput) -> @location(0) vec4f {
    return textureSample(spriteTexture, spriteSampler, input.uv);
}
`, de = `
@group(1) @binding(0)
var spriteSampler: sampler;

@group(1) @binding(1)
var spriteTexture: texture_2d<f32>;

@fragment
fn fs_main(input: VSOutput) -> @location(0) vec4f {
    let texColor: vec4f = textureSample(spriteTexture, spriteSampler, input.uv);
    return vec4f(input.maskColor.xyz, texColor.w * input.maskColor.a);
}
`, me = z + fe, pe = z + de, ge = (c) => `

struct VSOutput {
    @builtin(position) pos: vec4f,
    @location(0) uv: vec2f
}

@vertex
fn vs_main(@builtin(vertex_index) vertexIndex: u32) -> VSOutput {
    var out: VSOutput;

    let x = f32((vertexIndex & 1) << 2);
    let y = f32((vertexIndex & 2) << 1);

    out.uv = vec2f(x, 2.0 - y) / 2.0;
    out.pos = vec4f(x - 1.0, y - 1.0, 0.0, 1.0);
    return out;
}

struct Uniforms {
${c.uniforms.map((e) => "    " + e).join(`,
`)}
}

@group(0) @binding(0)
var<uniform> uniforms: Uniforms;

@group(1) @binding(0)
var defaultSampler: sampler;

@group(1) @binding(1)
var channel0: texture_2d<f32>;

@group(1) @binding(2)
var channel1: texture_2d<f32>;

@group(1) @binding(3)
var channel2: texture_2d<f32>;

@group(1) @binding(4)
var channel3: texture_2d<f32>;

@group(1) @binding(5)
var channel4: texture_2d<f32>;

@group(1) @binding(6)
var channel5: texture_2d<f32>;

@group(1) @binding(7)
var channel6: texture_2d<f32>;

@group(1) @binding(8)
var channel7: texture_2d<f32>;

fn texture(ch: i32, uv: vec2f) -> vec4f {
    let scaledUV = uv;

    switch (ch) {
        case 1:  { return textureSample(channel1, defaultSampler, scaledUV); }
        case 2:  { return textureSample(channel2, defaultSampler, scaledUV); }
        case 3:  { return textureSample(channel3, defaultSampler, scaledUV); }
        case 4:  { return textureSample(channel4, defaultSampler, scaledUV); }
        case 5:  { return textureSample(channel5, defaultSampler, scaledUV); }
        case 6:  { return textureSample(channel6, defaultSampler, scaledUV); }
        case 7:  { return textureSample(channel7, defaultSampler, scaledUV); }
        default: { return textureSample(channel0, defaultSampler, scaledUV); }
    }
}

fn mainImage(fragCoord: vec2f) -> vec4f {
    var fragColor: vec4f;
${c.mainImage.map((e) => "    " + e).join(`
`)}
    return fragColor;
}

@fragment
fn fs_main(input: VSOutput) -> @location(0) vec4f {
    let fragCoord = input.uv * uniforms.resolution;
    return mainImage(fragCoord);
}
`, xe = {
  componentMap: { r: "x", g: "y", b: "z", a: "w" },
  declareVar: (c, e, t = !1) => {
    const r = `${c}: ${e === "float" ? "f32" : e + "f"}`;
    return t ? r : `var ${r};`;
  }
};
class Te {
  constructor(e) {
    this.shaderMap = /* @__PURE__ */ new Map(), this.layersMap = /* @__PURE__ */ new Map(), this.texturesMap = /* @__PURE__ */ new Map(), this.canvas = e, this.clearColor = new _(0, 0, 0, 0), this.shaderMap = /* @__PURE__ */ new Map(), this.initialized = !1, this.pass = [D], this.offscreenTextures = [];
  }
  getType() {
    return "webgpu";
  }
  getBuilderOptions() {
    return xe;
  }
  addTextures(e, t) {
    for (const r of e)
      t[r.name] && this.texturesMap.set(r.name, {
        tileset: r,
        image: t[r.name]
      });
  }
  registerShader(e, t) {
    this.shaderMap.set(e, { builder: t });
  }
  setClearColor(e) {
    this.clearColor.copy(e);
  }
  setSize(e, t) {
    this.canvas.width = e, this.canvas.height = t, this.initialized && this.initOffscreenTextures(T);
  }
  getCanvas() {
    return this.canvas;
  }
  initOffscreenTextures(e) {
    for (let t = 0; t < e; ++t) {
      this.offscreenTextures[t]?.destroy();
      const r = M(t);
      this.offscreenTextures[t] = this.cfg.device.createTexture({
        size: { width: this.canvas.width * r, height: this.canvas.height * r, depthOrArrayLayers: 1 },
        format: this.cfg.format,
        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING,
        label: "offscreen texture " + t
      });
    }
  }
  async init() {
    const e = await he();
    if (!e) throw new Error("WebGPU not supported");
    this.cfg = e;
    const t = this.cfg.device, r = this.canvas.getContext("webgpu");
    this.ctx = r, this.ctx.configure(this.cfg);
    for (const s of this.texturesMap.values())
      s.tileset && (s.texture = this.createTexture(s.tileset, s.image));
    this.initOffscreenTextures(T), this.sampler = t.createSampler({
      magFilter: "nearest",
      minFilter: "nearest",
      addressModeU: "clamp-to-edge",
      addressModeV: "clamp-to-edge"
    }), this.fullscreenSampler = t.createSampler({
      magFilter: "linear",
      minFilter: "linear",
      addressModeU: "clamp-to-edge",
      addressModeV: "clamp-to-edge"
    }), this.registerShader("default", B);
    for (const [s, i] of this.shaderMap.entries()) {
      const n = ge(i.builder.build(this)), o = t.createShaderModule({
        label: s + " shader module",
        code: n
      }), a = t.createRenderPipeline({
        layout: "auto",
        vertex: {
          module: o,
          entryPoint: "vs_main"
        },
        fragment: {
          module: o,
          entryPoint: "fs_main",
          targets: [{ format: this.cfg.format }]
        },
        primitive: { topology: "triangle-strip" }
      }), l = t.createBuffer({
        size: N * 4,
        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
      }), u = t.createBindGroup({
        label: s + " uniform bind group",
        layout: a.getBindGroupLayout(0),
        entries: [
          { binding: 0, resource: { buffer: l } }
        ]
      });
      i.pipeline = a, i.uniformBindGroup = u, i.uniformBuffer = l;
    }
    this.commonBGL = this.cfg.device.createBindGroupLayout({
      entries: [
        { binding: 0, visibility: GPUShaderStage.FRAGMENT, sampler: {} },
        { binding: 1, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 2, visibility: GPUShaderStage.VERTEX, buffer: { type: "uniform" } }
      ]
    }), this.cameraBGL = this.cfg.device.createBindGroupLayout({
      entries: [
        { binding: 0, visibility: GPUShaderStage.VERTEX, buffer: { type: "uniform" } }
      ]
    }), this.pipeline = this.createMainPipeline(me), this.maskPipeline = this.createMainPipeline(pe), this.cameraBuffer = t.createBuffer({
      size: 16,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    }), this.cameraBindGroup = t.createBindGroup({
      layout: this.pipeline.getBindGroupLayout(0),
      entries: [{
        binding: 0,
        resource: { buffer: this.cameraBuffer }
      }]
    }), this.vbo = t.createBuffer({
      size: A.quad.byteLength,
      usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
    }), t.queue.writeBuffer(this.vbo, 0, A.quad);
  }
  createMainPipeline(e) {
    const t = this.cfg.device.createShaderModule({
      code: e
    }), r = this.cfg.device.createPipelineLayout({
      bindGroupLayouts: [this.cameraBGL, this.commonBGL]
    });
    return this.cfg.device.createRenderPipeline({
      layout: r,
      vertex: {
        module: t,
        entryPoint: "vs_main",
        buffers: [
          {
            arrayStride: 16,
            stepMode: "vertex",
            attributes: [
              { shaderLocation: 0, offset: 0, format: "float32x2" },
              { shaderLocation: 1, offset: 8, format: "float32x2" }
            ]
          },
          {
            arrayStride: 44,
            stepMode: "instance",
            attributes: [
              { shaderLocation: 2, offset: 0, format: "float32x2" },
              { shaderLocation: 3, offset: 8, format: "float32x2" },
              { shaderLocation: 4, offset: 16, format: "float32" },
              { shaderLocation: 5, offset: 20, format: "uint32x2" },
              { shaderLocation: 6, offset: 28, format: "float32x4" }
            ]
          }
        ]
      },
      fragment: {
        module: t,
        entryPoint: "fs_main",
        targets: [
          {
            format: this.cfg.format,
            blend: {
              color: {
                srcFactor: "src-alpha",
                dstFactor: "one-minus-src-alpha",
                operation: "add"
              },
              alpha: {
                srcFactor: "one",
                dstFactor: "one-minus-src-alpha",
                operation: "add"
              }
            }
          }
        ]
      },
      primitive: { topology: "triangle-strip" }
    });
  }
  renderScene(e, t, r, s, i) {
    const n = e.beginRenderPass({
      colorAttachments: [{
        clearValue: s,
        view: r.createView(),
        loadOp: "clear",
        storeOp: "store"
      }]
    });
    n.setPipeline(t), n.setBindGroup(0, this.cameraBindGroup), n.setVertexBuffer(0, this.vbo);
    for (const o of i)
      o.render(n);
    n.end();
  }
  render(e, t) {
    const r = [];
    for (const o of e.getLayersOrdered()) {
      if (!this.layersMap.has(o)) {
        const l = new be(this, o.isStatic);
        this.layersMap.set(o, l);
      }
      const a = this.layersMap.get(o);
      a.needsUpdate && a.upload(o.getSpritesOrdered()), r.push(a);
    }
    this.cfg.device.queue.writeBuffer(
      this.cameraBuffer,
      0,
      t.position.toArray()
    ), this.cfg.device.queue.writeBuffer(
      this.cameraBuffer,
      8,
      new Float32Array([t.vw, t.vh])
    );
    const s = this.cfg.device.createCommandEncoder();
    this.renderScene(s, this.pipeline, this.offscreenTextures[0], this.clearColor, r), this.renderScene(s, this.maskPipeline, this.offscreenTextures[1], L, r);
    const i = performance.now() * 1e-3;
    for (let o = 0; o < this.pass.length; ++o) {
      const a = this.pass[o], l = this.shaderMap.get(a.shader);
      if (!l)
        throw new Error("Unknown shader " + a.shader);
      const u = [
        { binding: 0, resource: this.fullscreenSampler }
      ];
      for (let g = 0; g < C; g++) {
        const E = a.inputs[g] ?? a.inputs[0], R = this.offscreenTextures[v.clamp(E, 0, T - 1)];
        u.push({
          binding: g + 1,
          resource: R.createView()
        });
      }
      const m = a.output === -1 ? this.ctx.getCurrentTexture() : this.offscreenTextures[v.clamp(a.output, 0, T - 1)], x = l.builder.getUniforms(), f = [{ name: "time", value: i }, { name: "resolution", value: [m.width, m.height] }].concat(a.uniforms ?? []), h = new Float32Array(N);
      for (let g of x) {
        const E = f.find((R) => R.name === g.name);
        if (E) {
          const R = typeof E.value == "number" ? [E.value] : E.value;
          h.set(R, g.offset);
        }
      }
      this.cfg.device.queue.writeBuffer(l.uniformBuffer, 0, h);
      const p = this.cfg.device.createBindGroup({
        label: a.shader + " texture bind group",
        layout: l.pipeline.getBindGroupLayout(1),
        entries: u
      }), d = s.beginRenderPass({
        colorAttachments: [{
          view: m.createView(),
          loadOp: "clear",
          storeOp: "store"
        }]
      });
      d.setPipeline(l.pipeline), d.setBindGroup(0, l.uniformBindGroup), d.setBindGroup(1, p), d.draw(3), d.end();
    }
    const n = s.finish();
    this.cfg.device.queue.submit([n]);
    for (const [o, a] of this.layersMap)
      a.lifetime <= 0 && (a.destroy(), this.layersMap.delete(o));
  }
  createTexture(e, t) {
    const r = this.cfg.device.createTexture({
      size: {
        width: e.imageWidth,
        height: e.imageHeight,
        depthOrArrayLayers: 1
      },
      format: "rgba8unorm",
      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT
    });
    return this.cfg.device.queue.copyExternalImageToTexture, this.cfg.device.queue.copyExternalImageToTexture(
      { source: t },
      { texture: r },
      [e.imageWidth, e.imageHeight, 1]
    ), r;
  }
  createTextureArray(e, t) {
    const r = e.tileWidth, s = e.tileHeight, i = this.cfg.device.createTexture({
      size: {
        width: r,
        height: s,
        depthOrArrayLayers: e.tileCount
      },
      format: "rgba8unorm",
      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT
    });
    for (let n = 0; n < e.tileCount; ++n) {
      const o = Math.floor(n / e.columns), a = n % e.columns, l = new Uint8Array(r * s * 4);
      for (let u = 0; u < s; ++u) {
        const m = ((o * s + u) * e.columns + a) * r * 4, x = m + r * 4;
        l.set(t.slice(m, x), u * r * 4);
      }
      this.cfg.device.queue.writeTexture(
        {
          texture: i,
          origin: { x: 0, y: 0, z: n }
        },
        l,
        {
          bytesPerRow: r * 4,
          rowsPerImage: s
        },
        {
          width: r,
          height: s,
          depthOrArrayLayers: 1
        }
      );
    }
    return i;
  }
  getConfig() {
    return this.cfg;
  }
  getTextureInfo(e) {
    const t = this.texturesMap.get(e);
    if (!t) throw new Error("Texture not found: " + e);
    return t;
  }
  getPipeline() {
    return this.pipeline;
  }
  getSampler() {
    return this.sampler;
  }
}
class be {
  constructor(e, t) {
    this.renderer = e, this.isStatic = t, this.needsUpdate = !0, this.drawCalls = [], this.bindGroups = /* @__PURE__ */ new Map(), this.lifetime = S, this.lastTexIdx = 0, this.instanceBuffer = e.getConfig().device.createBuffer({
      label: "Instance Buffer",
      size: 24 * (t ? b : I),
      usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
    }), this.tilesetDimBuffer = e.getConfig().device.createBuffer({
      label: "Tileset Dimensions Buffer",
      size: ve * 256,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
  }
  upload(e) {
    const t = this.renderer.getConfig().device, r = this.renderer.getPipeline(), s = this.renderer.getSampler();
    t.queue.writeBuffer(this.instanceBuffer, 0, A.createSpritesData(e, !0)), this.isStatic && (this.needsUpdate = !1), this.drawCalls.length = 0;
    let i = null;
    for (let n = 0; n < e.length; ++n) {
      const o = e[n].tileset.name;
      if (!i || o !== i.texName) {
        const a = this.renderer.getTextureInfo(o);
        t.queue.writeBuffer(
          this.tilesetDimBuffer,
          this.lastTexIdx * 256,
          new Float32Array([a.tileset.imageWidth, a.tileset.imageHeight])
        );
        const l = t.createBindGroup({
          layout: r.getBindGroupLayout(1),
          entries: [
            { binding: 0, resource: s },
            { binding: 1, resource: a.texture.createView() },
            {
              binding: 2,
              resource: {
                buffer: this.tilesetDimBuffer,
                offset: this.lastTexIdx * 256,
                size: 8
              }
            }
          ]
        });
        i = {
          texName: o,
          instanceOffset: n,
          instanceCount: 1
        }, this.bindGroups.has(i.texName) || (this.bindGroups.set(i.texName, l), ++this.lastTexIdx), this.drawCalls.push(i);
      } else
        i.instanceCount++;
    }
  }
  render(e) {
    e.setVertexBuffer(1, this.instanceBuffer);
    for (const t of this.drawCalls)
      e.setBindGroup(1, this.bindGroups.get(t.texName)), e.draw(4, t.instanceCount, 0, t.instanceOffset);
    this.lifetime = S;
  }
  destroy() {
    this.instanceBuffer.destroy(), this.tilesetDimBuffer.destroy();
  }
}
const b = 1e5, I = 1e5, S = 30, ve = 16, T = 12, C = 8, N = 32, M = (c) => 1 / (1 << Math.max(0, Math.floor((c - 2) * 0.5))), D = { shader: "default", inputs: [0], output: -1 }, L = new _(0, 0, 0, 1), Ue = (c) => {
  const e = document.createElement("canvas");
  switch (c) {
    case "webgl":
      return new re(e);
    case "webgl2":
      return new ue(e);
    case "webgpu":
      return new Te(e);
    default:
      throw new Error("Unknown renderer type");
  }
};
class ye {
  constructor(e) {
    this.zIndex = e.zIndex || 0, this.tileset = e.tileset, this.tilesetRegion = e.tilesetRegion, this.isStatic = e.isStatic || !1, this.position = new y(), this.offset = new y(), this.scale = new y(1, 1), this.angle = e.angle || 0, this.maskColor = new _(0, 0, 0, 1);
  }
  setTilesetRegion(e, t, r = 1, s = 1) {
    this.tilesetRegion.x = e, this.tilesetRegion.y = t, this.tilesetRegion.width = r, this.tilesetRegion.height = s;
  }
  getTile() {
    return this.tileset.getTile(this.tilesetRegion.x, this.tilesetRegion.y);
  }
}
class _e {
  constructor() {
    this.layers = [];
  }
  addSprite(e) {
    let t = this.layers.find((r) => r.isStatic === e.isStatic && r.zIndex === e.zIndex);
    return t || (t = new X({
      zIndex: e.zIndex,
      isStatic: e.isStatic
    }), this.layers.push(t)), t.add(e), e;
  }
  addTilemap(e, t = {}) {
    const r = e.getLayers();
    let s = 0;
    const i = [], n = [];
    for (const o of r) {
      const a = t.layers?.find((l) => l.name === o.name);
      switch (a?.zIndex && (s = a.zIndex), o.renderOrder !== "manual" && this.createLayer({
        zIndex: s,
        renderOrder: o.renderOrder,
        isStatic: !1
      }), o.type) {
        case "tilelayer": {
          for (let l = 0; l < o.height; ++l)
            for (let u = 0; u < o.width; ++u) {
              const m = o.getTile(u, l);
              if (!m) continue;
              const x = new ye({
                isStatic: m.animation === void 0,
                zIndex: s,
                tileset: m.tileset,
                tilesetRegion: { x: m.x, y: m.y }
              });
              if (x.position.set((u + o.x) * e.tileWidth, (l + o.y) * e.tileHeight), x.scale.set(e.tileWidth, e.tileHeight), i.push(this.addSprite(x)), m.animation) {
                const f = new q(x);
                f.play({ x: m.x, y: m.y }, { repeat: !0 }), n.push(f);
              }
            }
          break;
        }
        case "objectgroup": {
          if (t.onObject) {
            const l = o.getObjects();
            for (const u of l)
              t.onObject(this, u, o, s);
          }
          break;
        }
      }
      ++s;
    }
    return {
      sprites: i,
      animators: n
    };
  }
  createLayer(e) {
    const t = new X(e);
    return this.layers.push(t), t;
  }
  getLayersOrdered() {
    return this.layers.sort((e, t) => e.zIndex - t.zIndex);
  }
}
class X {
  constructor(e) {
    this.zIndex = e.zIndex, this.isStatic = e.isStatic, this.renderOrder = e.renderOrder || "manual", this.sprites = [];
  }
  add(e) {
    if (this.renderOrder === "manual") {
      let t = -1;
      for (let r = this.sprites.length - 1; r >= 0; --r)
        if (this.sprites[r].tileset.name <= e.tileset.name) {
          t = r;
          break;
        }
      t === -1 ? this.sprites.unshift(e) : this.sprites.splice(t + 1, 0, e);
    } else
      this.sprites.push(e);
  }
  getSpritesOrdered() {
    switch (this.renderOrder) {
      case "topdown":
        return this.sprites.sort((e, t) => e.position.y - t.position.y);
      default:
        return this.sprites;
    }
  }
}
class k {
  constructor(e, t, r, s, i) {
    this.tileset = e, this.id = t, this.x = r, this.y = s, this.properties = i?.properties, this.animation = i?.animation;
  }
  getProperty(e) {
    return this.properties?.find((t) => t.name === e) ?? null;
  }
}
const F = class F {
  constructor(e) {
    if (this.name = e.name, this.imageWidth = e.imagewidth, this.imageHeight = e.imageheight, this.tileWidth = e.tilewidth, this.tileHeight = e.tileheight, this.columns = e.columns, this.tileCount = e.tilecount, this.margin = e.margin || 0, this.spacing = e.spacing || 0, this.tiledata = /* @__PURE__ */ new Map(), e.tiles)
      for (let t of e.tiles)
        this.tiledata.set(t.id, t);
  }
  static async load(e) {
    if (!this.cache.has(e)) {
      const t = await Y.loadJson(e);
      this.cache.set(e, new F(t));
    }
    return this.cache.get(e);
  }
  static getByName(e) {
    return this.cache.values().find((t) => t.name === e) || null;
  }
  getTile(e, t) {
    if (e < 0 || e >= this.columns || t < 0 || t >= Math.ceil(this.tileCount / this.columns)) return null;
    const r = t * this.columns + e, s = this.tiledata.get(r);
    return new k(this, r, e, t, s);
  }
  getTileById(e) {
    if (e >= this.tileCount || e < 0) return null;
    const t = e % this.columns, r = Math.floor(e / this.columns), s = this.tiledata.get(e);
    return new k(this, e, t, r, s);
  }
  getTileXY(e) {
    const t = e % this.columns, r = Math.floor(e / this.columns);
    return { x: t, y: r };
  }
};
F.cache = /* @__PURE__ */ new Map();
let P = F;
class H {
  constructor(e) {
    this.name = e.name, this.x = e.x, this.y = e.y, this.width = e.width, this.height = e.height, this.type = e.type, this.renderOrder = e.draworder || "manual";
  }
}
class Ee extends H {
  constructor(e) {
    super(e), this.data = e.data;
  }
  getTile(e, t) {
    const r = this.data[t * this.width + e];
    return r - 1 == -1 ? null : this.tilemap.getTileById(r);
  }
}
class Ae extends H {
  constructor(e) {
    super(e), this.objects = e.objects;
  }
  getObjects() {
    return this.objects;
  }
}
class $ {
  constructor(e, t, r, s) {
    this.width = e, this.height = t, this.tileWidth = r, this.tileHeight = s, this.tilesets = [], this.layers = [];
  }
  static async load(e, t) {
    const r = await Y.loadJson(e), s = new $(r.width, r.height, r.tilewidth, r.tileheight);
    for (const i of r.layers)
      switch (i.type) {
        case "tilelayer":
          s.addLayer(new Ee(i));
          break;
        case "objectgroup":
          s.addLayer(new Ae(i));
          break;
      }
    for (let i of r.tilesets) {
      let n;
      if (i.source) {
        const o = i.source.split(/(\/|\\\/)/), a = o[o.length - 1].split(".tsj")[0];
        if (!t[a]) throw new Error("Source is missing for tileset: " + a);
        n = await P.load(t[a]);
      } else
        n = new P(i);
      s.tilesets.push({ tileset: n, firstGlobalId: i.firstgid });
    }
    return s;
  }
  addLayer(e) {
    e.tilemap = this, this.layers.push(e);
  }
  getTilesets() {
    return this.tilesets.map((e) => e.tileset);
  }
  getTilesetByName(e) {
    return this.tilesets.find((t) => t.tileset.name === e)?.tileset || null;
  }
  getLayers() {
    return this.layers;
  }
  getLayerByName(e) {
    return this.layers.find((t) => t.name === e) || null;
  }
  getTileById(e) {
    const t = this.tilesets;
    for (let r of t) {
      let s = r.tileset.getTileById(e - r.firstGlobalId);
      if (s)
        return s;
    }
    return null;
  }
}
export {
  q as Animator,
  Se as Camera,
  _ as Color,
  Re as LinearSpline,
  we as LinearSplineVector,
  _e as Scene,
  K as ShaderBuilder,
  ye as Sprite,
  $ as Tilemap,
  P as Tileset,
  y as Vector,
  Y as assets,
  Ue as createRenderer,
  v as math,
  U as matrix
};
